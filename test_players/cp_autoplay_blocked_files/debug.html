<!DOCTYPE html>
<!-- saved from url=(0053)http://emp.stage.bbc.co.uk/emp/SMPj/2.24.0/debug.html -->
<html class="ReithSans-loaded"><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252"><script type="text/javascript" src="./require(1).js"></script>
<script type="text/javascript">

window.validDomains = "bbc\\.co\\.uk,bbc\\.com,bbcconnectedstudio\\.co\\.uk,metabroadcast\\.com,bbcnewshq\\.com,twofourstaging\\.net,codeandtheory\\.net,thespace\\.org,plateau\\.com,bbcstore\\.com,microbit\\.co\\.uk,bbcarchdev\\.net,acropolis\\.org\\.uk,audiencesportal\\.co\\.uk,thirteenlostyears\\.co\\.uk,bbcdigitalguerrillas\\.co\\.uk,bbc-massive\\.com,britbox\\.com,bbcomtraining\\.co\\.uk,bbcrewind\\.co\\.uk,gomolearning\\.com,newslabs\\.co,bbcnewslabs\\.co\\.uk,bbccreative\\.co\\.uk,api\\.bbci\\.co\\.uk,csod\\.com,bbcmediaactionilearn\\.com,bbcnitechops\\.co\\.uk,bbcnireland\\.co\\.uk,bbcverticals\\.com,gomocentral\\.com,riddle\\.com".split(",");
window.validWholeDomains = "bbcmediaaction1.sharepoint.com,ne-scorm.365.systems".split(",");

// Browser capability tests e.g. for Windows Phone 8 Internet Explorer
if (typeof window.JSON !== 'object') {
    document.write('<script type="text/javascript" src="json.js"></scr'+'ipt>');
}
try{
    Object.defineProperty(this, "test", {} );
}
catch(e){
    // Redirect
    window.location.href="UnsupportedError.html";
}
</script>
<style type="text/css">
.p_audioui_intervalButton {
    width: 48px;
    height: 48px;
    fill: #FFFFFF;
    color: #FFFFFF;
    overflow: visible;
}

.p_audioui_intervalNumber {
    position: absolute;
    top: 20px;
    text-align: center;
    left: 0;
    right: 0;
    font-size: 14px;
    line-height: 14px;
}

.p_audioui_intervalNumber_sign {
    display: none;
}

.p_audioui_intervalButton:not([disabled]).pressed .p_audioui_intervalNumber {
    top: -20px;
}

@media (prefers-reduced-motion) {

    .p_audioui_intervalButton:not([disabled]).pressed .p_audioui_intervalNumber {
        top: 20px;
    }

}

.p_audioui_intervalButton:not([disabled]).pressed .p_audioui_intervalNumber_sign {
    display: inline;
}

@media (prefers-reduced-motion) {

    .p_audioui_intervalButton:not([disabled]).pressed .p_audioui_intervalNumber_sign {
        display: none;
    }

}

.p_audioui_intervalButton .p_audioui_intervalArrow {
    -webkit-transition: 200ms -webkit-transform ease-out;
            transition: 200ms -webkit-transform ease-out;
            transition: 200ms transform ease-out;
            transition: 200ms transform ease-out, 200ms -webkit-transform ease-out;
    -webkit-transform-origin: 24px 26px;
            transform-origin: 24px 26px;
}

.p_audioui_intervalButton:not([disabled]).pressed #p_audioui_backInterval_backArrow {
    -webkit-transform: rotate(-70deg);
            transform: rotate(-70deg);
}

.p_audioui_intervalButton:not([disabled]).pressed #p_audioui_forwardInterval_forwardArrow {
    -webkit-transform: rotate(70deg);
            transform: rotate(70deg);
}
.p_audioui_jumpButton {
    width: 48px;
    height: 48px;
    fill: #FFFFFF;
    color: #FFFFFF;
}

#p_audioui_backToStartButton_text {
    position: absolute;
    top: 22px;
    right: 17px;
    font-size: 10px;
    line-height: 10px;
}

#p_audioui_toLiveButton_text {
    position: absolute;
    top: 22px;
    left: 17px;
    font-size: 10px;
    line-height: 10px;
}
#p_audioui_playpause {
    width: 68px;
    height: 68px;
    fill: #FFFFFF;
}

#p_audioui_playpause_circle {
    stroke: rgb(255,255,255);
    stroke-width: 3;
    fill: none;
    -webkit-transition: 100ms opacity linear;
            transition: 100ms opacity linear;
}

.p_fadingRing {
    -webkit-transition: 100ms opacity linear;
            transition: 100ms opacity linear;
}

#p_audioui_playpause_highlightCircle {
    opacity: 0;
    -webkit-transition: 100ms opacity linear;
            transition: 100ms opacity linear;
}

#p_audioui_playpause.hovering #p_audioui_playpause_highlightCircle,
#p_audioui_playpause.pressed #p_audioui_playpause_highlightCircle,
.nonPointerFocus #p_audioui_playpause.focused #p_audioui_playpause_highlightCircle {
    opacity: 1;
}

#p_audioui_playpause_playIcon {
    -webkit-transform-origin: 34px 34px;
            transform-origin: 34px 34px;
    -webkit-transition: 100ms -webkit-transform ease-out;
            transition: 100ms -webkit-transform ease-out;
            transition: 100ms transform ease-out;
            transition: 100ms transform ease-out, 100ms -webkit-transform ease-out;
    -webkit-transform: scale(1);
            transform: scale(1);
}

#p_audioui_playpause.pressed #p_audioui_playpause_playIcon {
    -webkit-transform: scale(0.8);
            transform: scale(0.8);
}

#p_audioui_playpause_pauseIcon {
    -webkit-transform-origin: 34px 34px;
            transform-origin: 34px 34px;
    opacity: 0;
    -webkit-transition: 100ms -webkit-transform ease-out;
            transition: 100ms -webkit-transform ease-out;
            transition: 100ms transform ease-out;
            transition: 100ms transform ease-out, 100ms -webkit-transform ease-out;
    -webkit-transform: scale(1);
            transform: scale(1);
}

#p_audioui_playpause.pressed #p_audioui_playpause_pauseIcon {
    -webkit-transform: scale(0.8);
            transform: scale(0.8);
}
.audioUI #p_audioui_leftTimeDisplay {
    color: #FFF;
    font-size: 12px;
    line-height: 12px;
    pointer-events: none;
    transition: opacity 1000ms linear;
}

.audioUI #p_audioui_rightTimeDisplay {
    color: #FFF;
    font-size: 12px;
    line-height: 12px;
    pointer-events: none;
    transition: opacity 1000ms linear;
}

.audioUI #p_audioui_rightTimeDisplay span {
    display: block;
    float: right;
    line-height: 12px;
    height: 12px;
    margin-left: 3px;
    transition: opacity 1000ms linear;
}

.audioUI #p_audioui_rightTimeDisplay svg {
    display: block;
    float: right;
    fill: #FFFFFF;
    transition: opacity 1000ms linear;
    -webkit-transform: translateZ(0);
            transform: translateZ(0); /* translateZ fixes Safari jitter - creates new layer for halo */
}

.p_audioui_liveIconCentre {
    animation: 1.7s ease infinite pulsate;
}

@media (prefers-reduced-motion) {

    .p_audioui_liveIconCentre {
        animation: none;
    }

}

@keyframes pulsate {
    from {
        opacity: 1;
    }
    50% {
        opacity: 0.3;
    }
    to {
        opacity: 1;
    }
}
.audioUI #p_audioui_container {
    position: absolute;
    width: 100%;
    z-index: 160;
    bottom: 0;
}




.audioUI .p_playerSeekBarHolder {
    position: absolute;
    bottom: 98px;
}

/**** AUDIO CORE CONTROLS ****/

.audioButton {
    margin: 0;
    padding: 0;
    border: 0;
    outline: 0;
    background-color: transparent;
    cursor: pointer;
    transition: opacity 1000ms linear;
    opacity: 1;
    -webkit-tap-highlight-color: transparent;
}

.audioButton .p_audioButton_buttonInner {
    position: relative; /* For EDGE: To force opacity inheritance https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/5116981/ */
    width: 100%;
    height: 100%;
}

.audioButton[disabled] {
    cursor: default;
    pointer-events: none;
}

.audioButton[disabled] .p_audioButton_buttonInner {
    opacity: 0.4;
}

.audioButton.hidden,
.audioButton.removed {
    opacity: 0 !important;
    pointer-events: none;
    cursor: default;
}

.audioUI #p_audioui_coreControls {
    position: absolute;
    bottom: 16px;
    left: 50%;
    /*width: 342px;
    margin-left: -171px;*/
}

.audioUI #p_audioui_playpause {
    position: absolute;
    bottom: 0;
    left: -34px;
}

.audioUI #p_audioui_ctaDuration {
    position: absolute;
    bottom: 26px;
    left: 50px;
    width: 150px;
    color: #FFF;
    font-size: 15px;
    line-height: 15px;
    opacity: 1;
    transition: opacity 1000ms linear;
}

.audioUI #p_audioui_ctaDuration.hidden,
.audioUI #p_audioui_ctaDuration.removed {
    opacity: 0;
    transition-duration: 0s;
}

.audioUI #p_audioui_backInterval {
    position: absolute;
    bottom: 10px;
    right: 62px;
}

.audioUI #p_audioui_forwardInterval {
    position: absolute;
    bottom: 10px;
    left: 62px;
}

.audioUI #p_audioui_previousButton {
    position: absolute;
    bottom: 10px;
    right: 123px;
}

.audioUI #p_audioui_nextButton {
    position: absolute;
    bottom: 10px;
    left: 123px;
}

.audioUI #p_audioui_backToStartButton {
    position: absolute;
    bottom: 10px;
    right: 123px;
}

.audioUI #p_audioui_toLiveButton {
    position: absolute;
    bottom: 10px;
    left: 123px;
}

.audioUI .p_volumeControls {
    bottom: 26px;
    left: 8px;
}

.audioUI #p_audioui_rightRegionControls {
    position: absolute;
    right: 0;
    bottom: 27px;
}

.audioUI #p_audioui_playbackSettingsButton {
    float: right;
}

.audioUI #p_audioui_popOutPlayerButton {
    float: right;
    padding-right: 16px;
}

@media (max-width: 799px) {
    .audioUI #p_audioui_popOutPlayerButton {
        display: none;
    }

    .audioUI #p_audioui_playbackSettingsButton {
        display: none;
    }
}

/**** TIME DISPLAYS ****/

.audioUI #p_audioui_leftTimeDisplay {
    position: absolute;
    left: 16px;
    bottom: 92px;
}

.audioUI #p_audioui_rightTimeDisplay {
    position: absolute;
    right: 16px;
    bottom: 92px;
}

@media (max-width: 374px) {

    .audioUI #p_audioui_backInterval {
        right: 52px;
    }

    .audioUI #p_audioui_forwardInterval {
        left: 52px;
    }

    .audioUI #p_audioui_previousButton {
        right: 105px;
    }

    .audioUI #p_audioui_nextButton {
        left: 105px;
    }

    .audioUI #p_audioui_backToStartButton {
        right: 105px;
    }

    .audioUI #p_audioui_toLiveButton {
        left: 105px;
    }

}

@media (max-width: 399px) {

    .audioUI #p_audioui_leftTimeDisplay {
        left: 10px;
    }

    .audioUI #p_audioui_rightTimeDisplay {
        right: 10px;
    }

}
.p_errorWrapper {
    position: absolute;
    z-index: 150;
    left: 0;
    top: 0;
    height: 100%;
    width: 100%;
}

.p_errorDialog {
    display: -webkit-box;
    display: -ms-flexbox;
    display: flex;

    -webkit-box-orient: horizontal;
    -webkit-box-direction: normal;
    -ms-flex-direction: row;
    flex-direction: row;

    -webkit-box-pack: center;
    -ms-flex-pack: center;
    justify-content: center;

    -webkit-box-align: center;
    -ms-flex-align: center;
    align-items: center;

    width: 100%;
    height: 100%;
    text-decoration: none;

    vertical-align: middle;
    text-align: center;
    color: #fff;
    font-size: 18px;
    line-height: 24px;
    background-color: rgba(51,51,51,0.85);
}

.p_smallErrorVersion .p_errorDialog {
    background: rgba(51,51,51,1);
    display:block;
}

@media (min-width: 320px) and (max-width: 599px) {
    .p_errorDialog {
        font-size: 16px;
        line-height: 22px;
    }
}

@media (max-width: 319px) {
    .p_errorDialog {
        font-size: 15px;
        line-height: 20px;
    }
}

.p_errorBackground {
    vertical-align: middle;
    width: 245px;
    text-align: center;
    padding: 20px;
    background-color: transparent;
}

.p_smallErrorVersion .p_errorBackground {
    position: absolute;
    left: 0;
    height: 100%;
    width: 100%;
    background: none;
    text-align: left;
    padding: 0;
}

@media (max-width: 266px) {
    .p_errorBackground {
        width: 100%;
        padding: 0 8px;
        box-sizing: border-box;
    }
}

.p_iconHolder.alertIconHolder {
    height: 22px;
    background-size: 25.15px 22px;
    background-position: center;
    background-repeat: no-repeat;
    background-image: url(//emp.stage.bbci.co.uk/emp/assets/2.0.23/alert.png);
}

.svg .alertIconHolder {
    background-image: none;
}

.p_smallErrorVersion .alertIconHolder {
    display: inline-block;
    float: left;
    width: 44px;
    height: 100%;
    text-align: center;
    padding: 0 8px;
}

@media (max-width: 400px) {

    .p_smallErrorVersion .p_fallbackDialog .alertIconHolder {
        display:none;
    }

}

@media (max-width: 266px) {

    .alertIconHolder:not(.p_smallErrorVersion) {
        display: none;
    }

    .p_smallErrorVersion .p_errorRefreshDialog_a + .alertIconHolder {
        display: none;
    }
}

.svg .p_alertIcon {
    width: 25.15px;
    height: 22px;
}

.p_smallErrorVersion.svg .p_alertIcon {
    position: relative;
    top: 50%;
    -webkit-transform: translateY(-50%);
    -ms-transform: translateY(-50%);
    transform: translateY(-50%);
    width: 25.15px;
    height: 22px;
}

.p_smallErrorVersion div[role=alert] {
    display: block;
    overflow: hidden;
    position: relative;
    top: 50%;
    -webkit-transform: translateY(-50%);
    -ms-transform: translateY(-50%);
    transform: translateY(-50%);
}

.p_errorPrimary {
    display: inline-block;
    margin-top: 16px;
}

.p_smallErrorVersion .p_errorPrimary {
    margin: 0;
    display: block;
}

@media (max-width: 266px) {

    .p_errorPrimary {
        width: 100%;
    }

}

@media (max-width: 400px) {

    .p_smallErrorVersion .p_fallbackDialog .p_errorPrimary {
        padding: 8px;
        text-align: center;
    }

}

.p_errorPrimary a {
    color:#fff;
    font-weight:bold;
}

@media (max-width: 400px) {

    .p_smallErrorVersion.svg .p_refreshIcon {
        display: block !important;
        width: 18px;
        height: 18px;
        padding: 8px 0;
    }

}

.p_errorSecondary {
    margin-top: 31px;
    display: block;
    color: #fff;
}

.p_errorSecondary a {
    color: #fff;
}

.p_none.p_errorSecondary,
.p_smallErrorVersion .p_errorSecondary {
    display: none;
}

.p_errorDialog_a {
    display: inline-block;
    color: #fff;
    width: 227px;
    height: 34px;
    line-height: 34px;
    margin-top: 17px;
    margin-bottom: 10px;
    background-color : #191919;
    border: 5px solid transparent;
    background-clip: padding-box;
    cursor: pointer;
    -webkit-transition: background-color 0.4s ease-out;
    -moz-transition: background-color 0.4s ease-out;
    -o-transition: background-color 0.4s ease-out;
    transition: background-color 0.4s ease-out;
}

.p_smallErrorVersion .p_errorDialog_a {
    width: auto;
    text-align: center;
    margin: 0 8px 0 0;
    padding: 0 8px;
    float: right;
    position: relative;
    top: 50%;
    -webkit-transform: translateY(-50%);
    -ms-transform: translateY(-50%);
    transform: translateY(-50%);
}

.offline .p_errorDialog_a {
    display:none;
}

@media (max-width: 400px) {
    .p_smallErrorVersion .p_errorDialog_a {
        display: none;
    }

}

@media (max-width: 266px) {

    .p_errorDialog_a {
        width: 100%;
        border: 0;
    }

}

.p_errorRefreshDialog_a {
    background-size: 18px 18px;
    background-position: center;
    background-repeat: no-repeat;
    background-image: url(//emp.stage.bbci.co.uk/emp/assets/2.0.23/refresh.png);
}

.svg .p_errorRefreshDialog_a {
    background-image: none;
}

.p_smallErrorVersion .p_errorRefreshDialog_a {
    display: none;
    color: #fff;
    height: 34px;
    line-height: 34px;
    margin: 0 8px 0 0;
    padding: 0 8px;
    float: right;
    background-color : #191919;
    border: 5px solid transparent;
    background-clip: padding-box;
    cursor: pointer;
    -webkit-transition: background-color 0.4s ease-out;
    -moz-transition: background-color 0.4s ease-out;
    -o-transition: background-color 0.4s ease-out;
    transition: background-color 0.4s ease-out;
    position: relative;
    top: 50%;
    -webkit-transform: translateY(-50%);
    -ms-transform: translateY(-50%);
    transform: translateY(-50%);
}

@media (max-width: 400px) {

    .p_smallErrorVersion .p_errorRefreshDialog_a {
        display: inline-block !important;
    }

}

.p_fallbackButton {
    height:34px;
    line-height:34px;
    width:100%;
    margin-top: 19px;
    background:#191919;
    color:#fff;
    text-align:center;
    cursor:pointer;
    -webkit-transition: background-color 0.4s ease-out;
    -moz-transition: background-color 0.4s ease-out;
    -o-transition: background-color 0.4s ease-out;
    transition: background-color 0.4s ease-out;
}

.p_smallErrorVersion .p_fallbackDialog .p_fallbackButton {
    width: 245px;
    margin-top:12px;
}

@media (max-width: 400px) {

    .p_smallErrorVersion .p_fallbackDialog .p_fallbackButton {
        margin-right: auto;
        margin-left: auto;
    }

}
#p_audioui_playbackSettingsButton {
    fill: #FFFFFF;
    width: 48px;
    height: 48px;
}

#p_audioui_playbackSettingsButton.removed {
    display: none;
}
/* http://meyerweb.com/eric/tools/css/reset/
   v2.0 | 20110126
   License: none (public domain)
*/
.p_subtitlesContainer { 
    pointer-events:none;
    z-index: 9;
    width:100%;
    height:100%;
    display:block;
    position:absolute;
  }

.errorShowing .p_subtitlesContainer {
  display: none !important;
}

html, body, div, span, applet, object, iframe,
h1, h2, h3, h4, h5, h6, p, blockquote, pre,
a, abbr, acronym, address, big, cite, code,
del, dfn, em, img, ins, kbd, q, s, samp,
small, strike, strong, sub, sup, tt, var,
b, u, i, center,
dl, dt, dd, ol, ul, li,
fieldset, form, label, legend,
table, caption, tbody, tfoot, thead, tr, th, td,
article, aside, canvas, details, embed,
figure, figcaption, footer, header, hgroup,
menu, nav, output, ruby, section, summary,
time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
  font-size: 100%;
  font: inherit;
  vertical-align: baseline;
}
/* HTML5 display-role reset for older browsers */
article, aside, details, figcaption, figure,
footer, header, hgroup, menu, nav, section {
  display: block;
}
ol, ul {
  list-style: none;
}
blockquote, q {
  quotes: none;
}
blockquote:before, blockquote:after,
q:before, q:after {
  content: '';
  content: none;
}
table {
  border-collapse: collapse;
  border-spacing: 0;
}

/* --- --- end of css reset --- --- */

body, html {
  margin: 0;
  padding: 0;
  overflow: hidden;
  -ms-user-select:none;
  -moz-user-select:none;
  -webkit-user-select: none;
  user-select: none;
}

video::-webkit-media-controls-start-playback-button {
  display: none !important;
  -webkit-appearance: none;
}


html {
    height: 100%;
    width: 100%;
}

body {
  background-color: transparent;
  margin:0;
  padding:0;
}

body.classicUI {
    background-color: #000;
}

body.classicUI.transparent {
 background-color: transparent;
}

.p_background {
  position:fixed;
  left:0;
  right:0;
  top:0;
  bottom:0;
  background-color:#000;
}

.p_background.transparent { 
  background-color: transparent;
} 

button { 
  border-radius:0px;
}

/* CSS Reset for buttons */
button.p_cta,
button.p_button,
button.p_controlBarButton {
    font-size: 1em;
    outline: none;
}

.cta .mediaContainer:hover {
    cursor: pointer;
}

.transparent .mediaContainer { 
  background-color:transparent !important;
}

.errorShowing .mediaContainer:hover {
    cursor: default;
}

.p_accessibleHitArea {
    position: absolute;
    top: 0;
    width: 100%;
    height: 100%;
}

#p_alert {
  width: 1px;
  position: absolute;
  left: -2500px;
  overflow: hidden;
  display:none;
}

.p_posterEffectsContainer,
.p_posterSlideEffectContainer,
.p_posterEffectsContainer img {
    position: absolute;
    top: 0;
    z-index: 0;
    height: 100%;
    width: 100%;
}

.p_oldSlideImage {
    z-index: 0 !important;
}

.p_newSlideImage {
    z-index: 1 !important;
}

.p_onScreen {
    left: 0;
}

.p_offScreenLeft {
    left: -100%;
}

.p_offScreenRight {
    left: 100%;
}

.p_button {
    cursor: pointer;
    border: 0;
    padding: 0;
    margin: 0;
}

.p_posterEffectsContainer {
  position:absolute;
  top:0;
  left:0;
  bottom:0;
  right:0;
}

.p_posterEffectsContainer img {
  height:100%;
  width:100%;
}

.mediaContainer {
  left: 0;
  top: 0;
  height: 100%;
  width: 100%;
  overflow: hidden;
  position: absolute;
  background-repeat: no-repeat;
  background-position: 49.99% 49.99%;
  background-size: contain;
  background-color:inherit;
}

.mediaContainer video,
.mediaContainer audio {
  /* This fixes a bug on the iPad where the video element tries to be always-on-top 
    XXX we should limit this to iPad
*/
/*  -webkit-transform-style: preserve-3d;*/
  background-color: transparent;
  position:absolute;
  left:0;
  top:0;
  height:100%;
  width:100%;
}

.classicUI .mediaContainer video,
.classicUI .mediaContainer audio {
    background-color: black;
}

body.classicUI.transparent .mediaContainer video,
body.classicUI.transparent .mediaContainer audio {
  background-color:transparent;
}

#p_swfcontainer { 
  pointer-events:none;
  position:fixed;
  left:0px;
  top:0px;
  right:0px;
  bottom:0px;
}


.errorShowing #p_swfcontainer, .flashHidden #p_swfcontainer { 
  left:-10000px;
  width:10px;
}

.displayCover:not(.fullscreen) .mediaContainer { 
    background-size: cover;
}

.videoPositionTop .mediaContainer { 
  background-position:0% 0%;
}

.videoPositionBottom .mediaContainer { 
  background-position:0% 100%;
}

.displayCover:not(.fullscreen) .mediaContainer video { 
    object-fit: cover; 
}

.videoPositionTop .mediaContainer video { 
  object-position:0% 0%;
}

.videoPositionBottom .mediaContainer video { 
  object-position:0% 100%;
}

#debugMenu {
  color: #fff;
  font-size: 15px;
  display: block;
  position: fixed;
  top:0px;
  left:0px;
  right:0px;
  bottom:0px;
  padding: 10px;
  z-index: 10;
  background-color: rgba(0, 0, 0, 0.7);
}

.p_contextMenu {
    position: fixed;
    background-color: #fff;
    border: 1px solid #333;
    border-radius: 3px;
    max-width: 350px;
    margin: 0;
    padding: 0;
    z-index: 200;
}

.p_contextMenu li:hover {
    background-color: #666;
    color: #fff;
}

.p_contextMenu li {
    list-style: none;
}

.p_contextMenuItem {
    display: inline-block;
    margin: 0 5px;
    overflow: hidden;
    text-overflow: ellipsis;
    width: calc(100% - 10px);
    font-size: 12px;
    line-height: 22px;
    cursor: pointer;
    white-space: nowrap;
    color: #000;
    text-decoration: none;
}

.p_contextMenu li:first-child {
    margin-top: 5px;
}

.p_contextMenu li:last-child {
    margin-bottom: 5px;
}

#p_remoteInput {
    position: absolute;
    top: 40px;
    right: 40px;
    padding: 8px 10px;
    width: 37px;
    color: #fff;
    letter-spacing: 3px;
    font-weight: bold;
    font-size: 18px;
    background-color: rgba(0,0,0,0.8);
}

.p_iconHolder {
    position: relative;
    height: 100%;
    width: 100%;
}

.p_iconHolder svg { 
   height:inherit;
   width:inherit;
 }

.p_cta {
  position: absolute;
  border: 0;
  left: 0;
  bottom: 0;
  width: 99%;
  display: block;
  width: 80px;
  height: 80px;
  text-decoration: none;
  -webkit-transition: background-color 0.4s ease-out;
  -moz-transition: background-color 0.4s ease-out;
  -o-transition: background-color 0.4s ease-out;
  transition: background-color 0.4s ease-out;
  background-color: rgba(0, 0, 0, 0.8);
  background-image: url(//emp.stage.bbci.co.uk/emp/assets/2.0.23/cta_play.png);
  background-repeat: no-repeat;
  background-position: center;
  background-size: 52px 52px;
  cursor: pointer;
  z-index: 150;
}

.rtlCta .p_cta {
  left: calc(100% - 80px);
}

.p_cta.p_hasDuration {
    background-position: 50% 38%;
}

.svg .p_svg {
    fill: #fff;
}

.svg .p_cta,
.svg.minimode .p_cta {
    background-image: none;
}

.svg .p_cta .p_ctaIcon {
    position: absolute;
    top: 10px;
    left: 10px;
    height: 60px;
    width: 60px;
}

.svg .p_cta.p_hasDuration .p_ctaIcon {
    top: 5px;
}

.minimode .p_cta {
  width: 60px;
  height: 60px;
  background-size: 35px 35px;
}

.minimode.svg .p_cta .p_ctaIcon {
    top: 10px;
    left: 10px;
    height: 40px;
    width: 40px;
}

.minimode.svg .p_cta.p_hasDuration .p_ctaIcon {
    top: 4px;
}

.minimode.audio .p_cta {
  background-size: 22px 22px;
}

.minimode.audio .p_cta.p_hasDuration {
    background-position: 50% 34%;
}

.p_ctaDuration {
    font-size: 0.75rem;
    position: absolute;
    bottom: 8px;
    left: 0;
    color: #fff;
    width: 80px;
}

.minimode .p_ctaDuration {
    bottom: 6px;
    width: 60px;
}

.p_none {
    display: none;
}

.minimode .p_cta {
    background-image: url(//emp.stage.bbci.co.uk/emp/assets/2.0.23/cta_play_minimode.png);
}

.p_cta.p_iplayerIcon {
    background-image: url(//emp.stage.bbci.co.uk/emp/assets/2.0.23/cta_play_iplayer.png);
    background-size: 36px 36px;
}

.svg .p_cta.p_iplayerIcon {
    background-image: none;
}

.minimode .p_cta .p_iplayerIcon{
    background-size: 27px 27px;
}

.minimode .p_cta.p_hasDuration.p_iplayerIcon {
    background-position: 50% 31%;
}

.minimode.audio .p_cta .p_iplayerIcon{
    background-size: 23px 23px;
}

.audio .p_cta {
    background-image: url(//emp.stage.bbci.co.uk/emp/assets/2.0.23/cta_play_audio.png);
    background-size: 28px 28px;
}

.audio.svg .p_cta {
    background-image: none;
}

.audio.svg .p_cta .p_ctaIcon {
    top: 9px;
    left: 9px;
    height: 62px;
    width: 62px;
}

.audio.svg .p_cta.p_hasDuration .p_ctaIcon {
    top: 4px;
}

.minimode.audio.svg .p_cta .p_ctaIcon {
    top: 9px;
    left: 7px;
    height: 45px;
    width: 45px;
}

.minimode.audio.svg .p_cta.p_hasDuration .p_ctaIcon {
    top: 1px;
}

.audio .p_cta.p_iplayerIcon {
    background-image: url(//emp.stage.bbci.co.uk/emp/assets/2.0.23/cta_play_audio_iplayer.png);
}

.audio.svg .p_cta.p_iplayerIcon {
    background-image: none;
}

.minimode.audio.svg .p_cta.p_iplayerIcon .p_ctaIcon {
    top: 6px;
    left: 6px;
    height: 49px;
    width: 49px;
}

.minimode.audio.svg .p_cta.p_hasDuration.p_iplayerIcon .p_ctaIcon {
    top: 0;
}

@-webkit-keyframes spinner {
    from {
        -webkit-transform: rotate(0deg);
    }

    to {
        -webkit-transform: rotate(360deg);
    }
}

@-moz-keyframes spinner {
    from {
        -moz-transform: rotate(0deg);
    }

    to {
        -moz-transform: rotate(360deg);
    }
}

@keyframes spinner {
    from {
        transform: rotate(0deg);
    }

    to {
        transform: rotate(360deg);
    }
}

.p_spinner {
  position: absolute;
  position: fixed;
  pointer-events : none;
  z-index: 10;
    display: none;
}
.p_spinner canvas {
    -webkit-animation-name: spinner;
    -webkit-animation-duration: 1.1s;
    -webkit-animation-iteration-count: infinite;
    -webkit-animation-timing-function: linear;
    -moz-animation-name: spinner;
    -moz-animation-duration: 1.1s;
    -moz-animation-iteration-count: infinite;
    -moz-animation-timing-function: linear;
    animation-name: spinner;
    animation-duration: 1.1s;
    animation-iteration-count: infinite;
    animation-timing-function: linear;
}

.minimode .p_spinner {
    display: none !important;
}

#p_pluginContainer {
  z-index:50;
  overflow:hidden;
}

.p_playerControls {
    left: 0;
    right: 0;
    bottom: 0;
    z-index: 160;
    position: absolute;
}

.p_gradientLayer {
    pointer-events: none;
    opacity: 0;
    left: 0;
    right: 0;
    bottom: 0;
    z-index: 8;
    position: absolute;
    width: 100%;
    height: 148px;
    background: -moz-linear-gradient(top,  rgba(0,0,0,0) 0%, rgba(0,0,0,0.5) 40%, rgba(0,0,0,1) 100%); /* FF3.6-15 */
    background: -webkit-linear-gradient(top,  rgba(0,0,0,0) 0%,rgba(0,0,0,0.5) 40%,rgba(0,0,0,1) 100%); /* Chrome10-25,Safari5.1-6 */
    background: linear-gradient(to bottom,  rgba(0,0,0,0) 0%,rgba(0,0,0,0.5) 40%,rgba(0,0,0,1) 100%); /* W3C, IE10+, FF16+, Chrome26+, Opera12+, Safari7+ */    
}

.p_gradientBottomfiller {
  pointer-events: none;
  position: absolute; 
  z-index: 49; 
  width: 100%; 
  background-color: #000000;
  bottom: 0;
}

.cta .p_gradientLayer,
.cta .p_gradientBottomfiller {
  visibility: hidden;
}

.p_hasMarkers:not(.p_chapterOnly):not(.p_keyMomentOnly) .p_gradientLayer {
    height: 176px;
}

.noSeekingBar .p_gradientLayer {
    height: 64px;
}

.minimode .p_gradientLayer {
    background: black;
    height: 88px;
}

.minimode.transparent .p_gradientBottomfiller { 
    background:transparent;
}

.minimode.transparent .p_gradientLayer { 
    background:transparent;
}

.minimode.noSeekingBar .p_gradientLayer {
    height: 44px;
}

.minimode:not(.p_keyMomentOnly).p_hasMarkers .p_gradientLayer {
    height: 132px;
}

.minimode .p_keyMoment {
    bottom: 50px;
}

.minimode.p_keyMomentOnly .p_keyMoment {
    bottom: 6px;
}


@media (max-width:1310px) {
    .fullscreen .p_playerControls {
        left:  3.5625%;
        right:  3.5625%;
        margin: 0;
        width: auto;
    }
}

@media (min-width:1310px) {
    .fullscreen .p_playerControls {
        left: 50%;
        margin: 0 0 0 -640px;
        width: 1280px;
    }
}



.fadedOut { opacity:0; }
.fadedIn { opacity:1; }
.fadedIn, .fadedOut {
    -webkit-transition: opacity 0.6s ease-out;
    -moz-transition: opacity 0.6s ease-out;
    -o-transition: opacity 0.6s ease-out;
    transition: opacity 0.6s ease-out;
}

.controlsFadedOut .p_playerControls, .controlsFadedOut .p_gradientLayer, .controlsFadedOut .p_gradientBottomfiller, .controlsFadedOut .p_timeDisplay { opacity:0; }
.controlsFadedIn .p_playerControls, .controlsFadedIn .p_gradientLayer, .controlsFadedIn .p_gradientBottomfiller, .controlsFadedIn .p_timeDisplay { opacity:1; }
.controlsFadedIn .p_playerControls, .controlsFadedIn .p_gradientLayer, .controlsFadedIn .p_gradientBottomfiller, .controlsFadedIn .p_timeDisplay,
.controlsFadedOut .p_playerControls, .controlsFadedOut .p_gradientLayer, .controlsFadedOut .p_gradientBottomfiller, .controlsFadedOut .p_timeDisplay,
#p_compassContainer {
    -webkit-transition: opacity 0.6s ease-out;
    -moz-transition: opacity 0.6s ease-out;
    -o-transition: opacity 0.6s ease-out;
    transition: opacity 0.6s ease-out;
}

.p_timeTipTriangle.p_keyMomentTipTriangle {
  border-top: 5px solid #191919;
  left: 2px;
}

.p_timeDisplay {
    cursor: default;
    float: right;
    right: 0;
    margin-right: 12px;
    text-align: center;
    white-space: nowrap;
}

.p_time {
    font-size: 0.75em;
    text-align: right;
    display: inline-block;
    line-height: 44px;
    color: #fff;
}

.p_timeSeparator {
    font-size: 0.75em;
    padding-right: 7px;
    padding-left: 4px;
    width: 2px;
    line-height: 44px;
    color: #b3b3b3;
    display: inline-block;
}

.p_duration {
    color:#b3b3b3;
    text-align: left;
}



.transparent .p_timeSeparator, .transparent .p_duration { 
    color:white;
}

.p_playerControlBarHolder {
    position: relative;
    height: 44px;
    line-height: 0;
}

/*SMPHTML-791*/
.stopTouch .p_playerControls { 
    pointer-events:none;
}

.p_controlBarButton {
    position: absolute;
    width: 44px;
    height: 44px;
    font-weight:bold;
    display: block;
    text-decoration: none;
    text-align: center;
    background-repeat : no-repeat;
    background-color : transparent;
    background-position : center center;
    outline: 0;
    cursor: pointer;
    z-index: 170;
    -webkit-transition: opacity 0.4s ease-out;
    -moz-transition: opacity 0.4s ease-out;
    -o-transition: opacity 0.4s ease-out;
    transition: opacity 0.4s ease-out;
}

.p_controlBarButton:not(.p_buttonTouch) {
    -webkit-transition: background-color 0.4s ease-out, opacity 0.4s ease-out;
    -moz-transition: background-color 0.4s ease-out, opacity 0.4s ease-out;
    -o-transition: background-color 0.4s ease-out, opacity 0.4s ease-out;
    transition: background-color 0.4s ease-out, opacity 0.4s ease-out;
}

.p_selected_indicator {
    position: absolute;
    height: 4px;
    width: 40px;
}

.p_timeDisplay.p_covered { 
  opacity:0;
}

.p_controlBarButton_on:hover .p_selected_indicator, .p_settingsPanelOpen .p_selected_indicator, .nonPointerFocus .p_controlBarButton_on:focus .p_selected_indicator  {
	opacity: 0.4;
}

.p_controlSeekBarThumb {
    position: absolute;
    width: 38px;
    height: 38px;
    z-index: 170;
}

.p_playButton {
    left: 0;
    background-image: url(//emp.stage.bbci.co.uk/emp/assets/2.0.23/play.png);
}

.svg .p_playButton {
    background-image: none;
}

.svg .p_playButton .p_playIcon {
    position: absolute;
    left: 5px;
    top: 7px;
    width: 31px;
    height: 31px;
}

.p_pauseButton {
    left: 0;
    background-image: url(//emp.stage.bbci.co.uk/emp/assets/2.0.23/pause.png);
}

.svg .p_pauseButton {
    background-image: none;
}

.svg .p_pauseButton .p_pauseIcon {
    position: absolute;
    left: 7px;
    top: 8px;
    width: 28px;
    height: 28px;
}

.p_fullscreenButton {
    background-image: url(//emp.stage.bbci.co.uk/emp/assets/2.0.23/fullscreen.png);
}

.p_fullscreenButtonReturn {
    right:0;
    background-size: 22px 22px;
    background-position: center;
    background-repeat: no-repeat;
    background-image: url(//emp.stage.bbci.co.uk/emp/assets/2.0.23/fullscreen-exit.png);
}





.p_castOverlay {
    position: absolute;
    background-color: rgba(51, 51, 51, 0.8);
    height: 100%;
    padding:0;
    top: 0;
    left:0;
    right:0;
    margin: 0;
    overflow: hidden;
    z-index: 9;
}

.p_castOverlay .p_castIcon {
    height: 100px;
    width: 100px;
    position: absolute;
    top:0;
    bottom: 0;
    left: 0;
    right: 0;
    margin: auto;
}

.fullscreen .p_messageDiv {
    top: 35%;
}


.CCisCasting .p_castOverlay.shiftCentralControls .p_castIcon {
    margin: 5px;
}

.p_messageDiv {
    top: 22%;
    position: absolute;
    width: 100%;
    text-align: center;
}

.p_castMessage {
    color: #fff;
    font-size: 1.25em;
    font-weight: bold;
}

.CCisCasting .p_castOverlay.shiftCentralControls .p_castMessage,
.CCisCasting .p_castOverlay.shiftCentralControls .p_deviceMessage {
    display: inline;
}

.CCisCasting .p_castOverlay.shiftCentralControls .p_deviceMessage:before {
  content: " - ";
}

.p_deviceMessage {
    padding: 8px 0 4px 0;
    color: #a4a4a4;
    font-size: 1em;
}


@media (min-width:600px) {
  .CCisCasting .p_castOverlay.shiftCentralControls .p_messageDiv {
      top: 40px;
      left: 105px;
      display: inline;
      text-align: left;
  }
}

.CCisCasting .p_castOverlay.shiftCentralControls  .p_messageDiv div {
    display: inline-block;
}


.rippleEffect:active {
  border-radius: 50%;
  background-color: rgba(164,164,164, 0.5);
  -webkit-transition: background 0.2s;
  transition: background 0.2s;
}


@media (max-width:600px) {
/*for small screen the style will be similar to the shiftCentralControls one*/

  .p_castOverlay .p_castIcon {
    left: 10px;
    top: 7px;
    right: calc(100% - 100px);
    bottom: calc(100% - 50px);
    height: 44px;
    width: 44px;
    margin: 0;
  }

  .CCisCasting .p_castIcon {
    margin: 5px;
  }

  .CCisAttemptingToCast .p_castOverlay .p_castIcon,
  .CCisConnecting .p_castOverlay .p_castIcon {
    left: 30px;
    top: 13px;
  }

  .p_castMessage,
  .p_deviceMessage {
    display: inline;
  }

  .p_messageDiv,
  .fullscreen .p_messageDiv {
    top: 25px;
    left: 65px;
    display: inline;
    text-align: left;
    font-size: 12px;
  }

  .CCisAttemptingToCast .p_messageDiv,
  .CCisConnecting .p_messageDiv {
    left: 80px;
  }

  .p_deviceMessage:before {
    content: " - ";
  }

  .p_messageDiv div {
    display: inline-block;
  }

}



.svg .p_fullscreenButton,
.svg .p_fullscreenButtonReturn {
    background-image: none;
}

.nofullscreen .p_fullscreenButton,
.nofullscreen .p_fullscreenButtonReturn {
  display: none;
}

.p_subtitleButton {
    background-image: url(//emp.stage.bbci.co.uk/emp/assets/2.0.23/accessibility.png);
}

.svg .p_subtitleButton {
    background-image: none;
}

.svg .p_subtitleButton .p_subtitlesIcon {
    position: absolute;
    left: 6px;
    top: 6px;
    width: 32px;
    height: 32px;
}



.chromecast .p_chromecastButton {
    background-image: url(//emp.stage.bbci.co.uk/emp/assets/2.0.23/chromecast.png);
}



.svg .p_chromecastButton,
.svg .p_picInPicButton {
    background-image: none;
}











.svg .p_picInPicButton {
    padding-left: 11px;
    padding-top: 13px;
}

.p_embedButton {
    background-image: url(//emp.stage.bbci.co.uk/emp/assets/2.0.23/embed.png);
}

.svg .p_embedButton {
    background-image: none;
}

.svg .p_embedButton .p_embedIcon {
    position: absolute;
    width: 39px;
    height: 39px;
    left: 2px;
    top: 3px;
}

.p_padlock {
  position: absolute;
  right: 0px;
  background-image: url(//emp.stage.bbci.co.uk/emp/assets/2.0.23/padlock_locked.png);
  background-position: center center;
  background-repeat: no-repeat;
  background-color: #d13c2c;
  cursor: pointer;
  height: 30px;
  width: 30px;
  top: 50%;
  margin-top: -15px;
}

.rtlCta .p_padlock {
  left: 0
}

.svg .p_padlock,
.svg .p_padlock_unlocked {
    background-image: none;
}

.svg .p_padlock .p_padlock-lockedIcon {
    position: absolute;
    top: 9px;
    left: 6px;
}

.p_padlock_unlocked {
    background-image: url(//emp.stage.bbci.co.uk/emp/assets/2.0.23/padlock_unlocked.png);
}

.svg .p_padlock .p_padlock-unlockedIcon {
    position: absolute;
    top: 9px;
    left: 6px;
}

.p_guidance {
  position: absolute;
  height: 80px;
  max-width: 70%;
  padding-right: 40px;
  display: table;
  margin-top: -40px;
}

.rtlCta .p_guidance {
  padding-right: 25px;
}

.p_guidanceHolder {
    position: relative;
}

.rtlCta .p_guidanceHolder {
  text-align: right;
}

.svg .p_guidance .p_iconHolder {
    position: absolute;
    top: -9px;
    left: -6px;
}

.rtlCta .p_guidance .p_guidanceContainer .p_iconHolder {
  left: 100%;
}

/** When we fail to load the SVG file, we remove the .svg class from the body
  * We need to display:none the icon so that it doesn't push the guidance div
  * too high
 **/
.svg .p_guidanceIcon.p_svg {
    display: block;
}

.p_guidanceIcon.p_svg {
    display: none;
}

.svg .p_guidanceIcon {
    fill: #f00;
    width: 30px;
    height: 30px;
}

.minimode .p_guidance {
  height: 60px;
}

.p_guidance.p_ctaGuidance {
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.7);
}

:not(.rtlCta).cta .p_guidance.p_ctaGuidance {
  left: 80px;
}

.minimode .p_guidance.p_ctaGuidance {
  left: 60px;
}

.rtlCta .p_guidance.p_ctaGuidance {
  right:0;
  margin-right: 80px;
}

.p_guidance.p_continuous {
	height: 30px;
	margin: 8px;
	top: 0px;
	width: 70%;
	background-color: rgba(209,60,44,0.7);
}

/*.svg .p_gel-exitLinkIcon {
  -webkit-transition: fill 0.2s ease;
  transition: fill 0.2s ease;
}

.svg .p_gel-exitLinkIcon:hover {
  fill:#F54997;
}

#pgExit:focus {
    outline:none;
}

#pgExit:focus .p_gel-exitLinkIcon {
  fill:#F54997;
} */

.svg .p_guidance-alertIcon {
  fill:#F5B100;
  top: 0;
  left: 3px;
  position: absolute;
}



.svg .p_fullscreen-returnIcon {
    width: 22px;
    height: 22px;
    position: relative;
    top: 50%;
    transform: translateY(-50%);
    -webkit-transform: translateY(-50%);
    -ms-transform: translateY(-50%);
}

@media (max-width:480px) {
  .p_guidance {
    max-width: 180px;
    min-width: 180px;
  }
  .p_guidance.p_continuous {
    max-width: 360px;
    min-width: 240px;
  }
}

.p_guidanceContainer {
	color: #fff;
	font-size: 0.75em;
	font-weight: bold;
	padding-left: 10px;
	display: table-cell;
	vertical-align: middle;
	line-height: 15px;
	padding: 8px;
}

.p_guidanceFallback {
    display: inline-block;
    margin: auto;
    border-radius: 50%;
    height: 15px;
    width: 15px;
    background-color: #f00;
    position: absolute;
}

.svg .p_guidanceFallback {
    display: none;
}

.p_guidanceFallbackText {
  position: relative;
  left: 3px;
}

.guidanceClose {
	position: absolute;
	top: 50%;
	right: 1px;
	background-image: url(//emp.stage.bbci.co.uk/emp/assets/2.0.23/cross.png);
	background-position: center center;
	background-repeat: no-repeat;
	background-color: rgba(209,60,44,1);
	width: 30px;
	height: 30px;
	margin-top: -15px;
	cursor: pointer;
}

.svg .guidanceClose {
    background-image: none;
}

.svg .guidanceClose .p_crossIcon {
    position: absolute;
    left: 7px;
    top: 10px;
    width: 28px;
    height: 28px;
}

.p_guidanceText {
    position: relative;
    margin-left: 20px;
}

.rtlCta .rtlPadlock .p_guidanceText  {
  margin-left: 50px;
}

.p_subtitleButton {
    display: none;
}

.subtitles .p_subtitleButton {
    display: block;
}

.p_chromecastButton,
.p_picInPicButton {
    display: none;
}

.chromecast .p_chromecastButton,
.picInPic .p_picInPicButton {
    display: block;
}

.p_embedButton {
    display: none;
}

.embed .p_embedButton {
    display: block;
}

.p_playButton.p_iplayerPlay {
    background-image: url(//emp.stage.bbci.co.uk/emp/assets/2.0.23/play-iplayer.png);
}

.svg .p_playButton.p_iplayerPlay {
    background-image: none;
}



.p_controlBarFiller {
    position: absolute;
    width: 90px;
    height: 44px;
    text-align: center;
    left: 90px;
}


.p_noVolume .p_controlBarFiller {
    left: 45px;
}

.p_hiddenElement {
  left: -999em;
  top: 0;
  position: absolute;
}

.p_button > .p_selected_background {
    display: none;
    position: absolute;
    height: 4px;
    left: 2px;
    width: 40px;
    top: 38px;
    background-color: #000;
}

.p_button.p_controlBarButton_on > .p_selected_background {
  display: block;
}

.p_chapterMarkersHolder {
    z-index: 160;
    position: absolute;
    display: none;
    left: 0;
    bottom: 88px;
    width: 100%;
    height: 73px;
    line-height: 0;
}

.p_hasMarkers .p_chapterMarkersHolder {
  display:block;
}


.p_playerControls.p_keyMomentOnly .p_chapterMarkersHolder {
    height: 26px;
}

.fullscreen .p_playerControls.p_chapterOnly .p_chapterMarkersHolder {
    top: -88px;
}

.fullscreen .p_playerControls.p_keyMomentOnly .p_chapterMarkersHolder {
    top: -70px;
}

.p_playerControls.p_noControlBar .p_chapterMarkersHolder {
    bottom: 44px;
}

.p_chapterMarker {
    position: absolute;
    bottom: 0;
    height: 34px;
    overflow: hidden;
    z-index: 170;
    left: 16px;
    background: #000;
    text-overflow: ellipsis;
    padding-right : 0px;
    padding-left : 0px;
    line-height:16px;
    font-size: 0.75em;
    text-align: left;
    color: #fff;
    cursor: pointer;
}

.p_chapterMarker:focus {
    outline: none;
}

.p_chapterTip {
  display: none;
  position: absolute;
  bottom: 44px;
  z-index: 170;
  background-color: rgb(255,255,255);
  color: #191919;
  width: auto;
  margin-left: 0;
  border-left-width: 0;
  margin-right: 0;
  border-right-width: 0;
  max-width: 144px;

  padding-right: 8px;
  padding-left: 8px;
  padding-top: 12px;
  padding-bottom: 12px;
  line-height: 16px;
  font-size: 0.75em;
  font-weight: bold;

  cursor: pointer;
}

.p_chapterMarkerText {
  line-height: 34px;
  padding-left: 5px;
}





.p_keyMoment {
    position: absolute;
    bottom: 48px;
    height: 17px;
    width: 15px;
    z-index: 165;
    background: #191919;
    cursor: pointer;
}

.p_keyMoment.p_highlighted { 
  background-color:white;
}

.p_keyMoment.p_highlighted .p_keyMomentSquare { 
  background-color:#191919;
}

.p_keyMoment:focus {
    outline: none;
}

.p_keyMomentOnly .p_keyMoment {
    bottom: 0;
}

.p_keyMomentSquare{
    position: absolute;
    left: 5px;
    bottom: 6px;
    height: 5px;
    width: 5px;
    z-index: 170;
    background: #fff;
    cursor: pointer;
}


.p_volumeControlsFiller {
    position: absolute;
    left: 264px;
    height: 44px;
    z-index: 200; /* Does this need to be 200? Rest of controls are 160 */
}

.p_covered {
    opacity: 0;
}

.p_iconHolder {
    -webkit-transition: opacity 0.4s ease-out;
    -moz-transition: opacity 0.4s ease-out;
    -o-transition: opacity 0.4s ease-out;
    transition: opacity 0.4s ease-out;
}

.focusEnabled .p_padlock:focus, .p_padlock:hover,.focusEnabled .p_padlock_unlocked:focus, .p_padlock_unlocked:hover {
  background-color: #ff4739;
}

/*MP-3112*/
.p_paragraph,
.p_playerControlBarHolder {
  -webkit-text-size-adjust: none;
}

/* positioning of firefox high res icons */

@-moz-document url-prefix() {

    .p_audioIcon, .p_muteIcon, .p_fullscreen-enterIcon {
        position: absolute;
        top: 0;
        width: 44px;
        height: 44px;
    }

    .p_audioIcon {
        left: 1px;
    }

    .p_muteIcon {
       left: 1px;
    }

    .p_fullscreen-enterIcon {
        left: 0;
        top: 0;
    }

    .svg .p_cta .p_ctaIcon {
        left: 9px;
    }

    .svg .p_padlock .p_padlock-lockedIcon {
        width: 30px;
        height: 30px;
    }

    .svg .p_padlock .p_padlock-unlockedIcon {
        width: 30px;
        height: 30px;
    }

    .p_play-iplayerIcon {
        width: 44px;
        height: 44px;
        top: 2px;
    }

    .p_closed-captionsIcon {
        width: 44px;
        height: 44px;
        top: -1px;
    }

    .minimode.svg .p_cta .p_ctaIcon {
        left: 9px;
    }

    .svg .p_embedButton .p_embedIcon {
        left: 2px;
        top: 2px;
    }

}


/*----  FROM GUIDANCE TO WARNING  ----*/

.p_warning.p_guidance.p_continuous .p_guidanceIcon,
.p_ctaGuidance.p_guidance.p_warningCta .p_guidanceIcon {
    /* fill points to the circle fill="inherit" in SVG static, guidance icon*/
    fill: #FFFFFF;
    /* color points to the path fill="currentColor" in SVG static, guidance icon*/
    color: black;
}

.p_warning.p_guidance.p_continuous {
    background-color: rgba(51,51,51,0.85);
}

.p_warning.p_guidance.p_continuous .guidanceClose {
    background-color: #404040;
}

.p_warning .p_guidanceFallback,
.p_warningCta .p_guidanceFallback {
    background-color: #FFFFFF;
    color: black;
}

/*---- ---- ---- ----*/



/*raises the control bar in iOS Safari when toolbars displayed in fullscreen portrait*/
@media only screen
and (orientation:  portrait)
and (height: 628px)
and (-webkit-device-pixel-ratio: 2)
and (-webkit-min-device-pixel-ratio: 2),
only screen
and (orientation: portrait)
and (height: 696px),
only screen
and (orientation: portrait)
and (height: 528px)
{
    .fullscreen.iPhoneIos10 .p_playerControls,
    .fullscreen.iPhoneIos11orGreater .p_playerControls {
        padding-bottom: 65px;
    }
}


/*raises the control bar in iPhoneIos11orGreater Safari when toolbars displayed in fullscreen portrait*/
/* iPhoneIos11orGreater Portrait iPx fix */
@media only screen
and (orientation: portrait)
and (min-height: 640px)
and (-webkit-device-pixel-ratio: 3)
{
    .fullscreen.iPhoneIos11orGreater .p_playerControls {
        padding-bottom: 95px;
    }

}

/* iPhoneIos11orGreater Landscape fullscreen iPx fix */
@media only screen
and (orientation : landscape)
and (device-width : 375px)
and (device-height : 812px)
and (-webkit-device-pixel-ratio : 3)
{
    .fullscreen.iPhoneIos11orGreater .p_playerControls {
        /* padding-bottom: constant(safe-area-inset-bottom);*/
        bottom: 20px; /* lift slightly so it's not sat on top of "home" button */
        left: 90px;
        right: 90px;
    }

    .fullscreen.iPhoneIos11orGreater #p_pluginContainer{
        position: relative;

        /* NOTE:  The env() function shipped in iOS 11 with the name constant(). Beginning with Safari Technology Preview 41 and the iOS 11.2 beta, constant() has been removed and replaced with env(). You can use the CSS fallback mechanism to support both versions, if necessary, but should prefer env() going forward.*/
        top: constant(safe-area-inset-top) !important;
        top: env(safe-area-inset-top) !important;

        left: calc(constant(safe-area-inset-left) + 25px) !important;
        left: calc(env(safe-area-inset-left) + 25px) !important;

        /* lift slightly to avoid home button */
        height: calc(100% - constant(safe-area-inset-bottom) - constant(safe-area-inset-top)) !important ;
        height: calc(100% - env(safe-area-inset-bottom) - env(safe-area-inset-top)) !important ;

        /* bring in a bit */
        width: calc(100% - constant(safe-area-inset-right) - constant(safe-area-inset-left) - 50px) !important;
        width: calc(100% - env(safe-area-inset-right) - env(safe-area-inset-left) - 50px) !important;
    }

    .fullscreen.iPhoneIos11orGreater.threeSixty #p_pluginContainer {
        pointer-events: none;
    }
}

/* 360 CSS - Might move elsewhere... */

#p_threeSixtyCanvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;

    -ms-touch-action: none;
    touch-action: none;
}

.threeSixty .p_accessibleHitArea {
    display: none;
}

.threeSixty.cta .p_accessibleHitArea {
    display: block;
}

#p_compassContainer {
    width: 134px;
    height: 134px;
    position: absolute;
    top: 0;
    left: 0;
    background: transparent;
    border: 0;
    padding: 0;
    margin: 0;
    outline: none;
}

@media (max-width: 500px) {

    #p_compassContainer {
        display: none;
    }

}


/*
 * Subtitle Settings
 *
 */



#p_subtitleSettingsContainer {
    position: absolute;
    bottom: 44px;
    width: 224px;
    height: 96px;
    display: none;
    z-index: 200;
    color: #FFF;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
}

#p_subtitleSettingsContainer .p_subtitleSettingsMask {
    position: absolute;
    bottom: 0;
    left: -22.5px;
    width: 268px;
    height: 96px;
}

#p_subtitleSettingsContainer .p_subtitleSettingsBox {
    position: absolute;
    width: 224px;
    height: 89px;
    bottom: 7px;
    right: 0;
    background-color: #191919;
}

#p_subtitleSettingsContainer .p_subsToggleLabel {
    position: absolute;
    font-size: 14px;
    line-height: 44px;
    margin-left: 16px;
}

#p_subtitleSettingsContainer .p_subsToggle {
    position: absolute;
    right: 0;
}

#p_subtitleSettingsContainer .p_subsToggle .p_toggleText {
    display: none;
}

#p_subtitleSettingsContainer .p_sizingButtonsContainer {
    position: absolute;
    width: 100%;
    height: 44px;
    bottom: 0;
}

#p_subtitleSettingsContainer .p_subtitleSizeButton {
    display: block;
    float: left;
    width: 44px;
    height: 44px;
    background: none;
    margin-right: 1px;
    color: #FFF;
    outline: 0;
}

#p_subtitleSettingsContainer .p_subtitleSizeButton[disabled] {
    color: #a4a4a4;
}

#p_subtitleSettingsContainer .p_subtitleSizeButton div {
    width: 100%;
    height: 100%;
    box-sizing: border-box;
    text-align: center;
}

#p_subtitleSettingsContainer .p_subtitleSizeButton:last-child {
    margin-right: 0;
}

#p_subtitleSettingsContainer #p_subtitleSizeButton_useSmallestFontSize div {
    font-size: 9px;
    line-height: 9px;
    padding-top: 15px;
}

#p_subtitleSettingsContainer #p_subtitleSizeButton_useSmallFontSize div {
    font-size: 11px;
    line-height: 11px;
    padding-top: 13px;
}

#p_subtitleSettingsContainer #p_subtitleSizeButton_useMediumFontSize div {
    font-size: 14px;
    line-height: 14px;
    padding-top: 10px;
}

#p_subtitleSettingsContainer #p_subtitleSizeButton_useLargeFontSize div {
    font-size: 17px;
    line-height: 17px;
    padding-top: 8px;
}

#p_subtitleSettingsContainer #p_subtitleSizeButton_useLargestFontSize div {
    font-size: 20px;
    line-height: 20px;
    padding-top: 5px;
}

#p_subtitleSizeIndicator {
    position: absolute;
    bottom: 8px;
    left: 5px;
    width: 34px;
    height: 4px;
    background-color: #a4a4a4;
    -webkit-transition: left 200ms ease-out;
    transition: left 200ms ease-out;
}

.p_subsOn #p_subtitleSizeIndicator {
    background-color: #FFF;
}

#p_subtitleSettingsContainer .p_downArrow {
    position: absolute;
    bottom: 0;
    right: 15px;
    width: 0;
    height: 0;
    border-top: 7px solid #191919;
    border-left: 7px solid transparent;
    border-right: 7px solid transparent;
}


@media (max-height: 154px) { 
  #p_subtitleSettingsContainer {
    height:52px;
  }
  #p_subtitleSizeIndicator {
    display:none;
    visibility:hidden;
  }
  #p_subtitleSettingsContainer .p_sizingButtonsContainer {
    display:none;
  }
  #p_subtitleSettingsContainer .p_subtitleSettingsBox {
    height: 45px;
  }
}

/*
 * Toggle Button
 *
 */

.p_toggle {
    position: relative;
    display: block;
    width: 87px;
    height: 44px;
    outline: 0;
}

.p_toggleText {
    position: absolute;
    top: 17px;
    right: 58px;
    font-size: 10px;
    line-height: 10px;
}

.p_toggleSlot {
    position: absolute;
    box-sizing: border-box;
    top: 10px;
    right: 12px;
    width: 40px;
    height: 24px;
    padding: 0;
    border: 1px solid #A4A4A4;
    margin: 0;
    background-color: #A4A4A4;
    -webkit-border-radius: 12px;
    -moz-border-radius: 12px;
    border-radius: 12px;
    cursor: pointer;
}

.p_toggleOn .p_toggleSlot {
    background-color: #000;
    border-color: #fff;
}

.p_toggleSlider {
    position: absolute;
    top: 2px;
    left: 2px;
    display: block;
    width: 18px;
    height: 18px;
    -webkit-border-radius: 9px;
    -moz-border-radius: 9px;
    border-radius: 9px;
    background-color: #000;
    -webkit-transition: left 200ms linear;
    transition: left 200ms linear;
}

.p_toggleSlider .p_tick {
    position: absolute;
    top: 3px;
    left: 7px;
    height: 8px;
    width: 3px;
    border: solid #000;
    border-width: 0px 2px 2px 0px;
    -webkit-transform: rotate(45deg);
    -ms-transform: rotate(45deg);
    transform: rotate(45deg);
    opacity: 0;
}

.p_toggleOn .p_toggleSlider {
    left: 18px;
}

.p_toggleOn .p_toggleSlider .p_tick {
    opacity: 1;
}

@font-face {
    font-family: "ReithSans";
    src: url("https://gel.files.bbci.co.uk/r2.302/BBCReithSans_W_Rg.woff2") format("woff2"), url("https://gel.files.bbci.co.uk/r2.302/BBCReithSans_W_Rg.woff") format("woff");
    font-display: swap;
}

@font-face {
    font-family: "ReithSans";
    src: url("https://gel.files.bbci.co.uk/r2.302/BBCReithSans_W_Bd.woff2") format("woff2"), url("https://gel.files.bbci.co.uk/r2.302/BBCReithSans_W_Bd.woff") format("woff");
    font-weight: bold;
    font-display: swap;
}

@font-face {
    font-family: "ReithSerif";
    src: url("https://gel.files.bbci.co.uk/r2.302/BBCReithSerif_W_Rg.woff2") format("woff2"), url("https://gel.files.bbci.co.uk/r2.302/BBCReithSerif_W_Rg.woff") format("woff");
    font-display: swap;
}

.font-family-sans {
    font-family: Arial, Helvetica, freesans, sans-serif;
    line-height: normal;
}

.ReithSans-loaded .font-family-sans,
.ReithSans-loaded .font-family-sans button {
    font-family: ReithSans, Arial, Helvetica, freesans, sans-serif;
    line-height: 1.3;
}

.font-family-serif {
    font-family: "Times New Roman", serif;
}

.ReithSerif-loaded .font-family-serif {
    font-family: ReithSerif, "Times New Roman", serif;
}

.font-feature-salt {
    font-feature-settings: 'salt';
}

.p_parentalGuidancePopup {
    position: fixed;
    width: 390px;
    top: 50%;
    margin-top: -175px;
    margin-left: -195px;
    left: 50%;
    line-height: normal;
    vertical-align: middle;
    color: white;
    font-size: 22px;
    z-index: 2147483600;
    text-align: left;
}

.p_parentalGuidanceBackground {
    position: fixed;
    width: 5000px;
    height: 5000px;
    left: 5000px;
    top: -500px;
    z-index: 2147483600;
    background-color: #333333;
    filter: alpha(opacity=85);
    opacity: 0.85;
}

#guidanceContainer {
    padding-right: 26px;
    padding-left: 26px;
    text-align: center;
}

#pgHeaderTitle {
    height: 42px;
    position: relative;
    margin-top: 35px;
}
#pgHeader {
    font-size: 26px;
}
#guidanceBody {
    position: relative;
    width: 100%;
}
#guidanceFooter {
    width: 100%;
    height: 42px;
    bottom: 0px;
    display: table;
    text-align: center;
}
#pgExit {
    position: absolute;
    right: 12px;
    top: 12px;
    cursor: pointer;
    width: 18px;
    height: 18px;
}


/**** Playback Settings Button ****/

.p_playbackSettingsButton {
    background: url(//emp.stage.bbci.co.uk/emp/assets/2.0.23/playback_settings.png) no-repeat;
    display: none;
}

.playbackSettings .p_playbackSettingsButton {
    display: block;
}

.svg .p_playbackSettingsButton {
    background-image: none;
}

.p_dontCloseSettingsPanel svg {
    pointer-events: none;   /* Fix for Edge - Where svg <use> tag is not contained in the p_dontCloseSettingsPanel element */
}

/**** Playlist Settings Panel ****/

#p_playbackSettingsContainer {
    display: none;
    position: absolute;
    bottom: 44px;
    width: 256px;
    z-index: 200;
    color: #FFF;
    line-height: 1.2;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
}

#p_playbackSettingsMask {
    position: absolute;
    height: 88px;
    width: 44px;
    right: -22px;
    bottom: 24px;
}

#p_playbackSettingsBox {
    position: absolute;
    width: 100%;
    bottom: 7px;
    right: 0;
    box-sizing: border-box;
    padding: 12px 0 16px 12px;
    background-color: #191919;
}

#p_playbackSettingsHeading {
    font-size: 16px;
    margin-bottom: 12px;
    padding-top: 8px;
}

.p_settingsRow {
    position: relative;
    min-height: 44px;
}

.p_settingsTextBox {
    margin-right: 55px;
}

#p_qualityRow .p_settingsTextBox {
   padding: 0 0 0 2px;
}

.p_settingsTitle {
    font-size: 14px;
    margin-bottom: 4px;
}

.p_settingsSubtitle,
#p_qualitySubtitleUnavailable {
    font-size: 13px;
    color: #A4A4A4;
}

#p_autoplayRow {
    display: none;
}

#p_autoplayTitle {
    padding-top: 14px;
}

#p_autoplayToggle {
    position: absolute;
    top: 0;
    right:0;
    width: 55px;
}

#p_autoplayToggle .p_toggleText {
    display: none;
}

#p_autoplayToggle .p_toggleSlot {
    right: 11px;
}

#p_playbackSettingsContainer .p_downArrow {
    position: absolute;
    bottom: 0;
    right: 15px;
    width: 0;
    height: 0;
    border-top: 7px solid #191919;
    border-left: 7px solid transparent;
    border-right: 7px solid transparent;

}

/*we don't show if it does not fit*/
@media (max-height: 295px) {

  #p_qualityRow {
      display: none !important;
  }

  #p_playbackSettingsContainer.p_qualityPageOpen {
    display: none !important;
  }

}

/*no quality setting for hls streaming*/
.preferHls #p_qualityRow {
    display: none !important;
}

#p_qualityRow {
    display: none;
    margin-top: 15px;
    outline: none;
    cursor: pointer;
}

#p_qualityRow.p_qualitySettingUnavailable {
    pointer-events: none;
}

.p_qualitySettingUnavailable #p_qualitySubtitle {
    display: none;
}

#p_qualitySubtitleUnavailable {
    display: none;
}

.p_qualitySettingUnavailable #p_qualitySubtitleUnavailable {
    display: block;
}

#p_qualityRow .p_settingsTitle {
    display: inline-block;
}

.p_qualitySettingUnavailable .p_chevronBorder {
    border-color: transparent transparent transparent #A4A4A4 !important;
}

.p_qualityPanelRow {
    height: 48px;
    border-bottom: 1px solid grey;
    margin-right: 12px;
    line-height: 48px;
    outline: none;
    cursor: pointer;
}

#p_qualityListWrap {
    display: none
}

#p_qualityPanelHighRow.p_qualityPanelRow {
    height: 75px;
    border-bottom: 0;
}

.p_qualityPanelRowHeading {
    font-size: 14px;
    height: 48px;
    padding: 0 2px;
}

.p_qualityPanelRowSubtitle {
    font-size: 13px;
    color: #A4A4A4;
    line-height: 16px;
    margin-top: -12px;
    padding: 0 2px;
    width: 200px;
}

.p_qualityTick {
    position: relative;
    top: -32px;
    left: 216px;
    height: 12px;
    width: 6px;
    border: solid white;
    border-width: 0px 3px 3px 0px;
    -webkit-transform: rotate(40deg);
    -ms-transform: rotate(40deg);
    transform: rotate(40deg);
    opacity: 0;
    background-color: #191919;
}

.p_qualitySettingOn .p_qualityTick {
  opacity: 1;
}

#p_chevronPlaceholder {
    display: inline-block;
    float: right;
    position: absolute;
    left: 218px;
    top: 5px;
    background: transparent;
    border: 0;
    outline: none;
}

.p_chevronBorder {
    width: 0;
    height: 0;
    border-style: solid;
    border-width: 6px 0 6px 10px;
    border-color: transparent transparent transparent white;
    line-height: 0px;
}

.p_chevronInside {
    position: relative;
    top: -8px;
    left: -20px;
    width: 0;
    height: 0;
    border-style: solid;
    border-width:  8px 0 8px 16px;
    border-color: transparent transparent transparent #191919;
    line-height: 0px;
}
/* --- ---- --- --- --- --- */



/**** Left Button Positioning ****/


.p_fullscreenButton,
.nofullscreen .p_picInPicButton,
.nofullscreen .p_chromecastButton,
.nofullscreen .p_playbackSettingsButton,
.nofullscreen .p_subtitleButton,
.nofullscreen #p_subtitleSettingsContainer,
.nofullscreen #p_playbackSettingsContainer,
.nofullscreen .p_embedButton {
    right: 0;
}

#p_subtitleSettingsContainer,
#p_playbackSettingsContainer,
.p_picInPicButton,
.p_chromecastButton,
.p_playbackSettingsButton,
.p_subtitleButton,
.p_embedButton,
.nofullscreen.subtitles #p_playbackSettingsContainer,
.nofullscreen.subtitles .p_picInPicButton,
.nofullscreen.subtitles .p_chromecastButton,
.nofullscreen.subtitles .p_playbackSettingsButton,
.nofullscreen.subtitles .p_embedButton,
.nofullscreen.subtitles .p_embedButton,
.nofullscreen.playbackSettings .p_embedButton,
.nofullscreen.picInPic .p_embedButton,
.nofullscreen.chromecast .p_embedButton {
    right: 45px;
}

.subtitles #p_playbackSettingsContainer,
.subtitles .p_playbackSettingsButton,
.subtitles .p_picInPicButton,
.subtitles .p_chromecastButton,
.playbackSettings .p_picInPicButton,
.playbackSettings .p_chromecastButton,
.subtitles .p_embedButton,
.playbackSettings .p_embedButton,
.picInPic .p_chromecastButton,
.picInPic .p_embedButton,
.chromecast .p_embedButton,
.subtitles.picInPic .p_chromecastButton,
.nofullscreen.subtitles.playbackSettings .p_embedButton,
.nofullscreen.subtitles.picInPic .p_chromecastButton,
.nofullscreen.subtitles.picInPic .p_embedButton,
.nofullscreen.subtitles.chromecast .p_embedButton,
.nofullscreen.picInPic.playbackSettings .p_embedButton,
.nofullscreen.chromecast.playbackSettings .p_embedButton,
.nofullscreen.subtitles.playbackSettings .p_picInPicButton,
.nofullscreen.subtitles.playbackSettings .p_chromecastButton,
.nofullscreen.subtitles.playbackSettings .p_embedButton {
    right: 90px;
}

.subtitles.playbackSettings .p_picInPicButton,
.subtitles.playbackSettings .p_chromecastButton,
.subtitles.picInPic .p_chromecastButton,
.subtitles.playbackSettings .p_embedButton,
.subtitles.picInPic .p_embedButton,
.subtitles.chromecast .p_embedButton,
.picInPic.playbackSettings .p_chromecastButton,
.picInPic.playbackSettings .p_embedButton,
.chromecast.playbackSettings .p_embedButton,
.picInPic.chromecast .p_embedButton,
.nofullscreen.picInPic.subtitles.playbackSettings .p_chromecastButton,
.nofullscreen.picInPic.subtitles.playbackSettings .p_embedButton,
.nofullscreen.chromecast.subtitles.playbackSettings .p_embedButton {
    right: 135px;
}

.picInPic.subtitles.chromecast .p_embedButton,
.picInPic.subtitles.playbackSettings .p_chromecastButton,
.picInPic.subtitles.playbackSettings .p_embedButton,
.picInPic.chromecast.playbackSettings .p_embedButton,
.chromecast.subtitles.playbackSettings .p_embedButton {
    right: 180px;
}

.chromecast.picInPic.subtitles.playbackSettings .p_embedButton {
    right: 225px;
}


/**** End Left Button Positioning ****/
@media (max-width: 350px) {

    #p_playbackSettingsContainer,
    .subtitles #p_playbackSettingsContainer,
    .nofullscreen #p_playbackSettingsContainer,
    .nofullscreen.subtitles #p_playbackSettingsContainer {
        right: 5px;
    }

    #p_playbackSettingsContainer .p_downArrow,
    .nofullscreen.subtitles #p_playbackSettingsContainer .p_downArrow {
        right: 55px;  /* 45 (Button space) + 15 (Arrow centre) - 5 (Panel margin right) */
    }

    .subtitles #p_playbackSettingsContainer .p_downArrow {
        right: 100px;
    }

    .nofullscreen #p_playbackSettingsContainer .p_downArrow {
        right: 10px;
    }

    #p_subtitleSettingsContainer,
    .nofullscreen #p_subtitleSettingsContainer {
        right: 5px;
    }

    #p_subtitleSettingsContainer .p_downArrow {
        right: 55px;
    }

    .nofullscreen #p_subtitleSettingsContainer .p_downArrow {
        right: 5px;
    }

}
.p_audioui_playlistButton {
    width: 48px;
    height: 48px;
    fill: #FFFFFF;
}

.p_audioui_playlistButton .p_audioui_playlistChevron {
    -webkit-transform-origin: 24px 24px;
            transform-origin: 24px 24px;
    -webkit-transition: 100ms -webkit-transform ease-out;
            transition: 100ms -webkit-transform ease-out;
            transition: 100ms transform ease-out;
            transition: 100ms transform ease-out, 100ms -webkit-transform ease-out;
    -webkit-transform: scale(1);
            transform: scale(1);
}

.p_audioui_playlistButton:not([disabled]).pressed .p_audioui_playlistChevron {
    -webkit-transform: scale(0.8);
            transform: scale(0.8);
}
#p_audioui_popOutPlayerButton {
    height: 48px;
    fill: #FFFFFF;
    color: #FFFFFF;
}

#p_audioui_popOutPlayerButton svg {
    float: right;
    width: 20px;
    height: 20px;
    margin-right: 6px;
    margin-top: 15px;

    -webkit-transition: 100ms -webkit-transform ease-out;
            transition: 100ms -webkit-transform ease-out;
            transition: 100ms transform ease-out;
            transition: 100ms transform ease-out, 100ms -webkit-transform ease-out;
    -webkit-transform: scale(1);
            transform: scale(1);
}

#p_audioui_popOutPlayerButton .p_audioui_popOutPlayerButton_text {
    float: right;
    height: 48px;
    line-height: 48px;
    font-size: 13px;
    font-weight: bold;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
}

#p_audioui_popOutPlayerButton:not([disabled]).pressed svg {
    -webkit-transform: scale(0.8);
            transform: scale(0.8);
}
.p_playerSeekBarHolder {
    display: block;
    opacity: 1;
    height: 44px;
    width: 100%;
    line-height: 0;
    touch-action: none; /* SMPHTML-318 */
    transition: opacity 1000ms linear;
}

.classicUI .p_playerSeekBarHolder {
    z-index: 160;
    position: absolute;
    left: 0;
    top: -44px;
}

.classicUI .p_playerSeekBarHolder.hidden {
    display: none;
}

.audioUI .p_playerSeekBarHolder.hidden {
    pointer-events: none;
}

.audioUI .p_playerSeekBarHolder.hidden .p_progressBar {
    opacity: 0;
}

.audioUI .p_playerSeekBarHolder.hidden .p_seekThumb {
    opacity: 0;
}

.p_bar {
    position: absolute;
    top: 18px;
    height: 6px;
    left: 16px;
    cursor: pointer;
}

.audioUI .p_bar {
    height: 4px;
    top: 20px;
    transition: transform 1000ms linear;
}

.audioUI .p_playerSeekBarHolder.hidden .p_bar {
    transform: scale(1, 0.5);
    transform-origin: center;
}

.fullscreen .p_bar {
    left: 0;
}

.seekingBarNotFullyAvailable .p_bar {
    cursor: default;
}

.p_seekBar {
    right: 16px;
    background-color: #767676;
}

.audioUI .p_seekBar {
    background-color: rgba(255,255,255, 0.3);
}

.fullscreen .p_seekBar {
    right: 0;
}

.p_seekBarPositionLine {
    display: none;
    position: absolute;
    top: 0;
    width: 1px;
    height: 6px;
    background-color: #fff;
    z-index: 1;
    pointer-events: none;
}

.audioUI .p_seekBarPositionLine {
    height: 4px;
}

.p_progressBar  {
    right: 100%;
    transform-origin: left;
    -webkit-transform-origin: left;
    -moz-transform-origin: left;
}

.audioUI .p_progressBar {
    transition: opacity 1000ms linear;
}

.audioUI .p_progressBar.p_progressBarAvailable {
    background-color: #FFF;
    opacity: 0.5;
}

.p_progressBarAnimate {
    animation-name: progressBar;
    -webkit-animation-name: progressBar;
    -moz-animation-name: progressBar;
    animation-timing-function: linear;
    -webkit-animation-timing-function: linear;
    -moz-animation-timing-function: linear;
    animation-fill-mode: forwards;
    -webkit-animation-fill-mode: forwards;
    -moz-animation-fill-mode: forwards;
}

@-webkit-keyframes progressBar {
    to {
        -webkit-transform: scale(1, 1);
        -moz-transform: scale(1, 1);
        transform: scale(1, 1);
    }
}
@-moz-keyframes progressBar {
    to {
        -webkit-transform: scale(1, 1);
        -moz-transform: scale(1, 1);
        transform: scale(1, 1);
    }
}
@keyframes progressBar {
    to {
        -webkit-transform: scale(1, 1);
        -moz-transform: scale(1, 1);
        transform: scale(1, 1);
    }
}

.p_progressBarAvailable {
    opacity:0.4;
}

.p_bar.p_progressBar.p_progressBarAvailable {
    display: none;
}

.seekingBarNotFullyAvailable .p_bar.p_progressBar.p_progressBarAvailable,
.seekingBarNotFullyAvailable .p_progressBar {
    cursor: pointer;
    display: block;
}

.p_seekThumb {
    position: absolute;
    top: 14px;
    width: 9px;
    height: 14px;
    z-index: 170;
    background: #fff;
    cursor: pointer;
}

.audioUI .p_seekThumb {
    top: 16px;
    width: 12px;
    height: 12px;
    border-radius: 50%;
    transition: opacity 1000ms linear;
}

.p_seekThumbAnimate {
    -webkit-animation-name: seekThumb;
    -moz-animation-name: seekThumb;
    animation-name: seekThumb;
    -webkit-animation-timing-function: linear;
    -moz-animation-timing-function: linear;
    animation-timing-function: linear;
    -webkit-animation-fill-mode: forwards;
    -moz-animation-fill-mode: forwards;
    animation-fill-mode: forwards;
}

@-webkit-keyframes seekThumb {
    to {
        -webkit-transform: translate(0, 0);
        -moz-transform: translate(0, 0);
        transform: translate(0, 0);
    }
}
@-moz-keyframes seekThumb {
    to {
        -webkit-transform: translate(0, 0);
        -moz-transform: translate(0, 0);
        transform: translate(0, 0);
    }
}
@keyframes seekThumb {
    to {
        -webkit-transform: translate(0, 0);
        -moz-transform: translate(0, 0);
        transform: translate(0, 0);
    }
}

.p_seekThumb > .p_seekThumbLine {
    background-color: #191919;
}


.p_seekThumbLine {
    position: absolute;
    top: 4px;
    pointer-events:none;
    left: 4px;
    width: 1px;
    height: 6px;
    z-index: 170;
}

.audioUI .p_seekThumbLine {
    display: none;
}

.p_seekThumbHalo {
    position: absolute;
    top: -6px;
    left: -6px;
    width: 24px;
    height: 24px;
    border-radius: 50%;
    opacity: 0.4;
    -webkit-transform: scale(0, 0) translateZ(0);
        -ms-transform: scale(0, 0) translateZ(0);
            transform: scale(0, 0) translateZ(0); /* translateZ fixes Safari jitter - creates new layer for halo */
    -webkit-transition: -webkit-transform .2s linear;
            transition: -webkit-transform .2s linear;
            transition: transform .2s linear;
            transition: transform .2s linear, -webkit-transform .2s linear;
}

.p_seekThumbHalo.p_showing {
    -webkit-transform: scale(1, 1) translateZ(0);
        -ms-transform: scale(1, 1) translateZ(0);
            transform: scale(1, 1) translateZ(0); /* translateZ fixes Safari jitter - creates new layer for halo */
}

.classicUI .p_seekThumbHalo {
    display: none;
}

    /*** TIME TIP ***/

.p_timeTip {
    opacity: 0;
    position: absolute;
    bottom: 88px;
    font-size: 0.75em;
    background-color: #fff;
    font-weight: bold;
    color: #191919;
    z-index: 170;
    /*    height: 20px;*/
    padding-top: 1px;
    padding-bottom: 0px;
    padding-left: 8px;
    padding-right: 8px;
    margin-top: 0px;
    margin-bottom: 0px;
    pointer-events: none;
    text-align: center;

}

.p_noControlBar .p_timeTip { 
    bottom: 44px;
 }

.audioUI .p_timeTip {
    -webkit-transition: opacity .2s linear;
    transition: opacity .2s linear;
    bottom: 139px;
}

/*raises the control bar in iOS Safari when toolbars displayed in fullscreen portrait*/
@media only screen
and (orientation:  portrait)
and (height: 628px)
and (-webkit-device-pixel-ratio: 2)
and (-webkit-min-device-pixel-ratio: 2),
only screen
and (orientation: portrait)
and (height: 696px),
only screen
and (orientation: portrait)
and (height: 528px)
{
    .fullscreen.iPhoneIos10 .p_timeTip,
    .fullscreen.iPhoneIos11orGreater .p_timeTip {
        bottom: 153px;
    }
}

/*raises the control bar in iOS11 Safari when toolbars displayed in fullscreen portrait*/
/* iOS11 Portrait iPx fix */
@media only screen
and (orientation: portrait)
and (min-height: 640px)
and (-webkit-device-pixel-ratio: 3)
{
    .fullscreen.iPhoneIos11orGreater .p_timeTip {
        bottom: 183px;
    }
}

.p_timeTipText {
    line-height: 22px;
}

.p_timeTipTriangle {
    position: absolute;
    bottom: -6px;
    left: 15px;
    width: 0;
    height: 0;
    border-left: 6px solid transparent;
    border-right: 6px solid transparent;
    border-top: 6px solid #fff;
    font-size: 0;
    line-height: 0;
}

.p_thumbnail {
    visibility: hidden;
    border: 1px solid white;
    position: absolute;
    bottom:88px;
    z-index: 165;
    background: rgba(51, 51, 51, 0.8);
    opacity:0;
    transition: opacity 0s linear 0.4s;
}

.p_noControlBar .p_thumbnail { 
    bottom: 44px;
 }

@media (max-width: 399px) {

    .p_bar {
        left: 10px;
    }

    .p_seekBar {
        right: 10px;
    }

}
.p_volumeControls {
    position: absolute;
    display: block;
    opacity: 1;
    overflow: hidden;
    left: 45px;
    height: 44px;
    z-index: 200;
    -webkit-transition: width 0.25s ease-out, opacity 1000ms linear;
    -moz-transition: width 0.25s ease-out, opacity 1000ms linear;
    -o-transition: width 0.25s ease-out, opacity 1000ms linear;
    transition: width 0.25s ease-out, opacity 1000ms linear;
}

.classicUI .p_volumeControls.hidden,
.classicUI .p_volumeControls.removed {
    display: none
}

.audioUI .p_volumeControls.hidden,
.audioUI .p_volumeControls.removed {
    opacity: 0;
    pointer-events: none;
}

.audioUI .p_volumeControls {
    height: 48px;
}


.p_noVolume .p_volumeControls { 
    display:none;
}

.p_volumeControls.p_closed {
    width: 44px;
}

.audioUI .p_volumeControls.p_closed {
    width: 48px;
}

.p_volumeControls.p_open {
    width: 222px;
}

.p_volumeButton.audio {
    background-image: url(//emp.stage.bbci.co.uk/emp/assets/2.0.23/audio.png);
}

.p_volumeButton.mute {
    background-image: url(//emp.stage.bbci.co.uk/emp/assets/2.0.23/mute.png);
}

.svg .p_volumeButton {
    background-image: none;
}

.audioUI .p_volumeButton {
    width: 48px;
    height: 48px;
}

.p_sliderContainer {
    position: absolute;
    width: 176px;
    height: 44px;
    left: 44px;
    touch-action: none;
    cursor: pointer;
}

.audioUI .p_sliderContainer {
    height: 48px;
    left: 48px;
}

.p_sliderControls {
    position: absolute;
    width: 132px;
    height: 44px;
    touch-action: none;
}

.audioUI .p_sliderControls {
    height: 48px;
}

.p_volumeBarHolder {
    position: absolute;
    background-color: transparent;
    bottom: 0px;
    height: 44px;
    width: 9px;
}

.audioUI .p_volumeBarHolder {
    height: 48px;
}

.p_volumeBar {
    position: absolute;
    bottom: 8px;
    height: 28px;
    width: 3px;
}

.audioUI .p_volumeBar {
    bottom: 10px;
}

.p_volumeLevel {
    position: absolute;
    width: 22px;
    left: 111px;
    top: 24px;
    font-size: 0.75em;
    text-align: center;
    vertical-align: middle;
    color: #fff;
}

.audioUI .p_volumeLevel {
    top: 17px;
    left: 105px;
}

.p_afterVolume {
    background-color: #A4A4A4;
}

.audioUI .p_afterVolume {
    background-color: rgba(255,255,255, 0.5);
}

.p_selectedVolume {
    height: 32px;
    background-color: #fff;
}

.audioUI .p_volumeButton svg {
    transition: fill 0.25s ease-out;
}

@media (max-width: 799px) {
    .audioUI .p_volumeControls {
        display: none;
    }
}


.p_debugConsoleLog {
    position: absolute;
    background-color: rgba(240, 240, 230, 0.7);
    height: calc(100% - 88px);
    padding:0;
    top:0;
    left:0;
    right:0;
    margin: 0;
    overflow: hidden;
    z-index: 199;
}

.fullscreen .p_debugConsoleLog {
    height: 60%;
    min-height: 100px;
}

.p_consoleLogList {
    position: absolute;
    top: 0;
    left: 0;
    right:0;
    padding: 0 0;
    margin: 0;
    height: 100%;
    list-style: none;
    overflow: scroll;
}

.p_consoleLogItem {
    border-bottom: 1px solid black;
    word-wrap: break-word;
}
</style>
<script type="text/javascript">
(function() {
  if (true || !window.console) {

        if (!window.console) {
            window.console={};
        }
        var logs = ['error','warn','info','log','debug'];
        var original = {};
        for (var i=0;i<logs.length;i++) {
            var key=logs[i];
            original[key]=console[key];
            console[key] = function() {
                var args = arguments;
                if(args[0] && (typeof args[0] === 'string')) {
                    args[0] = '2.24.0: ' + args[0];
                }

                try {
                   if (top.smpDebugLogger) {
                      top.smpDebugLogger(args);
                   }
                } catch (e) {
                }

                try {
                   DebugConsole.updateConsoleLog(args);
                } catch (e) {
                }

                try {
                    original[key].apply(original, args);
                }catch(e) {
                }
            };
        }
    }
})();

var DEBUG_FULL = true;

/* Font Face Observer v2.0.13 -  Bram Stein. License: BSD-3-Clause */(function(){'use strict';var f,g=[];function l(a){g.push(a);1==g.length&&f()}function m(){for(;g.length;)g[0](),g.shift()}f=function(){setTimeout(m)};function n(a){this.a=p;this.b=void 0;this.f=[];var b=this;try{a(function(a){q(b,a)},function(a){r(b,a)})}catch(c){r(b,c)}}var p=2;function t(a){return new n(function(b,c){c(a)})}function u(a){return new n(function(b){b(a)})}function q(a,b){if(a.a==p){if(b==a)throw new TypeError;var c=!1;try{var d=b&&b.then;if(null!=b&&"object"==typeof b&&"function"==typeof d){d.call(b,function(b){c||q(a,b);c=!0},function(b){c||r(a,b);c=!0});return}}catch(e){c||r(a,e);return}a.a=0;a.b=b;v(a)}}
function r(a,b){if(a.a==p){if(b==a)throw new TypeError;a.a=1;a.b=b;v(a)}}function v(a){l(function(){if(a.a!=p)for(;a.f.length;){var b=a.f.shift(),c=b[0],d=b[1],e=b[2],b=b[3];try{0==a.a?"function"==typeof c?e(c.call(void 0,a.b)):e(a.b):1==a.a&&("function"==typeof d?e(d.call(void 0,a.b)):b(a.b))}catch(h){b(h)}}})}n.prototype.g=function(a){return this.c(void 0,a)};n.prototype.c=function(a,b){var c=this;return new n(function(d,e){c.f.push([a,b,d,e]);v(c)})};
function w(a){return new n(function(b,c){function d(c){return function(d){h[c]=d;e+=1;e==a.length&&b(h)}}var e=0,h=[];0==a.length&&b(h);for(var k=0;k<a.length;k+=1)u(a[k]).c(d(k),c)})}function x(a){return new n(function(b,c){for(var d=0;d<a.length;d+=1)u(a[d]).c(b,c)})};window.Promise||(window.Promise=n,window.Promise.resolve=u,window.Promise.reject=t,window.Promise.race=x,window.Promise.all=w,window.Promise.prototype.then=n.prototype.c,window.Promise.prototype["catch"]=n.prototype.g);}());

(function(){function l(a,b){document.addEventListener?a.addEventListener("scroll",b,!1):a.attachEvent("scroll",b)}function m(a){document.body?a():document.addEventListener?document.addEventListener("DOMContentLoaded",function c(){document.removeEventListener("DOMContentLoaded",c);a()}):document.attachEvent("onreadystatechange",function k(){if("interactive"==document.readyState||"complete"==document.readyState)document.detachEvent("onreadystatechange",k),a()})};function r(a){this.a=document.createElement("div");this.a.setAttribute("aria-hidden","true");this.a.appendChild(document.createTextNode(a));this.b=document.createElement("span");this.c=document.createElement("span");this.h=document.createElement("span");this.f=document.createElement("span");this.g=-1;this.b.style.cssText="max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;";this.c.style.cssText="max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;";
this.f.style.cssText="max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;";this.h.style.cssText="display:inline-block;width:200%;height:200%;font-size:16px;max-width:none;";this.b.appendChild(this.h);this.c.appendChild(this.f);this.a.appendChild(this.b);this.a.appendChild(this.c)}
function t(a,b){a.a.style.cssText="max-width:none;min-width:20px;min-height:20px;display:inline-block;overflow:hidden;position:absolute;width:auto;margin:0;padding:0;top:-999px;white-space:nowrap;font-synthesis:none;font:"+b+";"}function y(a){var b=a.a.offsetWidth,c=b+100;a.f.style.width=c+"px";a.c.scrollLeft=c;a.b.scrollLeft=a.b.scrollWidth+100;return a.g!==b?(a.g=b,!0):!1}function z(a,b){function c(){var a=k;y(a)&&a.a.parentNode&&b(a.g)}var k=a;l(a.b,c);l(a.c,c);y(a)};function A(a,b){var c=b||{};this.family=a;this.style=c.style||"normal";this.weight=c.weight||"normal";this.stretch=c.stretch||"normal"}var B=null,C=null,E=null,F=null;function G(){if(null===C)if(J()&&/Apple/.test(window.navigator.vendor)){var a=/AppleWebKit\/([0-9]+)(?:\.([0-9]+))(?:\.([0-9]+))/.exec(window.navigator.userAgent);C=!!a&&603>parseInt(a[1],10)}else C=!1;return C}function J(){null===F&&(F=!!document.fonts);return F}
function K(){if(null===E){var a=document.createElement("div");try{a.style.font="condensed 100px sans-serif"}catch(b){}E=""!==a.style.font}return E}function L(a,b){return[a.style,a.weight,K()?a.stretch:"","100px",b].join(" ")}
A.prototype.load=function(a,b){var c=this,k=a||"BESbswy",q=0,D=b||3E3,H=(new Date).getTime();return new Promise(function(a,b){if(J()&&!G()){var M=new Promise(function(a,b){function e(){(new Date).getTime()-H>=D?b():document.fonts.load(L(c,'"'+c.family+'"'),k).then(function(c){1<=c.length?a():setTimeout(e,25)},function(){b()})}e()}),N=new Promise(function(a,c){q=setTimeout(c,D)});Promise.race([N,M]).then(function(){clearTimeout(q);a(c)},function(){b(c)})}else m(function(){function u(){var b;if(b=-1!=
f&&-1!=g||-1!=f&&-1!=h||-1!=g&&-1!=h)(b=f!=g&&f!=h&&g!=h)||(null===B&&(b=/AppleWebKit\/([0-9]+)(?:\.([0-9]+))/.exec(window.navigator.userAgent),B=!!b&&(536>parseInt(b[1],10)||536===parseInt(b[1],10)&&11>=parseInt(b[2],10))),b=B&&(f==v&&g==v&&h==v||f==w&&g==w&&h==w||f==x&&g==x&&h==x)),b=!b;b&&(d.parentNode&&d.parentNode.removeChild(d),clearTimeout(q),a(c))}function I(){if((new Date).getTime()-H>=D)d.parentNode&&d.parentNode.removeChild(d),b(c);else{var a=document.hidden;if(!0===a||void 0===a)f=e.a.offsetWidth,
g=n.a.offsetWidth,h=p.a.offsetWidth,u();q=setTimeout(I,50)}}var e=new r(k),n=new r(k),p=new r(k),f=-1,g=-1,h=-1,v=-1,w=-1,x=-1,d=document.createElement("div");d.dir="ltr";t(e,L(c,"sans-serif"));t(n,L(c,"serif"));t(p,L(c,"monospace"));d.appendChild(e.a);d.appendChild(n.a);d.appendChild(p.a);document.body.appendChild(d);v=e.a.offsetWidth;w=n.a.offsetWidth;x=p.a.offsetWidth;I();z(e,function(a){f=a;u()});t(e,L(c,'"'+c.family+'",sans-serif'));z(n,function(a){g=a;u()});t(n,L(c,'"'+c.family+'",serif'));
z(p,function(a){h=a;u()});t(p,L(c,'"'+c.family+'",monospace'))})})};"object"===typeof module?module.exports=A:(window.FontFaceObserver=A,window.FontFaceObserver.prototype.load=A.prototype.load);}());

//----------------------------------------------------------------------------------------------------
// XD
//----------------------------------------------------------------------------------------------------


window.delayedFunctions=[];

var XD = (function() {
    /**
     * Allows sending/receiving data and events cross domain
     *
     * @constructor
     * @this {XD}
     * @param {string} validUrl Valid URL value
     */

    /**
     * Validate the URL and return the target
     *
     * @private
     * @return {string} The validated URL target or an empty string
     */
    function urlValidation(url) {
        if (url=="null") {
            return "*";
        }
        for (var i = 0; i < validDomains.length; i++) {
            var alternativeUrl = new RegExp('^(http[s]{0,1})://([^\\?\\&#:/]+\\.' + validDomains[i] + ')(:([0-9]+))?','gi');
            if (url.match(alternativeUrl)) {
                var targetUrl = url.split(alternativeUrl);
                return targetUrl[1] + '://' + targetUrl[2] + (targetUrl[4] ? ':' + targetUrl[4] : '');
            }
        }

        for (i = 0; i < validWholeDomains.length; i++) {
            if (url=="https://"+validWholeDomains[i]) {
                return "https://"+validWholeDomains[i];
            }
            if (url=="http://"+validWholeDomains[i]) {
                return "http://"+validWholeDomains[i];
            }
        }
        //Alternate validation for smp-offline: No domain, just file:// protocol
        if(/^file:\/\/$/i.test(url)) {
            return url;
        }

        return '';
    }

    var XD = function() {
        var xd = this;
        // send/receive from IFRAME to PAGE
        xd._receiveKey = '';
        xd._url = '';
        xd._listeners = {};

        // start the receiver for events
        xd.receive(function(event) {
               var type = event._data.type;
               var data = event._data.data;

                // if we have a registered listener for this receiveKey
                if(type && (typeof xd._listeners[type] === 'object')) {
                    var callbacks = xd._listeners[type];
                    for(var i = 0; i < callbacks.length; i++) {
                        // fire all listener callbacks for that event type on this receiveKey
                        var callback = callbacks[i];
                        if(typeof callback === 'function') {
                            callback.call(xd, data);
                        }
                    }
                }
            });
    };

    XD.prototype = {
        _receiveKey : '',
        _url : '',
        _listeners : {},

        /**
         * Post data
         *
         * @this {XD}
         * @param {object} data Data to be posted
         * @return {object} xd Instance of the XD object
         */
        post : function(data) {
            var xd = this;
            try {
                var postData = JSON.stringify(data);
            } catch (e) {
                if (DEBUG_FULL) { console.log("Stringify failed", data); }
                // make it a simple type, this should get initialised
                // out and maybe enough for some basic uses, should we
                // report this to rdot etc.?
                postData = { type: data.type };
            }

            if(typeof window.parent.postMessage == 'function') {
                window.parent.postMessage(postData, xd._url);
            }

            return xd;
        },

        /**
         * Receive data
         *
         * @this {XD}
         * @param {function} callback Callback function to be fired when data recieved
         * @return {object} xd Instance of the XD object
         */
        receive : function(callback) {
            var xd = this;
            var wrappedCallback = function(event) {
                if ((event.data+"").indexOf("ima://")===0) {
                    return;
                }
                if (event.data=="SMP.asyncDelay") {
                    if (window.delayedFunctions.length>0) {
                        var fnObj = window.delayedFunctions.shift();
                        if (fnObj){
                            fnObj.fn.apply(fnObj.that,fnObj.args);
                        } else {
                            if (DEBUG_FULL) {
                                console.log("ERROR!!!! no function found in asyncDelay");
                            }
                        }
                    }
                    return;
                }
                try {
                    event._data = JSON.parse(event.data);
                } catch (e) {
                    event._data={};
                    if (DEBUG_FULL) {
                        console.log("Error parsing event.data ",e);
                        console.log(event.data);
                    }
                }
                var d=event._data;
                // special case used to set the validated url (xd._url)
                // value inside the iframe
                if(d && !xd._url && (typeof d.initXD === 'object')) {
                    xd._url = urlValidation(event.origin);
                    // if url not validated - do not continue/allow callback
                    if(!xd._url.length) {
                        if (DEBUG_FULL) {console.log("Blocking URL:"+event.origin); }
                        return false;
                    }
                    // set the receiveKey so we can send events to the
                    // page from this point on
                    xd._receiveKey = d.initXD.receiveKey;
                    return true;
                }
                // if the source url doesn't match the security url -
                // do not pass go!
                if(event.origin !== xd._url && xd._url!="*") {
                    return false;
                }
                // if the receiveKey sent doesn't match the local
                // receiveKey - do not pass go!
                if((!d.receiveKey) || (d.receiveKey !== xd._receiveKey)) {
                    return false;
                }

                callback(event);
            };

            if(typeof window.addEventListener !== 'undefined') {
                window.addEventListener('message', wrappedCallback, false);
            } else {
                window.attachEvent('onmessage', wrappedCallback);
            }

            return xd;
        },


        /**
         * Add event listener(s)
         *
         * @this {XD}
         * @param {string} types String of types (separated by ' ')
         * @param {function} origCallback Callback function to be fired
         * @return {object} xd Instance of the XD object
         */
        on : function(type , callback) {
            var xd = this;
            if(typeof xd._listeners[type] === 'undefined') {
                xd._listeners[type] = [];
            }
            xd._listeners[type].push(callback);
            return xd;
        },

        /**
         * Fire event
         *
         * @this {XD}
         * @param {string} type Fired event type
         * @param {object} data Data passed to fired event
         * @return {object} xd Instance of the XD object
         */
        fire : function(type, data) {
            this.post({ receiveKey : this._receiveKey, data:data, type:type});
        },

        /**
         * Remove listener(s)
         *
         * @this {XD}
         * @param {string} types String of types (separated by ' ')
         * @return {object} xd Instance of the XD object
         */
        detach : function(type ) {
            // XXX review the need for this, is it worth it when
            // bootstrap won't be called anyway?
            var xd = this;
            if (typeof xd._listeners[type] !== 'undefined') {
                xd._listeners[type] = null;
                delete xd._listeners[type];
            }
            return xd;
        }
    };

    return XD;
})();

/** @scope _global_ */
/**
 * Error Object
 *
 * @class
 */


var CRITICAL = "critical";
var ERROR = "error";
var WARNING = "warning";
var UNKNOWN = "unknown";

var SMPError = (function() {

    var errors = {
        // XXX should the description and secondaryText here use the language class?
        // Do we even need this here as it's set up in init()?
        'unknown' : {
            description     : "An unknown error has occurred.",
            secondaryText   : "Please try again later.",
            detail          : "An unknown error occurred",
            severity        : ERROR,
            responsibility  : UNKNOWN,
            recoverable     : false
        }
    };

    var APPLICATION = "Application";
    var EXTERNAL = "External";
    var MEDIA = "Media";

    var SMPError = function(code,info) {
        var error;
        this.code = code;
        code = ('' + code);
        error = errors[code] || errors.unknown;

        var recoverable = !!error.recoverable;

        this.handled = true;
        this.type = ERROR;
        this.description = error.description || "";
        this.severity = error.severity;
        this.responsibility = error.responsibility;
        this.recoverable = recoverable;
        this.secondaryText = error.hasOwnProperty("secondaryText") ? error.secondaryText : (recoverable ? "" : Language.tryAgainLater);
        this.detail = error.detail || error.description;
        this.msg = "";
        this.info = info;

        return this;
    };

    

    SMPError.NON_BBC_PLAYLIST = 1001;
    SMPError.ERROR_LOADING_PLAYLIST = 1002;
    SMPError.NO_ITEMS_IN_PLAYLIST = 1003;
    SMPError.PROGRAMME_NOT_AVAILABLE_YET = 1004;
    SMPError.CONTENT_NOT_AVAILABLE_EXPIRED = 1005;
    SMPError.CONTENT_NOT_AVAILABLE_REGION = 1006;
    SMPError.MEDIATION_ERROR = 1026;
    SMPError.CANNOT_MAINTAIN_LOCK = 1039;
    SMPError.CONTENT_NOT_AV = 1051;
    SMPError.CONTENT_NOT_AVAILABLE = 1052;
    SMPError.CONTENT_NOT_AVAILABLE_GEO = 1056;
    SMPError.CONTENT_NOT_AVAILABLE_OTHER = 1057;
    SMPError.CONTENT_NOT_AVAILABLE_UNKNOWN = 1058;
    SMPError.CONTENT_NOT_AVAILABLE_REVOKED = 1059;
    SMPError.ERROR_PARSING_PLAYLIST = 1060;
    SMPError.CONTENT_NOT_AVAILABLE_PRE_START= 1061;
    SMPError.ALL_CONNECTIONS_FILTERED = 1062;
    SMPError.ALL_ITEMS_FILTERED = 1064;
    SMPError.NO_ITEMS = 1065;
    SMPError.NO_ITEMS_FILTERED = 1066;
    SMPError.MEDIASELECTOR_TIMEOUT = 1068;
    SMPError.MEDIATION_ERROR_UNKNOWN = 1069;
    SMPError.ERROR_PARSING_CONFIG = 1071;
    SMPError.PREFERRED_PROTOCOL_NOT_AVAILABLE = 1072;
    SMPError.UNHANDLED_INTERNAL_ERROR = 2100;
    SMPError.PLAYING_FAILED_NO_INTENT = 2200; 
    SMPError.PLAYING_STARTED_AFTER_NO_INTENT = 2201;
    SMPError.NETWORK_UNAVAILABLE = 3025;
    SMPError.MPD_LOAD_FAIL = 4200;
    SMPError.MPD_NO_STREAMS = 4201;
    SMPError.INIT_FRAGMENT_LOAD_FAIL = 4202;
    SMPError.STREAM_FRAGMENT_LOAD_FAIL = 4203;
    SMPError.PLAYING_DASH_WHEN_NOT_SUPPORTED = 4204;
    SMPError.DASH_MEDIASOURCE_ERROR=4205;
    SMPError.INIT_FRAGMENT_DOWNLOAD_INFORMATION = 4223;
    SMPError.MPD_GENERIC = 4224;
    SMPError.FRAGMENT_DOWNLOAD_INFORMATION = 4225;
    SMPError.FRAGMENT_END_DOWNLOAD_INFORMATION = 4229;
    SMPError.MPD_PARSE_ERROR = 4226;
    SMPError.NO_SUPPORTED_CODECS = 4227;
    SMPError.NO_SUPPORTED_CODECS_FAILOVER = 4228;
    SMPError.DASH_EXCEPTION = 4233;
    SMPError.DASH_FRAGMENT_DISCARDED = 4234;
    SMPError.DOWNLOAD_WAS_SLOW =  4237;
    SMPError.DOWNLOADS_OFTEN_SLOW = 4238;
    SMPError.LOAD_FAILED_BUFFERING = 4240;
    SMPError.STREAM_FRAGMENT_CONTENT_LENGTH_MISMATCH = 4241;
    SMPError.NO_ALTERNATIVE_MEDIA_AFTER_FAILOVER = 4999;
    SMPError.NO_ALTERNATIVE_MEDIA = 5000;
    SMPError.FORMAT_NOT_SUITABLE = 5001;
    SMPError.FORMAT_NOT_DECODED = 5003;
    SMPError.MEDIA_ERR_ABORTED = 5005;
    SMPError.MEDIA_ERR_NETWORK = 5007;
    SMPError.MEDIA_ERR_WEIRD = 5009;
    SMPError.DRM_KEY = 5100;
    SMPError.DRM_ERROR_TIMEOUT = 5101;
    SMPError.DEVICE_NOT_SUPPORTED = 6003;
    SMPError.INIT_TIMEOUT = 6004;
    SMPError.DASH_INIT_TIMEOUT = 6006;
    SMPError.ERROR_NO_MEDIA_SRC = 6011;
    SMPError.PLUGIN_LOAD_FAIL = 6100;
    SMPError.PLUGIN_INITIALISE_FAIL = 6101;
    SMPError.PLUGIN_LOAD_TIMEOUT = 6102;
    SMPError.THREE_SIXTY_FAILED = 6250;
    SMPError.EMBED_NOT_ALLOWED = 6500;
    SMPError.SUBS_FAILED = 7500;
    SMPError.THUMBNAIL_FAILOVER = 7501;
    SMPError.FONT_FAILED = 7502;
    SMPError.LANGUAGE_FAILED = 7750;

    SMPError.FLASH_NOT_CREATED = 8000;
    SMPError.FLASH_NOT_INITIALISED = 8001;
    SMPError.FLASH_NOT_INSTALLED = 8005;
    SMPError.FLASH_CRITICAL_ERROR = 8010;
    SMPError.CANT_PLAY_IN_ANDROID_BROWSER = 8020;

    SMPError.getError = function(type) {
        return new SMPError(type);
    };

    SMPError.prototype.toSimple=function() {
        var obj={};
        obj.code = this.code;
        obj.type = this.type;
        obj.description = this.description;
        obj.severity = this.severity;
        obj.responsibility = this.responsibility;
        obj.recoverable = this.recoverable;
        obj.secondaryText = this.secondaryText;
        obj.detail = this.detail;
        obj.info = this.info;
        return obj;
    };

    SMPError.init = function() {
        errors = {
            '1001' : {
                code            : 1001,
                description     : Language.defaultErrorMessage,
                detail          : "Player attempted to load a non BBC playlist",
                severity        : CRITICAL,
                responsibility  : APPLICATION
            },
            '1002' : {
                code            : 1002,
                description     : Language.defaultErrorMessage,
                detail          : "There was an error loading the playlist",
                severity        : CRITICAL,
                responsibility  : APPLICATION
            },
            '1003' : {
                code            : 1003,
                description     : Language.defaultErrorMessage,
                detail          : "This content is not currently available on this device",
                severity        : CRITICAL,
                responsibility  : MEDIA
            },
            '1004' : {
                code            : 1004,
                description     : Language.programmePreAvailability,
                detail          : "This programme is not available to play yet",
                severity        : CRITICAL,
                responsibility  : MEDIA
            },
            '1005' : {
                code            : 1005,
                description     : Language.contentPostAvailability,
                detail          : "This content is no longer available",
                severity        : CRITICAL,
                responsibility  : MEDIA
            },
            '1006' : {
                code            : 1006,
                description     : Language.programmeRegionRestriction,
                detail          : "This content is no longer available",
                severity        : CRITICAL,
                responsibility  : MEDIA
            },
            '1026' : {
                code            : 1026,
                description     : Language.defaultErrorMessage,
                detail          : "The media selector request failed",
                severity        : CRITICAL,
                responsibility  : "MediaSelector"
            },
            '1039' : {
                code            : 1039,
                description     : Language.httpsOnlyFailure,
                detail          : "HTTPS only playback failed",
                severity        : CRITICAL,
                responsibility  : MEDIA,
                recoverable : true,
                secondaryText : ""
            },
            '1051' : {
                code            : 1051,
                description     : Language.defaultErrorMessage,
                detail          : "This content is not Audio or Video",
                severity        : CRITICAL,
                responsibility  : MEDIA
            },
            '1052' : {
                code            : 1052,
                description     : Language.contentNotAvailableOnDevice,
                detail          : "This content is not currently available on this device",
                severity        : CRITICAL,
                responsibility  : MEDIA
            },
            '1056' : {
                code            : 1056,
                description     : Language.programmeRegionRestriction,
                secondaryText   : "",
                detail          : "Content not available mediaselector GEO",
                severity        : CRITICAL,
                responsibility  : MEDIA
            },
            '1057' : {
                code            : 1057,
                description     : Language.contentNotAvailableOnDevice,
                detail          : "Content not available OTHER",
                severity        : CRITICAL,
                responsibility  : MEDIA
            },
            '1058' : {
                code            : 1058,
                description     : Language.contentNotAvailableOnDevice,
                detail          : "Content not available UNKNOWN",
                severity        : CRITICAL,
                responsibility  : MEDIA
            },
            '1059' : {
                code            : 1059,
                description     : Language.itemRevoked,
                detail          : "Content not available revoked",
                severity        : CRITICAL,
                responsibility  : MEDIA
            },
            '1060' : {
                code            : 1060,
                description     : Language.defaultErrorMessage,
                detail          : "There was an error parsing the playlist",
                severity        : CRITICAL,
                responsibility  : MEDIA
            },
            '1061' : {
                code            : 1061,
                description     : Language.programmePreAvailability,
                detail          : "This live stream has not started yet.",
                severity        : CRITICAL,
                responsibility  : MEDIA,
                visible         : true
            },
            '1062' : {
                code            : 1062,
                description     : Language.defaultErrorMessage,
                detail          : "There were connections (from MediaSelector or hrefs), but all were filtered out",
                severity        : CRITICAL,
                responsibility  : MEDIA
            },
            '1064' : {
                code            : 1064,
                description     : Language.defaultErrorMessage,
                detail          : "There was an error parsing the playlist",
                severity        : CRITICAL,
                responsibility  : MEDIA
            },
            '1065' : {
                code            : 1065,
                description     : Language.defaultErrorMessage,
                detail          : "The playlist contained no items",
                severity        : CRITICAL,
                responsibility  : MEDIA
            },
            '1066' : {
                code            : 1066,
                description     : Language.defaultErrorMessage,
                detail          : "The playlist contained no items after filtering",
                severity        : CRITICAL,
                responsibility  : MEDIA
            },
            '1068' : {
                code            : 1068,
                description     : Language.defaultErrorMessage,
                detail          : "Mediaselector timed out",
                severity        : CRITICAL,
                responsibility  : MEDIA,
                recoverable     : true
            },
            '1069' : {
                code            : 1069,
                description     : Language.defaultErrorMessage,
                detail          : "Mediaselector errored",
                severity        : CRITICAL,
                responsibility  : MEDIA,
                recoverable     : true
            },
            '2100' : {
                code            : 2100,
                description     : WARNING,
                detail          : "SMPj experienced an internal error that it did not know how to handle",
                severity        : WARNING,
                responsibility  : APPLICATION
            },
            '2200' : {
                code            : 2200,
                description     : WARNING,
                detail          : "Playing failed, no intent",
                severity        : WARNING,
                responsibility  : APPLICATION
            },
            '2201' : {
                code            : 2201,
                description     : WARNING,
                detail          : "Playing started, after no intent",
                severity        : WARNING,
                responsibility  : APPLICATION
            },
            '3025' : {
                code            : 3025,
                description     : Language.networkNotAvailable,
                detail          : "Appear to be offline",
                severity        : CRITICAL,
                responsibility  : MEDIA,
                recoverable     : true
            },
            '4200' : {
                code            : 4200,
                description     : Language.defaultErrorMessage,
                detail          : "The requested stream manifest could not be loaded",
                severity        : ERROR,
                responsibility  : MEDIA
            },
            '4201' : {
                code            : 4201,
                description     : Language.defaultErrorMessage,
                detail          : "The manifest file contains no valid streams",
                severity        : ERROR,
                responsibility  : MEDIA
            },
            '4202' : {
                code            : 4202,
                description     : Language.defaultErrorMessage,
                detail          : "Failed to load headers for stream",
                severity        : ERROR,
                responsibility  : MEDIA
            },
            '4203' : {
                code            : 4203,
                description     : Language.defaultErrorMessage,
                detail          : "Failed to load stream fragment",
                severity        : ERROR,
                responsibility  : MEDIA
            },
            '4204' : {
                code            : 4204,
                description     : Language.defaultErrorMessage,
                detail          : "Attempting to play DASH connection with no MSE support",
                severity        : ERROR,
                responsibility  : APPLICATION
            },
            '4205' : {
                code            : 4205,
                description     : Language.defaultErrorMessage,
                detail          : "DASH Reported media source error",
                severity        : WARNING,
                responsibility  : APPLICATION
            },
            '4223' : {
                code            : 4223,
                description     : Language.defaultErrorMessage,
                detail          : "Failed to load init fragment",
                severity        : ERROR,
                responsibility  : MEDIA
            },
            '4224' : {
                code            : 4224,
                description     : "Unknown manifest error",
                detail          : "A generic manifest error occurred",
                severity        : ERROR,
                responsibility  : MEDIA
            },
            '4225' : {
                code            : 4225,
                description     : Language.defaultErrorMessage,
                detail          : "Failed to load stream fragment",
                severity        : ERROR,
                responsibility  : MEDIA
            },
            '4229' : {
                code            : 4229,
                description     : Language.defaultErrorMessage,
                detail          : "Failed to load stream fragment",
                severity        : WARNING,
                responsibility  : MEDIA
            },
            '4226' : {
                code            : 4226,
                description     : Language.defaultErrorMessage,
                detail          : "The manifest file could not be parsed",
                severity        : ERROR,
                responsibility  : MEDIA
            },
            '4227' : {
                code            : 4227,
                description     : Language.codecErrorMessage,
                detail          : "Client does not support any available codecs",
                severity        : CRITICAL,
                secondaryText : ""
            },
            '4228' : {
                code            : 4228,
                description     : Language.defaultErrorMessage,
                detail          : "Client does not support any available codecs failover to flash",
                severity        : ERROR
            },
            '4233' : {
                code            : 4233,
                description     : "An unspecified dash.js error occurred",
                severity        : WARNING,
                responsibility  : APPLICATION,
                recoverable     : true
            },
            '4234' : {
                code: 4234,
                description     : "Dash.js thought there was content in the buffer, but there was not",
                severity        : "info",
                responsibility  : APPLICATION,
                recoverable     : true
            },
            '4237' : {
                code            : 4237,
                description     : "Slow download",
                detail          : "A DASH fragment took longer to download than it would to play out",
                severity        : WARNING,
                responsibility  : APPLICATION,
                recoverable     : true
            },
            '4238' : {
                code            : 4238,
                description     : Language.insufficientBandwidth,
                detail          : "DASH fragments consistently took longer to download than it would to play out",
                severity        : CRITICAL,
                responsibility  : APPLICATION,
                recoverable     : true
            },
            '4240' : {
                code            : 4240,
                description     : Language.defaultErrorMessage,
                detail          : "A DASH failure happened, and now we've played out the rest of the buffer.",
                severity        : CRITICAL,
                responsibility  : APPLICATION,
                recoverable     : true
            },
            '4241' : { 
                code            : 4241,
                description     : Language.defaultErrorMessage,
                detail          : "Failed to load stream fragment because the content-length header didn't match the content",
                severity        : ERROR,
                responsibility  : MEDIA
            },
            '5000' : {
                code            : 5000,
                description     : Language.defaultErrorMessage,
                detail          : "No alternative media format available",
                severity        : CRITICAL,
                responsibility  : MEDIA
            },
            '4999' : { /* XXX Consider if this is in the right place, it's not, but we might just review all this when we have proper offline detection etc. rollover in general is pretty broken */
                code            : 4999,
                description     : Language.defaultErrorMessage,
                detail          : "No alternative media format available after failover, probably offline",
                severity        : CRITICAL,
                responsibility  : MEDIA,
                recoverable     : true
            },
            '5003' : {
                code            : 5003,
                detail          : "The format of the media resource could not be decoded (video)",
                severity        : ERROR,
                responsibility  : MEDIA
            },
            '5004' : {
                code            : 5004,
                detail          : "The format of the media resource could not be decoded (audio)",
                severity        : ERROR,
                responsibility  : MEDIA
            },
            '5005' : {
                code            : 5005,
                detail          : "HTML5 MEDIA_ERR_ABORTED - (video)",
                severity        : ERROR,
                responsibility  : MEDIA
            },
            '5006' : {
                code            : 5006,
                detail          : "HTML5 MEDIA_ERR_ABORTED - (audio)",
                severity        : ERROR,
                responsibility  : MEDIA
            },
            '5007' : {
                code            : 5007,
                detail          : "HTML5 MEDIA_ERR_NETWORK - (video)",
                severity        : ERROR,
                responsibility  : MEDIA
            },
            '5008' : {
                code            : 5008,
                detail          : "HTML5 MEDIA_ERR_NETWORK - (audio)",
                severity        : ERROR,
                responsibility  : MEDIA
            },
            '5009' : {
                code            : 5009,
                detail          : "The video tag fired an error event, but there was no error available on the element",
                severity        : WARNING,
                responsibility  : MEDIA
            },
            '5010' : {
                code            : 5010,
                detail          : "The audio tag fired an error event, but there was no error available on the element",
                severity        : WARNING,
                responsibility  : MEDIA
            },
            '5100' : {
                code            : 5100,
                detail          : "The video could not be decoded with the provided key (if any).",
                severity        : WARNING,
                responsibility  : EXTERNAL
            },
            '5101' : {
                code            : 5101,
                description     : Language.defaultErrorMessage,
                detail          : "A DRM error fired, and the timeout elapsed without it being corrected",
                severity        : CRITICAL,
                responsibility  : EXTERNAL
            },
            '6003' : {
                code            : 6003,
                description     : Language.errorUnsupported,
                detail          : "Browser does not have MSE support",
                severity        : CRITICAL,
                responsibility  : APPLICATION,
                secondaryText : ""
            },
            '6004' : {
                code            : 6004,
                description     : Language.defaultErrorMessage,
                detail          : "The player could not be initialised in time",
                severity        : CRITICAL,
                responsibility  : APPLICATION
            },
            '6006' : {
                code            : 6006,
                description     : Language.defaultErrorMessage,
                detail          : "Dash.js could not be initialised in time",
                severity        : CRITICAL,
                responsibility  : APPLICATION,
                recoverable     : true
            },
            '6011' : {
                code            : 6011,
                description     : Language.defaultErrorMessage,
                detail          : "No source has been found for this video",
                severity        : ERROR,
                responsibility  : MEDIA
            },
            '6100' : {
                code            : 6100,
                description     : "Plugin load failed",
                severity        : ERROR,
                responsibility  : APPLICATION
            },
            '6102' : {
                code            : 6102,
                description     : "Plugin load timed out",
                severity        : ERROR,
                responsibility  : APPLICATION
            },
            '6101' : {
                code            : 6101,
                description     : "Plugin initialise failed",
                severity        : ERROR,
                responsibility  : APPLICATION
            },
            '6250' : {
                code            : 6250,
                description     : "Plugin load timed out",
                severity        : ERROR,
                responsibility  : APPLICATION
            },
            '6500' : {
                code            : 6500,
                description     : "This content is not available on this site. Visit the BBC site to enjoy this content.",
                severity        : CRITICAL,
                responsibility  : EXTERNAL,
                recoverable     : true
            },
            '7500' : {
                code            : 7500,
                detail          : "There was an error loading Subtitles",
                severity        : WARNING,
                responsibility  : MEDIA
            },
            '7501' : {
                code            : 7501,
                detail          : "Failing over thumbnail manifest",
                severity        : WARNING,
                responsibility  : MEDIA
            },
            '7502' : {
                code            : 7502,
                detail          : "Webfont failed to load",
                severity        : WARNING,
                responsibility  : EXTERNAL
            },
            '7750' : {
                code            : 7750,
                detail          : "Language failed to load",
                severity        : WARNING,
                responsibility  : EXTERNAL
            },
            '8000' : {
                code            : 8000,
                description     : Language.errorFlashIsNeeded,
                detail          : "Flash creation failed.",
                severity        : CRITICAL,
                responsibility  : EXTERNAL
            },
            '8001' : {
                code            : 8001,
                description     : Language.errorFlashIsNeeded,
                detail          : "Flash initialisation failed.",
                severity        : CRITICAL,
                responsibility  : EXTERNAL
            },
            '8005' : {
                code            : 8005,
                description     : Language.errorFlashIsNeeded,
                detail          : "Flash not installed",
                severity        : CRITICAL,
                responsibility  : EXTERNAL
            },
            '8010' : {
                code            : 8010,
                description     : Language.defaultErrorMessage,
                detail          : "Flash Error.",
                severity        : CRITICAL,
                responsibility  : UNKNOWN
            },
            '8020' : {
                code            : 8020,
                description     : Language.errorCantPlayInBrowser,
                detail          : "Can't play in android/kindle browser",
                severity        : CRITICAL,
                responsibility  : EXTERNAL
            },
            'unknown' : {
                description     : Language.defaultErrorMessage,
                detail          : "An unknown error occurred",
                severity        : ERROR,
                responsibility  : UNKNOWN
            },
            'unknownCritical' : {
                description     : Language.defaultErrorMessage,
                detail          : "An unknown error occurred",
                severity        : CRITICAL,
                responsibility  : UNKNOWN
            }
        };
    };

    return SMPError;

})();
// trim (mostly for unit tests as this shouldn't apply to any browser,
// but who knows...)
if (!String.prototype.trim) {
  String.prototype.trim = function () {
    return this.replace(/^\s+|\s+$/g,'');
  };
}

function emptyFunction() {}


var HIDDEN_PLAYER = "-9999px";
var HIDDEN_PLAYER_MINIMODE = "-9998px";
var HIDDEN_PLAYER_SWF = "-9997px";
var DUPLICATE_EVENT_TIMEOUT = 500;
var KEY_ESCAPE = 27;
var KEY_SPACE = 32;
var KEY_LEFT_ARROW = 37;
var KEY_UP_ARROW = 38;
var KEY_RIGHT_ARROW = 39;
var KEY_DOWN_ARROW = 40;
var KEY_HOME = 36;
var KEY_END = 35;
var KEY_F = 70;
var KEY_M = 77;
var KEY_ENTER = 13;
var KEY_0 = 48;
var KEY_8 = 56;
var KEY_9 = 57;

var KEY_J = 74;
var KEY_K = 75;
var KEY_L = 76;

var STATS_TRACK_DELAY = 2000;

// Some generic UI functions


function stopIt(e) {
    if (e.preventDefault) {
        e.preventDefault();
    }
    if (e.stopPropagation) {
        e.stopPropagation();
    }
}

function appendChildren(el,elements) {
    for (var i=0;i<elements.length;i++) {
        el.appendChild(elements[i]);
    }
}

function createElement(type,className,html,text) {
    var el = document.createElement(type);
    el.className = className;
    if (html) {
        el.innerHTML = html;
        if (text) {
            el.firstChild.textContent = text;
        }
    }
    return el;
}

function updateExistingSvg(element,icon,extraClass) {
    // only remove and add if not already there
    var iconToUse = element.getElementsByClassName('p_' + icon + 'Icon')[0];
    var otherIcons = element.getElementsByClassName('p_iconHolder');
    for (var i = 0; i < otherIcons.length; i++) {
        // unsafe rethink.
        if (otherIcons[i].firstChild == iconToUse) {
            otherIcons[i].style.display = 'block';
        } else {
            otherIcons[i].style.display = 'none';
        }
    }
    if (!iconToUse) {
        // XXX would be nice not to have this different size...
        var size=44;
        if (icon=="fullscreen-return") {
            size=32;
        }
        element.appendChild(Utils.generateSVG(size,size,icon,'p_' + icon + 'Icon', extraClass));
    }
}




var Utils = (function() {

    var eventFieldData = {
        'loadstart' : ['currentSrc', 'preload', 'networkState'],  // the user agent begins looking for media data
        'loadedmetadata' : ['duration', 'readyState'],  // the user agent has just determined the duration and dimensions of the media resource and the text tracks are ready
        'canplay' : ['readyState'],  // the user agent can resume playback of the media data (but may not be able to complete without buffering)
        'canplaythrough' : ['readyState'],  // the user agent can resume playback of the media data (and should be able to complete without buffering)
        'play' : ['paused'],  // the element is no longer paused, fired after the play() method has returned, or when the autoplay attribute has caused playback to begin
        'pause' : ['paused','ended'],  // the element has been paused, fired after the pause() method has returned
        'playing' : ['paused', 'readyState'],  // playback is ready to start after having been paused or delayed due to lack of media data
        'seeking' : ['seeking'],  // the seeking IDL attribute changed to true
        'seeked' : ['seeking'],  // the seeking IDL attribute changed to false
        'timeupdate' : ['readyState'],
        'ended' : ['ended'],  // playback has stopped because the end of the media resource was reached
        'durationchange' : ['duration'],  // the duration attribute has just been updated
        'volumechange' : ['volume', 'muted'],  // either the volume attribute or the muted attribute has changed, fired after the relevant attribute's setter has returned
        'error' : ['error', 'networkState'],  // an error occurs while fetching the media data
        'waiting' : ['readyState']
    };

    var JSON_errors = {};
    var JSON_count = [];
    var JSON_timeout = 45000;

    function getFunction(callbackId,func) {
        return function(data) {
            clearTimeout(JSON_errors[callbackId]);
            window[callbackId]=emptyFunction;
            func(data);
        };
    }

    function getJsonId() {
        for (var i=JSON_count.length-1;i>=0;i--) {
            if (!JSON_count[i]) {
                JSON_count[i]=true;
                return i;
            }
        }
        JSON_count.push(true);
        return JSON_count.length-1;
    }

    function resetJsonId(e) {
        var id=parseInt(e.target.getAttribute("json_id"),10);
        JSON_count[id]=false;
    }

    // XXX temporary for smp-offline until SMP offline passes
    // through a setting saying it's offline.
    var doOnLineCheck = ((location.href+'').indexOf('file:')!==0);
    function getJSON(url,callback) {
        var args=arguments;
        var id=getJsonId();
        var callbackId="JS_callbacks"+id;
        window[callbackId]=getFunction(callbackId,callback);

        var gotFunc = function() {
            // prevent mediation
            // coming in so amazingly late
            // starting playback
            // anyway.
            window[callbackId]=emptyFunction;
            var index=getJSONs.indexOf(args);
            getJSONs.splice(index,1);
            callback({result:"timeout"});
        };

        JSON_errors[callbackId] = setTimeout(gotFunc,JSON_timeout);

        // XXX temporary for smp-offline until SMP offline passes
        // through a setting saying it's offline.
        if (navigator.onLine===false && doOnLineCheck) {
            if (DEBUG_FULL) { console.log("Asked to get href, but not online, delaying until online"); }
            window.removeEventListener("online",flushGets);
            getJSONs.push(args);
            window.addEventListener("online",flushGets);
            return;
        }


        url=url.replace("{callback}",callbackId);
        var scriptElement = document.createElement('script');
        scriptElement.type="text/javascript";
        scriptElement.src=url;
        scriptElement.setAttribute("json_id",id);
        scriptElement.onload=resetJsonId;


        var scriptErrorJsonId=function(e) {
            resetJsonId(e);
            callback({result:"scripterror"});
        };

        scriptElement.onerror=scriptErrorJsonId;
        document.getElementsByTagName('head')[0].appendChild(scriptElement);
    }

    function delayedErrorFunction(player,type,extra,nonPlayer,lowSeverity) {
        callErrorFunction(player,type,extra,nonPlayer,lowSeverity,true);
    }

    function callErrorFunction(player,type,extra,nonPlayer,lowSeverity,delay) {
        if (DEBUG_FULL) {
            console.log('Calling error function', player, type);
        }

        var error = SMPError.getError(type);
        error.nonPlayer = nonPlayer;
        error.extra = extra;
        if (lowSeverity) {
            error.morphed = true;
            error.severity = 'error';
        }
        if (delay) {
            player.delayedDispatch(error);
        } else {
            player.dispatch(error);
        }
    }

    function mixin(dest, source, copy) {
        var name, s, empty = {};
        if (dest) {
            for (name in source) {
                if (source.hasOwnProperty(name)) {
                    s = source[name];
                    if (!(name in dest) || (dest[name] !== s && (!(name in empty) || empty[name] !== s))) {
                        if (typeof dest[name] === "object" && dest[name]!==null) {
                            dest[name] = mixin(dest[name],s,copy);
                        } else {
                            dest[name] = copy(s);
                        }
                    }
                }
            }
        }
        return dest;
    }

    function merge() {
        var obj = clone(arguments[0]);
        if (obj) {
            for (var i = 1; i < arguments.length; i++) {
                if (arguments[i]) {
                    obj = mixin(obj,arguments[i],clone);
                }
            }
        }
        return obj;
    }

    function clone(src) {
        if (!src || typeof src != "object") {
            return src; // anything
        }
        var r, i, l;
        if (src instanceof Array) {
            // array
            r = [];
            for (i = 0, l = src.length; i < l; ++i) {
                if (i in src) {
                    r.push(clone(src[i]));
                }
            }
        } else {
            r = {};
        }
        return mixin(r, src, clone);
    }

    function hasClass(element, className) {
        return element && (element.className+'').indexOf(className) > -1;
    }

    function className(el,add,remove) {
        if (!el) {
            return;
        }
        var cName = el.className;
        if (cName === "") {
            el.className = add;
            return;
        }
        cName = (cName.replace(getReplaceRegExp(remove || "",add),"")).trim() + " "+add;
        el.className = cName.trim().replace(/\s+/g,' ');
    }

    function setOrUnsetClass(object, clazz, bool) {
        if (bool) {
            Utils.className(object, clazz);
        } else {
            Utils.className(object, '', clazz);
        }
    }

    function setOrUnsetClassOnlyAfterCheck(object, clazz, set, unset) {

        var isTheClassAlredySetted = hasClass(object,clazz);

        if (isTheClassAlredySetted && unset) {
            className(object, '', clazz);
        } else if (!isTheClassAlredySetted && set) {
            className(object, clazz, '');
        }
    }

    function getReplaceRegExp(a,b) {
        var str = a + " " + b;
        str = str.trim().replace(/\s+/g,"\\b|\\b");
        return new RegExp("\\b"+str+"\\b","g");
    }

    /**
     * Convert sections into a time display
     *
     */
    function secondsToTime(seconds,justHoursAndMinutes,neverEmpty,padHours) {

        // odd input should return nothing - avoid -Infinity and stuff
        if (isNaN(seconds) || seconds < 0 || seconds > 360000) {
            return neverEmpty ? "--:--" : "";
        }

        if (!seconds) {
            return "00:00";
        }



        var mins = Math.floor(seconds / 60);
        var hours = Math.floor(mins / 60);
        mins = Math.floor(mins % 60);
        var secs = Math.floor(seconds % 60);
        var paddedHours = (padHours && hours < 10) ? '0'+hours : hours;

        if (mins < 10) {
            mins = '0' + mins;
        }
        if (secs < 10) {
            secs = '0' + secs;
        }

        var time = [mins,secs];
        if (hours > 0 || justHoursAndMinutes) {
            time.unshift(paddedHours);
        }
        if (justHoursAndMinutes) {
            time.pop();
        }
        return time.join(':');
    }

    function epochToTime(time, bst, neverEmpty, justHoursAndMinutes, padHours) {
        // if it's not an epoch, then there is no time here.
        if (time <14000000) {
            return neverEmpty ? secondsToTime(time, false, true) : "";
        }
        var d = new Date((time * 1000) + (bst ? 60 * 60 * 1000 : 0 ));
        var seconds = d.getUTCHours() * 60 * 60 + d.getUTCMinutes() * 60 + d.getUTCSeconds();

        return secondsToTime(seconds, justHoursAndMinutes, neverEmpty, padHours);
    }


    var validHoldingImagesRE = new RegExp("^//|^http[s]{0,1}://","i");
    function holdingImage(playlist,container, uiPoster) {
        var url = null;
        if (!playlist) {
            return null;
        }
        if (playlist.posterRecipe) {
            url = playlist.posterRecipe;
        }
        if (!url) {
            url = playlist.posterImg;
        }
        if (!url) {
            return null;
        }
        if (!validHoldingImagesRE.test(url)) {
            return null;
        }
        return "url("+doChef(url, container, uiPoster)+")";
    }

    var recipesWidth = [ 320, 384, 432, 480, 512, 608, 640, 688, 720, 768, 800, 832, 976, 1024, 1376, 1920 ];
    var recipesHeight = [ 180, 216, 243, 270, 288, 342, 360, 387, 405, 432, 450, 468, 549, 576, 774, 1080 ];

    function doChef(url,container,uiPoster, knownWidth) {
        var width;
        if (knownWidth) {
            width = knownWidth;
        } else {
            width = Utils.getOffset(container,'width');
        }

        if (width === 0 || isNaN(width)) {
            width = 768;
        }
        if (uiPoster && uiPoster.densityMultiplier) {
            width = width * uiPoster.densityMultiplier;
        }
        for (var i = recipesWidth.length - 1; i > 0; i--) {
            if (width / recipesWidth[i] > 0.98) {
                break;
            }
        }
        var recipe = recipesWidth[ i ] + "x" + recipesHeight[ i ];
        // news only go to 1024, and after that have 1536
        var newsWidth = recipesWidth[i]<=1024 ? recipesWidth[i] : 1536;
        return url.replace( /[\${]recipe}?/, recipe ).replace( /[\${]width}?/, newsWidth );
    }

    function annotateEvent(event,player) {
        var type = event.type;

        if (player.mediaItem) {
            if (type == "playing") {
                event = player.mediaItem.annotateEvent(event);
            }
            if (type == "loadedmetadata") {
                var mc = player.mediaConnection;
                if (mc) {
                    event.transferFormat = mc.format;
                    event.cdn = mc.supplier;
                    event.height = player.mediaPlayer.videoHeight;
                    event.width = player.mediaPlayer.videoWidth;
                }
            }
            if (type == "timeupdate" || type=="seeked" || type=="seeking") {
                var th = player.timeHelper;
                event.duration = th.duration;
                if (player.isLive) {
                    event.currentTime = th.time;
                    event.streamStart = th.streamStart;
                    event.latestSeek = th.latestSeek;
                    event.earliestSeek = th.earliestSeek;
                    event.streamEnd = th.streamEnd;
                    event.joinTime = th.joinTime;
                    event.livePoint = event.latestSeek;
                } else {
                    event.currentTime = th.time;
                }
            }
        }

        // Check HTML event properties
        if (Utils.eventFieldData[type]) {
            var types = Utils.eventFieldData[type];
            var ul = types.length;
            for (var i = 0; i < ul; i++) {
                var property = types[i];
                event[property] = player.mediaPlayer[property];
            }
        }

        if (type == "volumechange") {
            event.volume = event.muted ? 0 : event.volume;
        }


        return event;
    }

    var reasonMap = {
        "postAvailability" : SMPError.CONTENT_NOT_AVAILABLE_EXPIRED,
        "postLiveAvailability" : SMPError.CONTENT_NOT_AVAILABLE_EXPIRED,
        "preAvailability" : SMPError.PROGRAMME_NOT_AVAILABLE_YET,
        "regionRestriction" : SMPError.CONTENT_NOT_AVAILABLE_REGION,
        "selectionunavailable" : SMPError.CONTENT_NOT_AVAILABLE,
        "geolocation" : SMPError.CONTENT_NOT_AVAILABLE_GEO,
        "other" : SMPError.CONTENT_NOT_AVAILABLE_OTHER,
        "itemRevoked" : SMPError.CONTENT_NOT_AVAILABLE_REVOKED,
        "EmptyPlaylistObject" : SMPError.NO_ITEMS,
        "EmptyPlaylistObjectFiltered" : SMPError.NO_ITEMS_FILTERED,
        "noMedia" : SMPError.CONTENT_NOT_AVAILABLE,
        "timeout" : SMPError.MEDIASELECTOR_TIMEOUT,
        "error" : SMPError.MEDIATION_ERROR,
        "scripterror" : SMPError.MEDIATION_ERROR_UNKNOWN,
        "nocvidmediator" : SMPError.CONTENT_NOT_AVAILABLE
    };

    function checkForItemsErrors(player, playlist) {
        var items = playlist.items;
        // display error if no media items left after filtering
        if (!items || items.length===0 || playlist.onlyAdverts) {
            if (DEBUG_FULL) { console.log('nothing to play:'+playlist.noItemsReason); }
            var err = SMPError.NO_ITEMS_IN_PLAYLIST;
            if (reasonMap[playlist.noItemsReason]) {
                err = reasonMap[playlist.noItemsReason];
            }
            Utils.callErrorFunction(player,err);
            return true;
        }
        return false;
    }

    function checkNotAvailableReason(player, item) {
        var err = SMPError.CONTENT_NOT_AVAILABLE_UNKNOWN;
        if (item.result) {
            var extra= item.result.reason;
            if (reasonMap[extra]) {
                err = reasonMap[extra];
                extra = null;
            }
        }
        var makeLowPriority = false;
        if (player.supportFallback ) {
            if (DEBUG_FULL) {
                console.log('flash is available so morphing to fall back');
            }
            Utils.asyncDelay(player.fallbackAsAppropriate, [],player);
            makeLowPriority = true;
        } else {
            if (player.supportFallbackLocked) {
                delayedErrorFunction(player,SMPError.CANNOT_MAINTAIN_LOCK);
                return false;
            }
        }
        Utils.callErrorFunction(player,err,extra,false, makeLowPriority);
        return false;
    }

    function checkCssSupport(el,property) {
        if ( property in el.style ) {
            return true;
        }
        property = property.replace(/^[a-z]/, function(val) {
            return val.toUpperCase();
        });
        var vendorPrefix = ['Webkit','Moz'];
        for (var i = 0; i < vendorPrefix.length; i++) {
            if ( vendorPrefix[i] + property in el.style ) {
                return true;
            }
        }
        return false;
    }

    function applyVendorStyles(arr,property,value) {
        for (var i=0;i<arr.length;i++) {
            var el=arr[i];
            if (el && el.style) {
                el.style[property] = value;
                if (value===null && el.style.removeProperty) {
                    el.style.removeProperty(property);
                }
                property = property.replace(/^[a-z]/, function(val) {
                                                return val.toUpperCase();
                                            });
                el.style["webkit" + property] = value;
                el.style["moz" + property] = value;
                el.style["ms" + property] = value;
                el.style["o" + property] = value;
            }
        }
    }

    function deleteCssRules(sheet, arr) {
        for (var i=sheet.cssRules.length-1;i>=0;i--) {
            var rule = sheet.cssRules[i].cssText;
            for (var j=0;j<arr.length;j++) {
                if (rule.indexOf(arr[j])!=-1) {
                    sheet.deleteRule(i);
                    break;
                }
            }
        }
    }

    function parseISODate(str) {
        str=(str+"").replace(/\D/gim,' ');
        var arr = str.split(/\s+/gim);
        return Date.UTC(arr[0],arr[1]-1,arr[2],arr[3],arr[4],arr[5]);
    }

    /**
     * Check if a url is on bbc.co.uk/bbc.com (any subdomain)
     *
     */
    function isValidUrl(url) {
        for (var i=0; i< window.validDomains.length; i++) {
            var alternativeUrl = new RegExp('^(http[s]{0,1})://([^\\?\\&#:/]+\\.' + window.validDomains[i] + ')(:([0-9]+))?','gi');
            if (url.match(alternativeUrl)) {
                return true;
            }
        }
        return false;
    }

    function getItemById( arr, id ) {
        if (arr && arr.length>0) {
            for (var i=0;i<arr.length;i++) {
                if (arr[i]._id == id) {
                    return arr[i];
                }
            }
        }
        return null;
    }

    var aliases={"chapter":["chapter","programme"], "key":["highlight","key"]};

    function getMarkerByType(arr,suppress,type) {
        var possible=[];
        var filtered=[];
        if (arr) {
            if (suppress && suppress.length>0) {
                for (var i=0;i<arr.length;i++) {
                    if (arr[i] && suppress.indexOf(arr[i].type)==-1) {
                        possible.push(arr[i]);
                    }
                }
            } else {
                possible = arr;
            }
            for (i=0;i<possible.length;i++) {
                if (possible[i] && aliases[type].indexOf(possible[i].type)!=-1) {
                    filtered.push(possible[i]);
                }
            }
        }
        return filtered;
    }

    function getActionFn(func,justDeDupe, propagate) {
        var acting = false;
        var resetActing = function() {
            acting = false;
        };
        return function(event) {
            if (!acting) {
                if (justDeDupe) {
                    func(event);
                } else {
                    if (event.button && event.button !== 0) {
                        return;
                    }
                    var actionType = getActionType(event);
                    func(actionType, event);
                }
                acting = true;
                setTimeout(resetActing,DUPLICATE_EVENT_TIMEOUT);
            }

            if(!propagate) {
                event.stopImmediatePropagation();
            }
        };
    }

    function generateSVG(width,height,icon,classname,extraClass) {
        var svgContainer = document.createElement('div');
        svgContainer.className = "p_iconHolder";
        if (icon) {
            svgContainer.innerHTML = ['<svg focusable="false" viewbox="0 0 ',width,' ',height,'" class="p_svg ',(extraClass || ''),' ',(classname || ''),'"><use xlink:href="#',icon,'"></use></svg>'].join('');
        }
        return svgContainer;
    }

    function isXhrRequestOk(href, error, item, domainOptional) {
        // If domainOptional, allow protocol://..,  //... or / or ./ or ../
        // If not, only allow the first two
        var re = domainOptional ? /^((([a-zA-Z]+\:)?\/\/)|\/|[\.]{1,2}\/)/ : /^([a-zA-Z]+\:)?\/\//;
        if (item.loading) {
            if (DEBUG_FULL) { console.log("LOADER: not loading as it's already loading:", href); }
            return false;
        }
        if (href && !href.match(re) && href.indexOf("data:")!==0) {
            if (DEBUG_FULL) { console.log("LOADER: not loading as this doesn't look like an absolute URL:", href); }
            Utils.asyncDelay(error,[href]);
            return false;
        }

        return true;
    }

    // getXML and getJSON online detection differs in if the timeout
    // can happen, so be careful...
    var getXMLs=[];
    var getJSONs=[];
    function flushGets() {
        if (DEBUG_FULL) { console.log("Online, now trying"); }
        window.removeEventListener("online",flushGets);

        while (getJSONs.length) {
            getJSON.apply(null, getJSONs.shift());
        }
        while (getXMLs.length) {
            getXML.apply(null, getXMLs.shift());
        }
    }
    function clearPendingReqs() {
        window.removeEventListener("online",flushGets);
        getXMLs = [];
        getJSONs = [];
    }

    function getXML(href, callback, error, item, domainOptional,setWithCredentials) {
        if (!isXhrRequestOk(href, error, item, domainOptional)) {
            return;
        }
        // XXX temporary for smp-offline until SMP offline passes
        // through a setting saying it's offline.
        if (navigator.onLine===false && doOnLineCheck) {
            if (DEBUG_FULL) { console.log("Asked to get href, but not online, delaying until online"); }
            window.removeEventListener("online",flushGets);
            getXMLs.push(arguments);
            window.addEventListener("online",flushGets);
            return;
        }
        var xhr = new XMLHttpRequest();
        var constructXML = false;
        try {
            xhr.open("GET", href, true);
            if (setWithCredentials) {
                xhr.withCredentials = true;
            }
        } catch (e) {
            if (XDomainRequest) {
                xhr = new XDomainRequest();
                constructXML = true;
                xhr.open("GET", href);
            } else {
                return;
            }
        }
        xhr.onload = function() {
            var xmldoc;
            if (constructXML) {
                try {
                    xmldoc =  new ActiveXObject('Microsoft.XMLDOM');
                    xmldoc.async = false;
                    xmldoc.loadXML(xhr.responseText);
                } catch (e) {
                    if (DEBUG_FULL) { console.log("LOADER: failed to parse:", href); }
                    item.loading = false;
                    error(href,true);
                }
            } else {
                xmldoc = xhr.responseXML;
                if (!xmldoc && window.DOMParser) {
                    var parser = new DOMParser();
                    xmldoc = parser.parseFromString(xhr.responseText, "text/xml");
                }
            }
            item.loading = false;
            callback(xmldoc);
        };
        xhr.onerror = function() {
            if (DEBUG_FULL) { console.log("Loader: Error downloading: ", href);}
            item.loading = false;
            error(href);
        };
        item.loading = true;
        xhr.send(null);
    }

    function getText(href, callback, error, item, domainOptional) {
        if (!isXhrRequestOk(href, error, item, domainOptional)) {
            return;
        }
        var xhr = new XMLHttpRequest();
        xhr.open("GET", href, true);
        xhr.responseType = "text";
        xhr.onload = function() {
            item.loading = false;
            callback(xhr.response);
        };
        xhr.onerror = function() {
            if (DEBUG_FULL) { console.log("Loader: Error downloading: ", href);}
            item.loading = false;
            error(href);
        };

        item.loading = true;
        xhr.send(null);
    }

    function getOffset(element, type) {
        var rect = element.getBoundingClientRect();
        type = type || "left";
        var unadjustedOffset = rect[type];
        return needsSizingFix(element) ? unadjustedOffset * 100 : unadjustedOffset;
    }

    function getOffsets(element) {
        var rect = element.getBoundingClientRect();
        if (needsSizingFix(element)) {
            rect.left = rect.left * 100;
            rect.top = rect.top * 100;
            rect.height = rect.height * 100;
            rect.width = rect.width * 100;
        }
        return rect;
    }

    function multiAddEventListener(element,events,func,useCapture) {
        var arr = typeof events === 'object' ? events : events.split(/\s+/g);
        for (var i = 0; i < arr.length; i++) {
            element.addEventListener(arr[i],func,useCapture);
        }
    }

    function needsSizingFix(element) {
        // IE11 in fullscreen returns incorrect offset sizes (SMPHTML-318)
        return (element.offsetWidth < element.clientWidth);
    }

    function isKeyboardClick(event) {
        return event.type == 'click' && event.clientX === 0 && event.clientY === 0;
    }

    function getActionType(event) {
        return (event.clientX === 0 && event.clientY === 0) ? 'key_press' : 'click';
    }

    function defineProperties(obj,properties) {
        for (var i in properties) {
            if (properties.hasOwnProperty(i)) {
                Object.defineProperty(obj, i, properties[i] );
            }
        }
    }

    window.delayedFunctions=[];
    function asyncDelay(fn,args,that) {
        window.delayedFunctions.push({fn:fn,args:args,that:that});
        if (window.postMessage) {
            window.postMessage("SMP.asyncDelay", "*");
        }
    }

    function isItemAudio(mediaItem) {
        if (mediaItem.connections.length >= 1 && mediaItem.connections[0].mimetype) {
            return mediaItem.connections[0].mimetype.split("/")[0] === "audio";
        } else {
            return mediaItem.type === "audio";
        }
    }

    function stableSort( array, sortFunc ) {
        var positionedArray = array.map( function(item, index){ return {item: item, position: index}; });

        positionedArray.sort(function (a, b) {
            var indexDiff = sortFunc(a.item, b.item);
            if (indexDiff === 0) {
                indexDiff = a.position - b.position;
            }
            return indexDiff;
        });

        var ret = [];
        for (var i = 0; i < positionedArray.length; i++) {
            ret[i] = positionedArray[i].item;
        }

        return ret;
    }


    function clamp(val,low,high) {
        if (val<low) {
            return low;
        }
        if (val>high) {
            return high;
        }
        return val;
    }

    /**
     * Creates an RFC-4122 v4 compliant UUID
     *
     */
    function UUID() {
        // returns a RFC-4122 v4 compliant UUID
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            var r = (Math.random()*new Date())%16|0, v = c == 'x' ? r : (r&0x3|0x8);
            return v.toString(16);
        }).toUpperCase();
    }

    function downAction(element, callback, capture) {
        capture = !!capture;
        if(window.PointerEvent) {
            element.addEventListener('pointerdown', callback, capture);
        } else {
            element.addEventListener('touchstart', function(e) {
                callback(e);
                element.focus();
                e.preventDefault();
            }, capture);
            element.addEventListener('mousedown', callback, capture);
        }
    }

    function upAction(element, callback, capture) {
        capture = !!capture;
        if(window.PointerEvent) {
            element.addEventListener('pointerup', callback, capture);
        } else {
            element.addEventListener('touchend', callback, capture);
            element.addEventListener('mouseup', callback, capture);

        }

    }

    function moveAction(element, callback, capture) {

        capture = !!capture;

        if(window.PointerEvent) {
            element.addEventListener('pointermove', callback, capture);
        } else {

            element.addEventListener('touchmove', callback, capture);
            element.addEventListener('mousemove', callback, capture);

        }

    }

    function hoverMoveAction(element, callback, capture) {
        capture = !!capture;
        if(window.PointerEvent) {
            element.addEventListener('pointermove', function(e) {
                if(e.pointerType == 'mouse') {
                    callback(e);
                }
            }, capture);
        } else {
            element.addEventListener('mousemove', callback, capture);
        }

    }

    function hoverLeaveAction(element, callback, capture) {
        capture = !!capture;
        if(window.PointerEvent) {
            element.addEventListener('pointerleave', function(e) {
                if(e.pointerType == 'mouse') {
                    callback(e);
                }
            }, capture);
        } else {
            element.addEventListener('mouseleave', callback, capture);
        }
    }

    function buttonAction(element, callback) {

        Utils.downAction(element, callback);
        element.addEventListener('keyup', function(e) {
            var keyCode = e.keyCode;
            if (keyCode == 32 || keyCode == 13) {
                callback(e);
            }
        });

    }

    function getCookie(name) {

        name = encodeURIComponent(name);

        var regex = new RegExp(name + '=([^;\\s]*)', 'i');

        var result = regex.exec(document.cookie);

        if(result) {
            return decodeURIComponent(result[1]);
        } else {
            return null;
        }

    }

    function setCookie(name, value, kill) {

        // XXX Where do we check if people let us set cookies?

        var date = new Date();
        date.setTime(date.getTime()+(15552000000*(kill ? -1 : 1))); //Store cookie for 180 days
        if (!kill) {
            date.setDate(15);
            date.setHours(12);
            date.setMinutes(0);
            date.setSeconds(0);
        }
        var expires = date.toUTCString();

        var domain = location.hostname;

        if (domain.indexOf('.bbc.co.uk') !== -1) {
            domain = '.bbc.co.uk';
        }

        if (domain.indexOf('.bbc.com') !== -1) {
            domain = '.bbc.com';
        }

        try {
            document.cookie = encodeURIComponent(name) + '=' + encodeURIComponent(value) + '; expires=' + expires + '; domain=' + domain + '; path=/';
        } catch (e) {}
    }

    var now = function() {
        return Date.now();
    };

    if (window.performance && window.performance.now) {
        now = function() {
            return window.performance.now();
        };
    }

    function loadFontFile(player, fontFace) {
        var font = new FontFaceObserver(fontFace);
        font.load().then(function () {
            Utils.className(document.documentElement, fontFace + "-loaded");
        }, function (){
            Utils.callErrorFunction(player, SMPError.FONT_FAILED, "" + fontFace, false, true);
        });
    }

    function isObjectEmpty(obj) {
        for(var prop in obj) {
            if(obj.hasOwnProperty(prop)) {
                return false;
            }
        }

        return true;
    }

    function object(o) {
        function F(){}
        F.prototype = o;
        return new F();
    }

    function noneOrBlock(bool) {
        if (bool) {
            return "block";
        }
        return "none";
    }

    function padZeros(num, size) {
        var s = num + "";
        while(s.length < size) {
            s = "0" + s;
        }
        return s;
    }

    function createSVGElement(type, attributes) {
        var element = document.createElementNS("http://www.w3.org/2000/svg", type);
        for(var attribute in attributes) {
            if(attributes.hasOwnProperty(attribute)) {
                element.setAttributeNS(null, attribute, attributes[attribute]);
            }
        }
        return element;
    }

    var Utils = {
        getActionFn : getActionFn,
        eventFieldData : eventFieldData,
        getJSON : getJSON,
        getXML : getXML,
        getText: getText,
        clearPendingReqs : clearPendingReqs,
        merge : merge,
        clone : clone,
        isObjectEmpty: isObjectEmpty,
        now : now,
        className : className,
        setOrUnsetClass : setOrUnsetClass,
        setOrUnsetClassOnlyAfterCheck : setOrUnsetClassOnlyAfterCheck,
        hasClass : hasClass,
        secondsToTime : secondsToTime,
        epochToTime : epochToTime,
        callErrorFunction : callErrorFunction,
        delayedErrorFunction:delayedErrorFunction,
        parseISODate : parseISODate,
        asyncDelay : asyncDelay,
        holdingImage : holdingImage,
        annotateEvent : annotateEvent,
        deleteCssRules : deleteCssRules,
        checkCssSupport : checkCssSupport,
        applyVendorStyles : applyVendorStyles,
        checkForItemsErrors : checkForItemsErrors,
        checkNotAvailableReason : checkNotAvailableReason,
        isValidUrl : isValidUrl,
        getMarkerByType : getMarkerByType,
        getItemById : getItemById,
        generateSVG : generateSVG,
        getOffset: getOffset,
        getOffsets: getOffsets,
        multiAddEventListener: multiAddEventListener,
        isKeyboardClick: isKeyboardClick,
        getActionType: getActionType,
        defineProperties : defineProperties,
        isItemAudio: isItemAudio,
        stableSort : stableSort,
        clamp : clamp,
        sortByStart : function(a, b) { return a.start-b.start; },
        sortSimple :  function(a, b) { return a - b; },
        UUID: UUID,
        doChef: doChef,
        downAction: downAction,
        upAction: upAction,
        moveAction: moveAction,
        hoverLeaveAction: hoverLeaveAction,
        hoverMoveAction: hoverMoveAction,
        buttonAction: buttonAction,
        getCookie: getCookie,
        setCookie: setCookie,
        loadFontFile: loadFontFile,
        object: object,
        noneOrBlock: noneOrBlock,
        padZeros: padZeros,
        createSVGElement: createSVGElement
    };
    return Utils;
})();


var TimeHelper = (function() {
    var TAI_TO_UTC_SHIFT = -37;
    var CONSIDERED_UNIX_TIME = 1000000;

    function clampToPercent(val) {
        return Utils.clamp(val,0,1);
    }

    function applyWebcastData(th, item, data) {
        // Documented:
        // https://confluence.dev.bbc.co.uk/display/mp/Time+display+for+Live+streams

        if (!data) {
            if (!item.simulcast) {
                th.earliestSeek = Math.max(th.joinTime, th.streamStart);
            }
        } else {
            var JT = data.ignoreJoinTime ? th.time : th.joinTime;
            if (data.accurateStartTime) {
                th.accurateStartTime = data.accurateStartTime;
                th.earliestSeek = Math.max(Math.min(JT,data.accurateStartTime), th.streamStart);
            } else {
                if (data.scheduledStartTime) {
                    th.earliestSeek = Math.max(Math.min(JT, data.scheduledStartTime), th.streamStart);
                } else {
                    if (!item.simulcast) {
                        th.earliestSeek = Math.max(th.joinTime, th.streamStart);
                    }
                }
            }
            if (data.accurateEndTime) {
                th.accurateEndTime = data.accurateEndTime;
                th.streamEnd = data.accurateEndTime;
            } else {
                if (data.scheduledEndTime) {
                    th.scheduledEndTime = data.scheduledEndTime;
                    th.streamEnd = Math.max(data.scheduledEndTime, th.latestSeek);
                }
            }
            if (th.inbandEndTime)  {
                th.streamEnd = Math.min(th.streamEnd,th.inbandEndTime);
            }

        }
    }

    var TimeHelper = function(player) {
        var th = this;
        th.player = player;
        th.reset();
        return th;
    };

    TimeHelper.prototype = {
        reset : function() {
            var th = this;
            th.joinTime = NaN;

            th.streamStart = 0;
            th.latestSeek = 0;
            th.latestAllowableSeekTime = 0;

            th.earliestSeek = 0;
            th.streamEnd = 0;

            th.time = th.player.config.startTime;
            th.percent = 0;
            // XXX this is wrong isn't it?
            th.drawSeekBar = false;
            th.duration = NaN;
            th.rewindWindowLength = 0;
            th.dashTimeDelta = 0;

            th.restartedWebcast = false;
            th.startTimeAvailable = false;

            // these should probably be 0 or NaN rather than false?
            th.accurateStartTime = false;
            th.accurateEndTime = false;
            th.scheduledEndTime = false;
            th.availableTime = {};
            th.presentationTimeOffset = 0;
            th.inbandEndTime = null;
            th.forcedTime = null;

            th.playbackTimeouts = [];
        },
        setAvailableTime : function(d) {
            var th = this;
            th.availableTime = d || {};
            th.update(th.player.time, th.player.duration);
        },
        partialReset: function() {
            var th = this;
            var item = th.player.mediaItem;
            th.percent = 0;

            if (item) {
                // if VOD
                if (!item.live) {
                    th.time = th.player.config.startTime;
                    // XXX shouldn't this be the percent relevant to
                    // the startTime.
                    // th.percent = 0;
                } else {
                    th.duration = NaN;
                }
            }
        },
        timeToString: function(t,neverEmpty) {
            var th = this;
            var item = th.player.mediaItem;
            var time = t;
            if (isNaN(time)) {
                time = th.time;
            }

            if (!item || isNaN(time)) {
                return neverEmpty ? "--:--" : "";
            }

            if (item.live) {
                // Simulcast or Webcast
                return Utils.epochToTime(time, th.player.config && th.player.config.isBSTime, neverEmpty, true, true);
            } else {
                // VOD
                return Utils.secondsToTime(time, false, neverEmpty);
            }
        },
        getDurationOrEndString: function() {
            var th = this;
            var item = th.player.mediaItem;

            if (item) {
                if (!item.live && th.duration && !th.player.config.ondemandWebcastData) {
                    return Utils.secondsToTime(th.duration);
                } else {
                    if ((item.live || th.player.config.ondemandWebcastData) && (th.accurateEndTime || (th.scheduledEndTime && th.latestSeek < th.scheduledEndTime))) {
                        return th.timeToString(th.streamEnd);
                    }
                }
            }
            return "";
        },
        getTimeString: function(time) {
            var th = this;
            var item = th.player.mediaItem;
            if (th.time < CONSIDERED_UNIX_TIME && item && item.live) {
                return "";
            }
            return th.timeToString(time);
        },
        getTimeInfoToDisplay: function(time) {
            var th = this;
            var timeObj = {};

            timeObj.duration = th.getDurationOrEndString();
            timeObj.currentTime = th.getTimeString(time);

            return timeObj;
        },
        percentToTimeString: function(percent,neverEmpty) {
            var th = this;
            var time = th.percentToTime(percent);
            return th.timeToString(time,neverEmpty);
        },
        unixTimeToStreamTime: function(time) {
            var th = this;
            var player = th.player;
            var item = th.player.mediaItem;

            if (item && item.live && !item.useFlash) {
                if (!player.isPlayingDash) {
                    // if the start time is not an epoch, leave it as is
                    // XXX this should possibly not be here, but flash
                    // supports currentTime's outside of the epoch as
                    // being within the rewind window 0 indexed
                    if (!th.startTimeAvailable) {
                        return time;
                    }
                    if (time > CONSIDERED_UNIX_TIME) {
                        time = time - item.startTime;
                        if(item.type=="audio") {
                            time = time - TAI_TO_UTC_SHIFT;
                        }
                    }
                } else if (item.type=="audio" && time>CONSIDERED_UNIX_TIME) {
                    time = time - TAI_TO_UTC_SHIFT;
                }

            }
            return time;
        },
        streamTimeToUnixTime: function(time) {
            var th = this;
            var player = th.player;
            var item = th.player.mediaItem;

            if (item && item.live && !item.useFlash) {
                if(!player.isPlayingDash) {
                    // if there's no value for start time return it to NaN
                    if (!th.startTimeAvailable) {
                        return time;
                    }

                    if(time < CONSIDERED_UNIX_TIME) {
                        time = time + item.startTime;
                    }
                }

                if (item.type == 'audio' && time>CONSIDERED_UNIX_TIME) {
                    time = time + TAI_TO_UTC_SHIFT;
                }

            }

            return time;
        },
        timeToPercent: function(time) {
            var th = this;
            var item = th.player.mediaItem;
            var percent;

            if (!item || isNaN(Number(time)) || isNaN(th.duration)) {
                return Infinity;
            }

            if (item.live || th.player.config.ondemandWebcastData) {
                percent = (time - th.earliestSeek) / th.duration;
            } else {
                percent = time / th.duration;
            }
            return clampToPercent(percent);
        },
        percentToTime: function(percent) {
            var th = this;
            var item = th.player.mediaItem;

            if (!item) {
                return 0;
            }

            var time = th.duration * clampToPercent(percent);
            if (item.live || th.player.config.ondemandWebcastData) {
                time = time + th.earliestSeek;
            }
            return time;
        },
        update: function(time, duration) {
            var th = this;
            var player = th.player;
            var item = player.mediaItem;
            var data = player.webcastData;
            var live = item && item.live;

            if (th.forcedTime) {
                time = th.forcedTime;
            }

            // black list HLS live time calculations for old android devices and windows phone
            var hlsLiveVintageAndroid = ( (player.mediaPlayer.currentTime === 0) && live && !player.isPlayingDash);
            var hlsLiveWinPhone = ( live && !player.isPlayingDash && Device.windowsPhone);

            if ( hlsLiveVintageAndroid || hlsLiveWinPhone ) {
                th.time = 0;
                return;
            }

            if (!isNaN(time)) {
                th.time = time;
            }

            if (item && (live || th.player.config.ondemandWebcastData)) {
                if (player.isPlayingDash) {
                    if (player.dashEvents.dashPlayer) {
                        th.earliestSeek = th.streamStart = th.streamTimeToUnixTime(player.dashEvents.dashPlayer.currentStart) + th.presentationTimeOffset + (item.simulcast ? 60 : 0 );
                        // SMPHTML-953
                        th.streamEnd = th.latestSeek = Math.max(th.streamTimeToUnixTime(player.dashEvents.dashPlayer.currentEnd || 0) + th.presentationTimeOffset - 8, isNaN(time) ? 0 : time );

                        if (isNaN(th.joinTime) && !isNaN(th.latestSeek) && time) {
                            th.joinTime = time;
                        }

                        if (th.inbandEndTime) {
                             th.latestSeek = th.streamEnd = th.inbandEndTime;
                        }

                        applyWebcastData(th, item, data);
                        th.checkSnappedAndUpdate(time);
                    }
                } else {
                    if (item.useFlash) {
                        var ti=player.swf.currentTimeInfo;
                        // copy stuff from player.swf.currentTimeInfo
                        if (ti) {
                            th.setStartTimeAvailable(true);
                            // ignore earliest seek as the webcast
                            // nature screws that up.
                            th.earliestSeek = th.streamStart = ti.streamStart;
                            th.streamEnd = ti.streamEnd;
                            th.latestSeek = ti.latestSeek;
                            th.joinTime = ti.joinTime;

                            applyWebcastData(th, item, data);
                            th.checkSnappedAndUpdate(time);

                        }
                    } else {
                        var seekable = player.seekable;
                        if (th.startTimeAvailable && seekable.end != Infinity) {

                            th.earliestSeek = th.streamStart = th.streamTimeToUnixTime(seekable.start + 60);
                            th.streamEnd = th.latestSeek = th.streamTimeToUnixTime(seekable.end);

                            if (isNaN(th.joinTime) && time > CONSIDERED_UNIX_TIME) {
                                th.joinTime = time;
                            }

                            applyWebcastData(th, item, data);
                            th.checkSnappedAndUpdate(time);

                        }
                        // If a HLS client doesn't provide an accurate
                        // rewind window, assume there is not one.
                        if (th.duration == Infinity) {
                            th.duration = 0;
                        }
                    }
                }

            } else {
                // VOD

                // SMPHTML-1340
                duration = th.checkDurationAgainstSeekableEnd(duration,player.seekable);

                th.duration = duration;
                th.streamEnd = th.latestSeek = duration;
                th.percent = clampToPercent(th.time / th.duration);
            }

            var endAvailableTime = th.availableTime.end;
            if (endAvailableTime && endAvailableTime>th.streamStart) {
                th.latestSeek = Math.min(Math.max(endAvailableTime, th.time),th.streamEnd);
            }

            th.latestAllowableSeekTime = Math.min(th.latestSeek, th.streamEnd);

            // Show seek bar if not live or duration over 30 seconds
            var d = th.canSeek();
            if (th.drawSeekBar != d) {
                th.drawSeekBar = d;
                if (item && live) {
                    th.player.delayedDispatch({type:"canPauseChange", canPause: d});
                }
                // need to let UI know there's been a change.
                th.player.ui.checkIfCanDisplaySeekBar();
            }

            for (var i = 0; i < th.playbackTimeouts.length;) {
                var timeout = th.playbackTimeouts[i];
                if (th.time >= timeout.time && (timeout.seekover || time < timeout.time + 0.33)) {
                    var cb = timeout.callback;
                    th.playbackTimeouts.splice(i, 1);
                    cb();
                } else {
                    i++;
                }
            }
        },
        checkDurationAgainstSeekableEnd:function(duration,seekable){
            if ( seekable && duration && (Math.abs(duration-seekable.end) <= 0.1) ) {
                return seekable.end;
            }
            return duration;
        },
        checkSnappedAndUpdate: function (time) {
            var th = this;
            var timeDiff = (th.latestSeek - time);
            var iSnappedValue = 20;

            if (timeDiff < iSnappedValue) {
                if (th.streamEnd == th.latestSeek) {
                    th.streamEnd = time;
                }
                th.latestSeek = time;
            }

            th.rewindWindowLength = th.latestSeek - th.streamStart;
            th.duration = th.streamEnd - th.earliestSeek;
            th.percent = clampToPercent((time - th.earliestSeek) / th.duration);
        },
        getLatestAllowableSeekPercent: function() {
            var th = this;
            var time = th.latestAllowableSeekTime;
            return th.timeToPercent(time);
        },
        checkIfTimeIsAvailable : function(time, sloppy) {
            var th = this;
            if (DEBUG_FULL) { console.log("Check if time is available:" + time+","+th.earliestSeek); }
            var earliestSeekTime = th.earliestSeek - (sloppy ? 2 : 0);

            return Utils.clamp(time,earliestSeekTime,th.latestAllowableSeekTime);

        },
        hasRewindWindow: function() {
            var th = this;
            var item = th.player.mediaItem;
            return (item && item.live && th.rewindWindowLength > 60);
        },
        canSeek: function() {
            var th = this;
            var player = th.player;
            var item = th.player.mediaItem;

            // XX if this changes we need to dispatch an event so plugins
            // can know - should we have a canSeekChange event, or just
            // dispatch durationchange - since duration has changed if
            // this ever changes.

            // SMPHTML-955 if the duration is only over 30seconds because of
            // AST / SST / AET / SET then this should also be FALSE.

            // If 'not live' or 'it is live with a duration over 90
            // seconds and allowed by settings'
            return (
                (item && !item.live) ||
                (item && item.live &&
                    !Device.inaccurateRewindWindow &&
                 (((th.latestSeek - th.earliestSeek) > 90) || ((th.streamEnd - th.earliestSeek) > 90)) &&
                    player.playlist.liveRewind &&
                    player.ui.config.controls.enableLiveRewind &&
                    (!Device.consideredForMobileLiveRewind || player.config.supportLiveRewindOnMobile)
                )
            );
        },
        setStartTimeAvailable: function(available) {
            var th = this;
            if (th.startTimeAvailable!=available) {
                th.startTimeAvailable = available;
                var player = th.player;
                if (DEBUG_FULL) { console.log('now have start time, so testing:'+player.needHlsStartTime); }
                if ( (player.needHlsStartTime && available) || ( player.isUsingGetStartDate && available) ) {
                    player.timeHelper.update(player.time, player.duration);
                    player.needHlsStartTime = false;
                    if (player.waitingForStartTime && th.canSeek()) {
                        if (DEBUG_FULL) { console.log('seeking now'); }
                        player.time = player.waitingForStartTime;
                        player.waitingForStartTime = 0;
                    }
                }
            }
        },
        setPresentationTimeOffset: function(offsetS) {
            var th = this;
            th.presentationTimeOffset = offsetS || 0;
        },
        setInbandEndTime: function(inbandEndTime) {
            var th = this;
            th.inbandEndTime = inbandEndTime + th.presentationTimeOffset;
        },
        /*
         * Attach a callback to fire at a playback time.
         * The first timeupdate with time greater than playbackTime will fire callback once only.
         * If seekover is set to true, any timeupdate greater than playbackTime will fire, otherwise the timeupdate must naturally play over playbackTime.
         */
        setPlaybackTimeout: function(callback, playbackTime, seekover) {
            var th = this;
            var timeout = {
                callback: callback,
                time: playbackTime,
                seekover: !!seekover
            };
            var id = -1;

            if (typeof timeout.callback === 'function' && !isNaN(timeout.time)) {
                id = th.playbackTimeouts.length > 0 ? th.playbackTimeouts[th.playbackTimeouts.length - 1].id + 1 : 1;
                timeout.id = id;
                th.playbackTimeouts.push(timeout);
            } else {
                if (DEBUG_FULL) {
                    console.log("Rejecting setPlaybackTimeout, one of the parameters isn't valid.");
                }
            }

            return id;
        },
        clearPlaybackTimeout: function(id) {
            var th = this;
            th.playbackTimeouts = th.playbackTimeouts.filter(function (a) { return a.id != id; });
        },
        secondsToHMS: function(inputSeconds) {

            var HMS = inputSeconds < 0 ? '-' : '';

            inputSeconds = Math.abs(inputSeconds);

            var hours = Math.floor(inputSeconds / 3600);

            inputSeconds %= 3600;

            var mins = Math.floor(inputSeconds / 60);

            var seconds = Math.round(inputSeconds % 60);

            HMS += hours ? hours + ':' + Utils.padZeros(mins,2) + ':' + Utils.padZeros(seconds,2) : Utils.padZeros(mins,2) + ':' + Utils.padZeros(seconds,2);

            return HMS;

        }
    };

    return TimeHelper;
})();
var Quality = (function(){
    
    var Quality = function (qualityStr) {
        var quality = this;
        
        if (qualityStr) {
            quality.name = qualityStr.toLowerCase();
        }

        return quality;
    };

    Quality.prototype = {
        getVideoRatio: function() {
            var quality = this;
            var ratio;

            switch(quality.name) {
                case "hd":
                case "high":
                    ratio = 1;
                    break;
                case "medium":
                    ratio = 0.65;
                    break;
                case "low":
                    ratio = 0.2;
                    break;
                default:
                    ratio = 0.65;
                    break;
            }

            return ratio;
        },
        getAudioRatio: function() {
            return 1;
        }
    };

    return Quality;
})();
/** @scope _global_ */
/**
 * Various Device based things.
 *
 */
var Device = (function() {

    var Device = {
        requiresFakeEndedEvent: false,
        requiresFakePlayEvent: false,
        requiresRestartAdjustmentAtEnd: false,
        supportsVideoDash: false,
        supportsAudioDash: false,
        needToLoadSVG: true,
        supportsHls: false,
        useFakeFullscreen:false,
        windowsPhone: false,
        android: false,
        ios: false,
        ipad: false,
        iphone: false,
        blackBerry:false,

        init : function(ua, hls) {
            var hasMseSupport = window.MediaSource ? true : false;
            ua = ua.toLowerCase();

            Device.windowsPhone = (/windows phone/).test(ua);
            Device.android = (/android/).test(ua) && !Device.windowsPhone;
            Device.ios = (/(ipod|ipad|iphone)/).test(ua) && !Device.windowsPhone;
            Device.iphone = (/iphone|ipod/).test(ua) && !Device.windowsPhone;
            Device.ipad = (/ipad/).test(ua);
            Device.playbook = (/playbook/).test(ua);
            Device.blackBerry = ( /blackberry/.test(ua) || Device.playbook || /bb10/.test(ua) );
            Device.macSafari = /safari/.test(ua) && /mac/.test(ua) && !/chrome/.test(ua) && !Device.windowsPhone;
            Device.firefox = /firefox/.test(ua);
            Device.kindle = /silk/.test(ua);
            Device.trident = /trident/.test(ua);
            Device.edge = / edge\//.test(ua);
            Device.snowLeopard = Device.macSafari && (/os x 10_6/).test(ua); // Mac OSX Snow Leopard and Safari
            Device.windowsWebview = Device.edge && (/webview/).test(ua);
            Device.windows10Arm = (/windows nt 10\.[0-9]; arm/).test(ua);
            var probablyXP = (/windows nt 5\./).test(ua);
            Device.windowsXpFirefox = Device.firefox && probablyXP;
            Device.windowsXpChrome = window.chrome && probablyXP;

            Device.preWindows10IE11 = Device.trident && (/ nt 6./).test(ua);
            Device.opera = /opr/.test(ua);

            Device.samsung = /samsungbrowser/.test(ua);

            if (Device.firefox) {
                var v = ua.match(/firefox\/([0-9]+)/);
                var firefoxVersion = (!v ? 0 : parseInt(v[1],10));
            }

            // Calculate iOS iosVersion number
            if (Device.ios) {
                v = ua.match(/os ([0-9]+)\_([0-9]+)/);
                var iosMajorVersion = (!v ? 0 : parseInt(v[1],10));
                var iosMinorVersion = (!v ? 0 : parseInt(v[2], 10));
            }

            // Calculate macOS version number
            if (Device.macSafari) {
                v = ua.match(/os x ([0-9]+)\_([0-9]+)/);
                if (v && v.length >= 3) {
                    var macOsMajorVersion = parseInt(v[1],10);
                    var macOsMinorVersion = parseInt(v[2],10);
                }
            }

            Device.safariPreSierra = Device.macSafari && (macOsMajorVersion < 10 || (macOsMajorVersion === 10 && macOsMinorVersion < 12));
            
            // iOS < 7 - Hiding the cursor causes a mousemove event
            // which fires showControlBar causing pulsating
            Device.hideCursorInFullscreen = !Device.ios || iosMajorVersion >= 7 ;

            var androidVersion;
            var chromeNum = 0;
            var hasAndroidBrowser = false;
            if (Device.android) {

                v = (ua.match(/android (\d+(?:[\.\d]*)+)/i));
                androidVersion = !v ? 99 :  parseFloat(v[1])*10;
                if(androidVersion && androidVersion < 42) {
                    hasAndroidBrowser = true;
                }

                var chromeVersion = ua.match(/chrome\/([0-9]+)/);
                if (chromeVersion) {
                    chromeNum = parseInt(chromeVersion[1],10);
                    if (chromeNum < 35) {
                        Device.useFakeFullscreen=true;
                    }
                }
            }

            Device.useStartDateInHls = (iosMajorVersion >= 10);

            Device.iPhoneIos10 = Device.iphone && iosMajorVersion == 10;
            Device.iPhoneIos11orGreater = Device.iphone && iosMajorVersion >= 11;

            Device.iPhoneOutOfPagePlayback =   Device.iphone && iosMajorVersion < 10;
            Device.inaccurateRewindWindow =  Device.ios && iosMajorVersion < 7;
            Device.allowFakeFullscreenScroll = Device.ios && (iosMajorVersion === 11 && iosMinorVersion < 3) || iosMajorVersion < 11;
            Device.cannotDetectAutoplayFailure =  Device.ios && iosMajorVersion < 8;

            Device.iosRequiresFakePlayingEventAfterSeeked = Device.ios && iosMajorVersion == 12;

            // iPhone 5 and iPhone SE
            Device.iPhoneNeedFullScreenMarginButton = ( Device.iphone && (screen.width === 320) && (screen.height === 568) );

            Device.loadStartUnreliableAudio = Device.ios && iosMajorVersion >= 6;
            Device.requiresRestartAdjustmentAtEnd = Device.iPad;
            Device.requiresFakePlayEvent = hasAndroidBrowser || Device.kindle || Device.blackBerry;
            Device.requiresFakeEndedEvent = Device.macSafari || hasAndroidBrowser;
            Device.requiresFakePlayingEventAfterSeekedWhenDash = Device.trident;

            Device.supportsAutoplay = !Device.ios && !Device.windowsPhone && !Device.android && !Device.blackBerry; 

            Device.fallbackAfterDashDecodeError = Device.supportsAutoplay && (/palemoon/).test(ua);

            Device.possiblyPreferPlainOverDash = !Device.supportsAutoplay && !((firefoxVersion > 63 && androidVersion >= 8) || (chromeNum>55 && androidVersion>=6));

            Device.notWorthTryingAutoplay = !Device.supportsAutoplay || Device.macSafari;

            Device.supportsMultipleMediaElements = Device.supportsAutoplay;
            Device.consideredForMobileLiveRewind = !Device.supportsAutoplay;

            Device.supportsVideoDash = hasMseSupport && !Device.safariPreSierra && !Device.windowsXpFirefox && !Device.preWindows10IE11 && !Device.windowsXpChrome;
            Device.supportsAudioDash = hasMseSupport;
            Device.supportsHls = hls || Device.edge || Device.windows10Arm || Device.macSafari;
            Device.preferHls = Device.ios || (Device.blackBerry && !Device.playbook) || Device.windowsWebview;

            Device.requiresDashAVC3CodecHack = Device.trident || Device.windowsWebview;
            Device.noSupportForLocationHeader = Device.trident;

            Device.requiresFullscreenResizeDelay = !Device.supportsAutoplay || !(Device.Edge || window.chrome || Device.macSafari || Device.firefox);
            Device.requiresShortFullscreenResizeDelay = Device.trident;

            // Or something else ?  are there any which don't support
            // flash playback which do support dash??  adding in the
            // iOS as an extra validation on blocking flash messages
            Device.supportPlayerFallback = !Device.ios;

            /* need desktop edge here too, but how do we get that, not important for now, as that will be flash for now? */
            Device.preferVideoFallbackOverHLS = Device.kindle || Device.android || (!Device.supportsHls && !Device.macSafari);

            Device.flashLockMatters = !(Device.kindle || Device.android);

            // dash.js 759
            Device.requiresManualDashPlay = Device.firefox;

            Device.requiresPageFullScreenStyles = Device.edge;

            Device.disallowHighResIcons = false;

            Device.animationCompensationSupported = !Device.ios && !Device.edge && !Device.macSafari;
            Device.scrubAnimation = !(Device.firefox && firefoxVersion<52) && !Device.samsung && !(androidVersion && androidVersion < 44) && !Device.trident;

            Device.canTabbing = !Device.ios;

            Device.webgl = (function () {
                try {
                    var canvas = document.createElement('canvas');
                    var supports = 'probablySupportsContext' in canvas ? 'probablySupportsContext' :  'supportsContext';
                    if (supports in canvas) {
                        return canvas[supports]('webgl') || canvas[supports]('experimental-webgl');
                    }
                    return 'WebGLRenderingContext' in window;
                } catch (e) {
                    return false;
                }
            })();

            if (DEBUG_FULL) {
                console.log("Device init: iosMajorVersion: "+iosMajorVersion+", androidVersion:"+androidVersion);
                console.log("loadStartUnreliableAudio: "+Device.loadStartUnreliableAudio);
                console.log("requiresRestartAdjustmentAtEnd: "+Device.requiresRestartAdjustmentAtEnd);
                console.log("windowsPhone: "+Device.windowsPhone);
                console.log("androidPhone: "+Device.android);
                console.log("HLS supports/prefer/filter: "+Device.supportsHls+"/"+Device.preferHls);
                console.log("SupportsAutoPlay: "+Device.supportsAutoplay);
            }
        },

        requestFullscreen : function(e) {
            if (e.requestFullscreen) {
                e.requestFullscreen();
            } else {
                if (e.webkitRequestFullscreen) {
                    e.webkitRequestFullscreen();
                } else {
                    if (e.msRequestFullscreen) {
                        e.msRequestFullscreen();
                    } else {
                        if (e.mozRequestFullScreen) {
                            e.mozRequestFullScreen();
                        }
                    }
                }
            }
        },

        exitFullscreen : function(e) {
            if (e.exitFullscreen) {
                e.exitFullscreen();
            } else {
                if (e.webkitExitFullscreen) {
                    e.webkitExitFullscreen();
                } else {
                    if (e.msExitFullscreen) {
                        e.msExitFullscreen();
                    } else {
                        if (e.mozCancelFullScreen) {
                            e.mozCancelFullScreen();
                        }
                    }
                }
            }
        },

        fullscreenEnabled : function(doc) {
            if (!doc || Device.useFakeFullscreen) {
                return false;
            }
            return doc.fullscreenEnabled || doc.webkitFullscreenEnabled || doc.msFullscreenEnabled || doc.mozFullScreenEnabled;
        },

        bindToFullscreenChange : function(doc, func) {
            Utils.multiAddEventListener(doc, 'fullscreenchange webkitfullscreenchange MSFullscreenChange mozfullscreenchange', func);
        },

        isBrowserFullscreen : function (e) {
            var doc = e.target;
            if (!doc) {
                return false;
            }

            var docDocument = doc.contentDocument || doc.ownerDocument;

            if (docDocument) {
                if ( docDocument.fullscreenElement || docDocument.msFullscreenElement || docDocument.webkitIsFullScreen || docDocument.mozFullScreen) {
                    return true;
                }
            } else {
                // IE 11
                if (doc.msFullscreenElement) {
                    return true;
                }
            }

            return doc.webkitIsFullScreen || doc.mozFullScreen;
        },

        loadSVGForHighResIcon : function(ui) {
            // XXX this was in device because it was only going to be
            // conditional on where, it may be that it works fine
            // everywhere at this route and this can remain, but if
            // not then we should just do it where appropriate and
            // have generateSVG include the path where necessary.
            if (Device.needToLoadSVG) {
                var error = function() {
                    if (DEBUG_FULL) {
                        console.log("Loading SVG failed");
                    }
                    // this will probably fail as it's not a
                    // feature we can currently change at run time,
                    // should we?
                    if (ui) {
                        ui.config.useHighResIcons = false;
                    }
                    Utils.className(document.body,"","svg");
                };

                Device.needToLoadSVG = false;
                var url = "/emp/assets/2.0.23/svgicons.svg";
                Utils.getXML(url, function(doc) {
                  if (doc && doc.documentElement) {
                    if (DEBUG_FULL) {
                        console.log("Loading SVG succeeded, adding");
                    }
                    document.body.appendChild(document.importNode(doc.documentElement,true));
                  } else {
                      error();
                  }
                }, error, {}, true);
                if (DEBUG_FULL) {
                    console.log("Loading SVG:" + url);
                }
            }
        }
    };

    return Device;
})();
/**
 * Thumbnail Scrubbing
 */

var ThumbnailScrub = (function() {

    var iso8601re = new RegExp('([+-]?)P(?:(\\d+)Y)?(?:(\\d+)M)?(?:(\\d+)D)?(?:T(?:(\\d+)H)?(?:(\\d+)M)?(?:(\\d+(?:\\.\\d+)?)S)?)?','i');

    var requestMap = {};

    function iso8601DurationToSeconds(iso8601Duration) {
        var matches = iso8601re.exec(iso8601Duration);
        if (matches) {
            var years = parseInt("0"+matches[2],10);
            var months = parseInt("0"+matches[3],10);
            var days = parseInt("0"+matches[4],10);
            var hours = parseInt("0"+matches[5],10);
            var minutes = parseInt("0"+matches[6],10);
            var seconds = parseFloat("0"+matches[7]);

            return seconds +
                   (minutes * 60) +
                   (hours * 60 * 60) +
                   (days * 24 * 60 * 60) +
                   (months * 30 * 24 * 60 * 60) +
                   (years * 365 * 24 * 60 * 60);
        }
        return null;
    }


    function createStoryBoardUrl(url, number) {
        return url.replace('$Number%04d$', ("0000"+number).slice(-4));
    }


    function parseBaseUrl(url) {
        var base = '';

        if (url.indexOf('/') !== -1) {
            if (url.indexOf('?') !== -1) {
                url = url.substring(0, url.indexOf('?'));
            }
            base = url.substring(0, url.lastIndexOf('/') + 1);
        }

        return base;
    }


    function extractThumbData(duration, thumbSets, thumbManifestHref) {

        var thumbSet,
            width,
            height,
            media,
            representation,
            url,
            size,
            thumbData = {},
            sizeData = {},
            i,
            l,
            baseUrl = parseBaseUrl(thumbManifestHref);

        for (i = 0, l = thumbSets.length; i < l; i++) {

            sizeData = {};

            thumbSet = thumbSets[i];

            width = thumbSet.Representation.width;
            height = thumbSet.Representation.height;

            media = thumbSet.SegmentTemplate.media;
            representation = thumbSet.Representation.id;

            size = width + 'x' + height;
            url = baseUrl + media.replace('$RepresentationID$', representation);

            sizeData.storyboardUrlTemplate = url;

            sizeData.numberRows = thumbSet.Representation.EssentialProperty_asArray[0].value;

            sizeData.numberColumns = thumbSet.Representation.EssentialProperty_asArray[1].value;

            sizeData.thumbsPerBoard = sizeData.numberRows * sizeData.numberColumns;

            sizeData.maxNumBoards = 40;

            sizeData.thumbInterval = thumbSet.SegmentTemplate.timescale / 1000;

            sizeData.totalNumberThumbs = Math.floor(duration / sizeData.thumbInterval);

            sizeData.lastBoard =  Math.ceil(sizeData.totalNumberThumbs / sizeData.thumbsPerBoard)-1;

            thumbData[size] = sizeData;
        }

        return thumbData;

    }

    var preloadedUrls = {};
    function preloadImageUrl(thumbData,boardNo) {
        var url = createStoryBoardUrl(thumbData.storyboardUrlTemplate, boardNo);
        if (!preloadedUrls[url]) {
            preloadedUrls[url] = true;
            var img = new Image();
            img.src = url;
        }
    }

    /*
     * Constructor for ThumbnailScrub class
     */
    var ThumbnailScrub = function(player) {

        this.player = player;

    };

    ThumbnailScrub.prototype = {


        updateOverrideManifest : function( url ) {
            this.overrideManifestHref = url;
            this.extractManifestData();
        },
        newMediaItem : function(mi) {
            this.overrideManifestHref = null;
            this.connectionIndex = 0;
            this.reset();
            this.mediaItem = mi;
        },

        extractManifestData: function() {
            var manifestHref = this.overrideManifestHref;
            if (this.mediaItem) {
                if (!manifestHref) {
                    manifestHref = this.mediaItem.thumbManifestHref;
                }
                if (!manifestHref) {
                    var connections = this.mediaItem.thumbnailConnections;
                    if (connections[this.connectionIndex]) {
                        manifestHref = connections[this.connectionIndex].href;
                    }
                }
            }
            if (this.manifestHref!=manifestHref) {
                if (manifestHref) {
                    this._init(manifestHref);
                } else {
                    // in case there was an override and it's now been removed
                    this.reset();
                }
            }
        },

        /*
         * Function to be called by UI to give all the information needed to render a thumbnail for a point in time.
         * @param {int} time - The current time of playback in seconds
         * @return {Object} - {
         *     {string} storyBoardUrl - The url of the storyboard containing the thumbnail
         *     {int} x - The number of pixels from the left
         *     {int} y - The number of pixels from the top
         * }
         *
         */
        getThumbnailData: function(time, width, height) {

            var thumbSizeData,
                thumbNumber,
                storyBoardNumber,
                storyBoardThumbNumber,
                storyBoardRow,
                storyBoardColumn,
                storyBoardUrl,
                thumbnailData,
                size;

            size = width + 'x' + height;

            thumbSizeData = this.thumbData[size];

            // XXX should just get a different size or something the
            // size should be the prefferred size from the UI and this
            // should provide the closest it can manage for now return
            // null the same as if there are no thumbnails available

            if (!thumbSizeData) {
                return;
            }

            thumbNumber = Math.min(thumbSizeData.totalNumberThumbs - 2, Math.max(0, Math.ceil(time / thumbSizeData.thumbInterval) - 1));
            
            storyBoardNumber = Math.floor(thumbNumber / thumbSizeData.thumbsPerBoard);

            preloadImageUrl(thumbSizeData,storyBoardNumber);

            // if there's more than 1 board, get surrounding boards
            if (storyBoardNumber > 0) {
                preloadImageUrl(thumbSizeData,storyBoardNumber-1);
            }

            if (storyBoardNumber < thumbSizeData.lastBoard) {
                preloadImageUrl(thumbSizeData,storyBoardNumber+1);
            }

            storyBoardThumbNumber = thumbNumber % thumbSizeData.thumbsPerBoard;

            storyBoardColumn = storyBoardThumbNumber % thumbSizeData.numberColumns;

            storyBoardRow = Math.floor(storyBoardThumbNumber / thumbSizeData.numberColumns);

            storyBoardUrl = createStoryBoardUrl(thumbSizeData.storyboardUrlTemplate, storyBoardNumber);

            thumbnailData = {
                storyBoardUrl: storyBoardUrl,
                x: -1 * storyBoardColumn * width,
                y: -1 * storyBoardRow * height
            };

            return thumbnailData;
        },
        reset: function() {
            this.manifestHref = null;
            this.thumbData = {};
            this.loaded = false;
            // XXX this feels a bit yucky
            if (this.player.ui && this.player.ui.controls) {
                Utils.className(this.player.ui.controls, '', 'p_hasThumbnails');
            }
        },
        _init: function(thumbManifestHref) {

            var thumbScrub = this;

            thumbScrub.manifestHref = thumbManifestHref;

            thumbScrub.thumbData = {};
            thumbScrub.loaded = false;


            if (!thumbManifestHref) {
                return;
            }
            requestMap[thumbManifestHref] = {};
            var error = function() {
                Utils.callErrorFunction(thumbScrub.player, SMPError.THUMBNAIL_FAILOVER, thumbScrub.manifestHref, true);
                // XXX this should actually only increase if it was
                // requesting the current one, but the case is pretty
                // extreme, as if the others are set you wouldn't try
                // a second, so it can be done any time unless an
                // overridden thumb manifest is removed and therefore
                // it needs to go back to the MS ones. No current
                // users and rather extreme use case
                thumbScrub.connectionIndex++;
                thumbScrub.extractManifestData();
            };

            var cb = function(xmldoc) {

                var x2js, jsonData = {};

                thumbScrub.manifestXml = xmldoc;

                try {
                    x2js = new X2JS([], '', false);  //jshint ignore:line
                    jsonData = x2js.xml2json(xmldoc);
                    thumbScrub.manifestJSON = jsonData;
                } catch(e) {
                    error();
                    return;
                }

                if (!jsonData || !jsonData.MPD || !jsonData.MPD.Period) {
                    error();
                    return;
                }

                thumbScrub.duration = iso8601DurationToSeconds(jsonData.MPD.Period.duration);

                thumbScrub.thumbData = extractThumbData(thumbScrub.duration, jsonData.MPD.Period.AdaptationSet_asArray, thumbManifestHref);

                if (thumbScrub.player.ui && thumbScrub.player.ui.controls) {
                    Utils.className(thumbScrub.player.ui.controls, 'p_hasThumbnails');
                }

                thumbScrub.loaded = true;

                if (DEBUG_FULL) {
                    console.log('[Thumbnail Scrub] Duration: ', thumbScrub.duration);
                    console.log('[Thumbnail Scrub] Thumb Data: ', thumbScrub.thumbData);
                }

            };

            Utils.getXML(thumbManifestHref, cb, error, requestMap[thumbManifestHref]);

        }
    };

    return ThumbnailScrub;


})();
var TTMLParser = (function() {

    var SECONDS_IN_HOUR = 60 * 60; // Expression of an hour in seconds
    var SECONDS_IN_MIN = 60; // Expression of a minute in seconds

    // These height/width values are used to set the output size for the properties that depend
    // on the height/width, i.e. font-size, line-height and paragraph-padding.
    // It is irrelevant what this value is set to for values with relative units(%, c), however,
    // for absolute(pixel) values, this is the resolution at which the original size is preserved,
    // for example, the size of video that a 16px font will render at 16px. For this, the height-
    // width must be specified on the <tt> element as an extent, but if it isn't, this default
    // should provide reasonable (if big) scaling.
    var videoHeight = 360;
    var videoWidth = 640;

    /*
     * This TTML parser follows "EBU-TT-D SUBTITLING DISTRIBUTION FORMAT - tech3380" spec - https://tech.ebu.ch/docs/tech/tech3380.pdf.
     * */
    var instance,
        timingRegex,
        ttml,
        // contains the whole ttml document received
    ttmlStyling,
        // contains the styling information from the document (from head following EBU-TT-D)
    ttmlLayout,
        // contains the positioning information from the document (from head following EBU-TT-D)
    fontSize,
        lineHeight,
        linePadding,
        padding,
        defaultLayoutProperties,
        defaultStyleProperties,
        fontFamilies,
        fontClasses,
        fontBlocked,
        textAlign,
        multiRowAlign,
        wrapOption,
        unicodeBidi,
        displayAlign,
        supportsBoxDecorationBreak,
        writingMode;

    /**
     * Parse the raw data and process it to return the HTML element representing the cue.
     * Return the region to be processed and controlled (hide/show) by the caption controller.
     * @param data: raw data received from the TextSourceBuffer
     **/

    function parse(data) {
        var converter = new X2JS([], '', false); //jshint ignore:line
        //xml2json library is ignored for jshint; so jshint doesn't know that this exists.
        
        // Parse the TTML in a JSON object.
        ttml = converter.xml2json(data);

        if (!ttml) {
            throw 'TTML document could not be parsed';
        }

        var type = 'html';
        
        var ebuNamespace = getNamespacePrefix(ttml, 'http://www.w3.org/ns/ttml');
        // Get the namespace if there is one defined in the JSON object.
        var ttNS = ebuNamespace || getNamespacePrefix(ttml, 'http://www.w3.org/2006/10/ttaf1');

        // Remove the namespace before each node if it exists:
        if (ttNS) {
            removeNamespacePrefix(ttml, ttNS);
        }

        // Check the document and compare to the specification (TTML and EBU-TT-D).
        var tt = ttml.tt;
        if (!tt) {
            throw 'TTML document lacks tt element';
        }

        var head = tt.head;
        if (!head) {
            head={};
            if (DEBUG_FULL) {
                console.log("TTML document lacks head element");
            }
        }
        if (head.layout) {
            ttmlLayout = head.layout.region_asArray; //Mandatory in EBU-TT-D
        }
        if (head.styling) {
            ttmlStyling = head.styling.style_asArray; // Mandatory in EBU-TT-D
        }
        var body = tt.body;
        if (!body) {
            throw 'TTML document lacks body element';
        }

        var nstts = getNamespacePrefix(ttml.tt, 'http://www.w3.org/ns/ttml#styling') || getNamespacePrefix(ttml.tt, 'http://www.w3.org/2006/10/ttaf1#styling');
        if (tt.hasOwnProperty(nstts + ':extent')) {
            var arr = tt[nstts + ':extent'].split('px');
            if (arr.length == 3) {
                videoWidth = parseInt(arr[0], 10);
                videoHeight = parseInt(arr[1], 10);
            }
        }

        // Extract the cellResolution information
        var cellResolution = getCellResolution();

        // Compute the CellResolution unit in order to process properties using sizing (fontSize, linePadding, etc).
        var cellUnit = [videoWidth / cellResolution[0], videoHeight / cellResolution[1]];
        defaultStyleProperties['font-size'] = parseFontSize(cellUnit[1] + 'px;', cellUnit);

        var regions = [];
        if (ttmlLayout) {
            for (var i = 0; i < ttmlLayout.length; i++) {
                regions.push(processRegion(Utils.clone(ttmlLayout[i]), cellUnit));
            }
        }

        // Get the namespace prefix.
        var nsttp = getNamespacePrefix(ttml.tt, 'http://www.w3.org/ns/ttml#parameter') || getNamespacePrefix(ttml.tt, 'http://www.w3.org/2006/10/ttaf1#parameter');

        // Set the framerate.
        if (ttml.tt.hasOwnProperty(nsttp + ':frameRate')) {
            ttml.tt.frameRate = parseInt(ttml.tt[nsttp + ':frameRate'], 10);
        }
        var captionArray = [];
        // Extract the div
        var divs = ttml.tt.body_asArray[0].__children;

        function parseDiv(div) {
            if (div.div) {
                var cues = div.div.p_asArray;
                if (!cues) { cues = []; }

                //Iron out second level divs to the top level. This is not EBU-TT-D, but is in live subtitles format.
                var childDivs = div.div.div_asArray;
                if (childDivs && childDivs.length) {
                    for (var i = 0; i < childDivs.length; i++) {
                        var paras = childDivs[i].p_asArray;
                        var parentTime = getTimesFromElement(childDivs[i]);
                        if (paras) {
                            for (var j = 0; j < paras.length; j++) {
                                cues.push(paras[j]);
                                if (parentTime.begin || parentTime.end) {
                                    paras[j].parentTime = parentTime;
                                }
                            }
                        }
                    }
                }
            }

            /*** Parsing of every cue.
             *
             * cues: List of the cues found in the ttml parsing.
             *       We iterate on this list.
             * cue: Every cue is parsed individually and creates an HTML element with its style and children.
             *
             * pElements: all the nodes that can be found in the paragraph.
             *
             * ***/

            // Caption array is the final result return containing all the cues' information.
            if (!cues) { cues = []; }
            cues.forEach(function (cue) {
                var pTime;
                var spanTime;

                // Obtain the start and end time of the cue.
                pTime = getTimesFromElement(cue);
                spanTime = getTimesFromElement(cue.span);

                // NARRATIVE SUBS WIP
                var isForcedDisplay = getForcedDisplayFromElement(cue);

                var mergedTime = mergeTimes(cue.parentTime, pTime);
                mergedTime = mergeTimes(mergedTime, spanTime);

                if (isNaN(mergedTime.begin) && isNaN(mergedTime.end)) {
                    if (DEBUG_FULL) {
                        console.log('Subtitle rejected (Begin or end time missing): ' + (cue.hasOwnProperty('id') ? cue.id : 'No id'));
                    }
                    return;
                }

                if (cue['smpte:backgroundImage'] !== undefined) {
                    var images = ttml.tt.head.metadata.image_asArray;
                    for (var j = 0; j < images.length; j++) {
                        if ('#' + images[j]['xml:id'] == cue['smpte:backgroundImage']) {
                            captionArray.push({
                                start: mergedTime.begin,
                                end: mergedTime.end,
                                id: images[j]['xml:id'],
                                data: 'data:image/' + images[j].imagetype.toLowerCase() + ';base64, ' + images[j].__text,
                                type: 'image'
                            });
                        }
                    }
                } else if (type === 'html') {
                    lineHeight = {};
                    linePadding = {};
                    fontSize = {};
                    padding = {};
                    var cueID = '';
                    if (cue.hasOwnProperty('id') || cue.hasOwnProperty('xml:id')) {
                        cueID = cue['xml:id'] || cue.id;
                    }

                    /**
                     * Find the region defined for the cue.
                     */
                    // properties to be put in the "captionRegion" HTML element.
                    var cueRegionProperties = constructCueRegion(cue, div.div, cellUnit);
                    var isRegioned = cueRegionProperties && cueRegionProperties.length > 0;
                    applyDefaultProperties(cueRegionProperties, defaultLayoutProperties);

                    /**
                     * Find the style defined for the cue.
                     */
                    // properties to be put in the "paragraph" HTML element.
                    var cueStyleProperties = constructCueStyle(cue, cellUnit);

                    // Final cue HTML element.
                    var cueParagraph = document.createElement('div');
                    cueParagraph.className = 'p_paragraph';

                    // Stock the element in the subtitle (in p) in an array (in case there are only one value).
                    var pElements = cue.__children;

                    // Create an wrapper containing the cue information about unicodeBidi and direction
                    // as they need to be defined on at this level.
                    // We append to the wrapper the cue itself.
                    var cueDirUniWrapper = constructCue(pElements, cellUnit,  !!ebuNamespace);
                    cueDirUniWrapper.className = 'p_cueDirUniWrapper';

                    //Check for no text and discard if none.
                    var anythingButWhitespace = /[^\s]/;
                    if(! anythingButWhitespace.test(cueDirUniWrapper.textContent))
                    {
                        return;
                    }

                    // If the style defines these two properties, we place them in cueContainer
                    // and delete them from the cue style so it is not added afterwards to the final cue.
                    if (arrayContains('unicode-bidi', cueStyleProperties)) {
                        cueDirUniWrapper.style.cssText += getPropertyFromArray('unicode-bidi', cueStyleProperties);
                        deletePropertyFromArray('unicode-bidi', cueStyleProperties);
                    }
                    if (arrayContains('direction', cueStyleProperties)) {
                        cueDirUniWrapper.style.cssText += getPropertyFromArray('direction', cueStyleProperties);
                        deletePropertyFromArray('direction', cueStyleProperties);
                    }

                    // Apply the linePadding property if it is specified in the cue style.
                    if (arrayContains('padding-left', cueStyleProperties) || arrayContains('padding-right', cueStyleProperties)) {
                        applyLinePadding(cueDirUniWrapper, getValueFromArray('padding-left', cueStyleProperties),
                            getValueFromArray('padding-right', cueStyleProperties));
                    } else {
                        //If doesn't contain any padding, set defaults and apply.
                        //Set default to 0.5c
                        cueStyleProperties.push('padding-left:' + cellUnit[0] * 0.5 + 'px;');
                        cueStyleProperties.push('padding-right:' + cellUnit[0] * 0.5 + 'px;');
                        applyLinePadding(cueDirUniWrapper, getValueFromArray('padding-left', cueStyleProperties),
                            getValueFromArray('padding-right', cueStyleProperties));
                    }
                    padding.left = getValueFromArray('padding-left', cueStyleProperties);
                    padding.right = getValueFromArray('padding-right', cueStyleProperties);

                    if (!isRegioned)
                    {
                        deletePropertyFromArray('text-align', cueStyleProperties);
                        deletePropertyFromArray('justify-content', cueStyleProperties);

                        cueRegionProperties.push(textAlign.center[0]);
                        cueStyleProperties.push(textAlign.center[1]);
                    }
                    else if (arrayContains('justify-content', cueStyleProperties)) {
                         cueRegionProperties.push(getPropertyFromArray('justify-content', cueStyleProperties));
                    }

                    if (arrayContains('multi-row-align', cueStyleProperties)) {
                        var mra = getValueFromArray('multi-row-align', cueStyleProperties);
                        if (arrayContains('text-align', cueStyleProperties) && multiRowAlign[mra] != 'auto') {
                            deletePropertyFromArray('text-align', cueStyleProperties);
                        }
                        if (mra in multiRowAlign) {
                            cueStyleProperties.push(multiRowAlign[mra]);
                            deletePropertyFromArray('multi-row-align', cueStyleProperties);
                        }
                    }

                    /**
                     * Clean and set the style and region for the cue to be returned.
                     */

                    // Remove the line padding property from being added at the "paragraph" element level.
                    if (arrayContains('padding-left', cueStyleProperties) && arrayContains('padding-right', cueStyleProperties)) {
                        deletePropertyFromArray('padding-left', cueStyleProperties);
                        deletePropertyFromArray('padding-right', cueStyleProperties);
                    }

                    // Remove the ID of the region from being added at the "paragraph" element level.
                    var regionID = '';
                    if (arrayContains('regionID', cueRegionProperties)) {
                        var wholeRegionID = getPropertyFromArray('regionID', cueRegionProperties);
                        regionID = wholeRegionID.slice(wholeRegionID.indexOf(':') + 1, wholeRegionID.length - 1);
                    }

                    //Transfer flex-box attributes for implementation by the presenter.
                    var flexBoxAttr = [];
                    swapInArrays('justify-content', cueRegionProperties, flexBoxAttr);
                    swapInArrays('align-items', cueRegionProperties, flexBoxAttr);

                    // We link the p style to the finale cueParagraph element.
                    if (cueStyleProperties) {
                        Utils.className(cueParagraph, getClasses(cueStyleProperties));
                        var css = cueStyleProperties.join(' ');
                        cueParagraph.style.cssText = css;
                    }

                    // We then place the cue wrapper inside the paragraph element.
                    cueParagraph.appendChild(cueDirUniWrapper);

                    // Final cue.
                    var finalCue = document.createElement('div');
                    finalCue.appendChild(cueParagraph);
                    finalCue.id = 'subtitle_' + cueID;

                    // We define the CSS style for the cue region.
                    if (cueRegionProperties) {
                        Utils.className(finalCue, getClasses(cueRegionProperties));
                        cueRegionProperties = cueRegionProperties.join(' ');
                    }
                    finalCue.style.cssText = 'position: absolute; margin: 0; box-sizing: border-box; pointer-events: none;' + cueRegionProperties;

                    if (Object.keys(fontSize).length === 0) {
                        fontSize.defaultFontSize = cellUnit[1] / 16 + 'em';
                    }

                    applyBackgroundColorDefaults(cueParagraph);


                    // We add all the cue information in captionArray.
                    captionArray.push({
                        start: mergedTime.begin,
                        end: mergedTime.end,
                        type: 'html',
                        cueHTMLElement: finalCue,
                        regions: regions,
                        regionID: regionID,
                        cueID: cueID,
                        videoHeight: videoHeight,
                        videoWidth: videoWidth,
                        cellResolution: cellResolution,
                        fontSize: fontSize || cellUnit[1] / 16 + 'em',
                        lineHeight: lineHeight,
                        linePadding: linePadding,
                        padding: padding,
                        flexBoxAttr: flexBoxAttr,

                        // NARRATIVE SUBS WIP
                        forcedDisplay: isForcedDisplay.forcedDisplay
                    });
                } else {
                    var text = '';
                    var textElements = cue.__children;
                    if (textElements.length) {
                        textElements.forEach(function (el) {
                            if (el.hasOwnProperty('span')) {
                                var spanElements = el.span.__children;
                                spanElements.forEach(function (spanEl) {
                                    // If metadata is present, do not process.
                                    if (spanElements.hasOwnProperty('metadata')) {
                                        return;
                                    }
                                    // If the element is a string
                                    if (spanEl.hasOwnProperty('#text')) {
                                        text += spanEl['#text'].replace(/[\r\n]+/gm, ' ').trim();
                                        // If the element is a 'br' tag
                                    } else if ('br' in spanEl) {
                                        // Create a br element.
                                        text += '\n';
                                    }
                                });
                            } else if (el.hasOwnProperty('br')) {
                                text += '\n';
                            } else {
                                text += el['#text'].replace(/[\r\n]+/gm, ' ').trim();
                            }
                        });
                    }

                    captionArray.push({
                        start: mergedTime.begin,
                        end: mergedTime.end,
                        data: text,
                        type: 'text'
                    });
                }
            });
        }
                         
        divs.forEach(function (div) {
                         if (captionArray.length<1) {
                             parseDiv(div);
                         }
                         Utils.asyncDelay(parseDiv,[div]);
        });

        return captionArray;
    }

    function setup() {
        /*
         * This TTML parser follows "EBU-TT-D SUBTITLING DISTRIBUTION FORMAT - tech3380" spec - https://tech.ebu.ch/docs/tech/tech3380.pdf.
         * */
        timingRegex = /^([0-9]+):([0-5][0-9]):([0-5][0-9])|(60)(\.([0-9])+)?$/; // Regex defining the time
        fontSize = {};
        lineHeight = {};
        linePadding = {};
        padding = {};
        defaultLayoutProperties = {
            'top': '85%;',
            'left': '5%;',
            'width': '90%;',
            'height': '10%;',
            'align-items': 'flex-end;',
            'overflow': 'visible;',//Overflow should only be visible because we move subtitles about too much.
            '-ms-writing-mode': 'lr-tb, horizontal-tb;',
            '-webkit-writing-mode': 'horizontal-tb;',
            '-moz-writing-mode': 'horizontal-tb;',
            'writing-mode': 'horizontal-tb;'
        };
        defaultStyleProperties = {
            'color': 'rgb(255,255,255);',
            'direction': 'ltr;',
            'font-style': 'normal;',
            'font-weight': 'normal;',
            'text-align': 'center;',
            'justify-content': 'center;',
            'text-decoration': 'none;',
            'unicode-bidi': 'normal;',
            'white-space': 'normal;'
        };
        fontFamilies = {
            monospace: 'monospace',
            monospaceSansSerif: 'monospace, sans-serif',
            monospaceSerif: 'monospace, serif',
        };
        fontBlocked = {
            "Reith-sans": true
        };
        fontClasses = {
            sansSerif: 'font-family-sans',
            serif: 'font-family-serif',
            proportionalSansSerif: 'font-family-sans',
            proportionalSerif: 'font-family-serif',
            'default': 'font-family-sans;'
        };
        textAlign = {
            right: ['justify-content: flex-end;', 'text-align: right;'],
            start: ['justify-content: flex-start;', 'text-align: start;'],
            center: ['justify-content: center;', 'text-align: center;'],
            end: ['justify-content: flex-end;', 'text-align: end;'],
            left: ['justify-content: flex-start;', 'text-align: left;']
        };
        multiRowAlign = {
            start: 'text-align: start;',
            center: 'text-align: center;',
            end: 'text-align: end;',
            auto: ''
        };
        wrapOption = {
            wrap: 'white-space: normal;',
            noWrap: 'white-space: nowrap;'
        };
        unicodeBidi = {
            normal: 'unicode-bidi: normal;',
            embed: 'unicode-bidi: embed;',
            bidiOverride: 'unicode-bidi: bidi-override;'
        };
        displayAlign = {
            before: 'align-items: flex-start;',
            center: 'align-items: center;',
            after: 'align-items: flex-end;'
        };
        writingMode = {
            lrtb: '-webkit-writing-mode: horizontal-tb;' + 'writing-mode: horizontal-tb;',
            rltb: '-webkit-writing-mode: horizontal-tb;' + 'writing-mode: horizontal-tb;' + 'direction: rtl;' + 'unicode-bidi: bidi-override;',
            tbrl: '-webkit-writing-mode: vertical-rl;' + 'writing-mode: vertical-rl;' + '-webkit-text-orientation: upright;' + 'text-orientation: upright;',
            tblr: '-webkit-writing-mode: vertical-lr;' + 'writing-mode: vertical-lr;' + '-webkit-text-orientation: upright;' + 'text-orientation: upright;',
            lr: '-webkit-writing-mode: horizontal-tb;' + 'writing-mode: horizontal-tb;',
            rl: '-webkit-writing-mode: horizontal-tb;' + 'writing-mode: horizontal-tb;' + 'direction: rtl;',
            tb: '-webkit-writing-mode: vertical-rl;' + 'writing-mode: vertical-rl;' + '-webkit-text-orientation: upright;' + 'text-orientation: upright;'
        };
        supportsBoxDecorationBreak = Utils.checkCssSupport( document.createElement('span'),"boxDecorationBreak");
    }

    function parseTimings(timingStr) {
        // Test if the time provided by the caption is valid.
        var test = timingRegex.test(timingStr);
        var timeParts, parsedTime, frameRate;

        if (!test) {
            // Return NaN so it will throw an exception at internalParse if the time is incorrect.
            return NaN;
        }

        timeParts = timingStr.split(':');

        // Process the timings by decomposing it and converting it in numbers.
        parsedTime = parseFloat(timeParts[0]) * SECONDS_IN_HOUR + parseFloat(timeParts[1]) * SECONDS_IN_MIN + parseFloat(timeParts[2]);

        // In case a frameRate is provided, we adjust the parsed time.
        if (timeParts[3]) {
            frameRate = ttml.tt.frameRate;
            if (frameRate && !isNaN(frameRate)) {
                parsedTime += parseFloat(timeParts[3]) / frameRate;
            }
        }
        return parsedTime;
    }

    function getNamespacePrefix(json, ns) {
        // Obtain the namespace prefix.
        var r = Object.keys(json).filter(function (k) {
            return (k.split(':')[0] === 'xmlns' || k.split(':')[1] === 'xmlns') && json[k] === ns;
        }).map(function (k) {
            return k.split(':')[2] || k.split(':')[1];
        });
        if (r.length != 1) {
            return null;
        }
        return r[0];
    }

    function removeNamespacePrefix(json, nsPrefix) {
        for (var key in json) {
            if (json.hasOwnProperty(key)) {
                if ((typeof json[key] === 'object' || json[key] instanceof Object) && !Array.isArray(json[key])) {
                    removeNamespacePrefix(json[key], nsPrefix);
                } else if (Array.isArray(json[key])) {
                    for (var i = 0; i < json[key].length; i++) {
                        removeNamespacePrefix(json[key][i], nsPrefix);
                    }
                }
                var newKey = key.slice(key.indexOf(nsPrefix) + nsPrefix.length + 1);
                json[newKey] = json[key];
                delete json[key];
            }
        }
    }

    // backgroundColor = background-color, convert from camelCase to dash.
    function camelCaseToDash(key) {
        return key.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
    }

    // Convert an RGBA value written in Hex to rgba(v,v,v,a).
    function convertHexToRGBA(rgba) {
        // Get the hexadecimal value without the #.
        var hex = rgba.slice(1);
        // Separate the values in pairs.
        var hexMatrice = hex.match(/.{2}/g);
        // Convert the alpha value in decimal between 0 and 1.
        var alpha = parseFloat(parseInt(parseInt(hexMatrice[3], 16) / 255 * 1000, 10) / 1000);
        // Get the standard RGB value.
        var rgb = hexMatrice.slice(0, 3).map(function (i) {
            return parseInt(i, 16);
        });
        // Return the RGBA value for CSS.
        return 'rgba(' + rgb.join(',') + ',' + alpha + ');';
    }

    // Return whether or not an array contains a certain text
    function arrayContains(text, array) {
        for (var i = 0; i < array.length; i++) {
            var split = array[i].split(':');
            if (split.length === 2) {
                if (split[0].trim() === text) {
                    return true;
                }
            }
        }

        return false;
    }

    // Return the whole value that contains "text"
    function getPropertyFromArray(text, array) {
        for (var i = 0; i < array.length; i++) {
            if (array[i].indexOf(text) > -1) {
                return array[i];
            }
        }
        return null;
    }

    function getValueFromArray(text, array) {
        var result = getPropertyFromArray(text, array);
        if (result) {
            result = result.slice(result.indexOf(':') + 1).replace(';','');
        }

        return result;
    }

    // Delete a a property from an array.
    function deletePropertyFromArray(property, array) {
        array.splice(array.indexOf(getPropertyFromArray(property, array)), 1);
    }

    function mergeArrays(primeArray, arrayToAdd) {
        for (var i = 0; i < primeArray.length; i++) {
            for (var j = 0; j < arrayToAdd.length; j++) {
                // Take only the name of the property
                if (primeArray[i]) {
                    if (primeArray[i].split(':')[0].indexOf(arrayToAdd[j].split(':')[0]) > -1) {
                        primeArray.splice(i, 1);
                    }
                }
            }
        }
        return primeArray.concat(arrayToAdd);
    }

    function swapInArrays(str, sourceArray, destArray) {
        if (arrayContains(str, sourceArray)) {
            destArray.push(getPropertyFromArray(str, sourceArray));
            deletePropertyFromArray(str, sourceArray);
        }
    }

    function parseFontSize(str, cellUnit) {
        var valueStr = str.slice(str.indexOf(':') + 1, str.length);
        var value;

        //Convert to em
        if (valueStr.indexOf('%') >= 0) {
            var pc = parseFloat(valueStr.slice(0, valueStr.length - 1));
            value = (pc * cellUnit[1]) / (100 * 16);
        } else if (valueStr.indexOf('em') >= 0) {
            return valueStr;
        } else {
            var px;

            if (valueStr.indexOf('px') >= 0) {
                px = parseInt(valueStr.slice(0, valueStr.length - 2), 10);
            } else { //Assume pixels when there is no unit specified.
                px = parseInt(valueStr, 10);
            }

            value = px / 16;
        }
        return value + 'em;';
    }

    function parseLineHeight(lineHeight, fontSize) {
        var valueLHSize = 125;
        if (lineHeight.indexOf('%') >= 0) {
            valueLHSize = parseFloat(lineHeight.slice(lineHeight.indexOf(':') + 1, lineHeight.indexOf('%')));
        } else if (lineHeight.indexOf('px') >= 0) {
            valueLHSize = fontSize/parseFloat(lineHeight.slice(lineHeight.indexOf(':') + 1, lineHeight.indexOf('px')));
            valueLHSize *= 100;
        }
        return valueLHSize  + '%;';
    }
    /**
     * Processing of styling information:
     * - processStyle: return an array of strings with the cue style under a CSS style form.
     * - findStyleFromID: Return the unprocessed style from TTMLStyling corresponding to the ID researched.
     * - getProcessedStyle: Return the processed style(s) from the ID(s) received in entry.
     * **/

    // Compute the style properties to return an array with the cleaned properties.
    function processStyle(cueStyle, cellUnit) {
        var properties = [];

        if (typeof cueStyle !== 'object') {return;}
        // Clean up from the xml2json parsing:
        for (var key in cueStyle) {
            if (cueStyle.hasOwnProperty(key)) {
                //Clean the properties from the parsing.
                var newKey = key.replace('ebutts:', '');
                newKey = newKey.replace('xml:', '');
                newKey = newKey.replace('tts:', '');

                // Clean the properties' names.
                newKey = camelCaseToDash(newKey);
                if (newKey !== key) {
                    cueStyle[newKey] = cueStyle[key];
                    delete cueStyle[key];
                }
            }
        }

        if ('style' in cueStyle) {
            properties = properties.concat(getProcessedStyle(cueStyle.style, cellUnit));
        }

        // Line padding is computed from the cellResolution.
        if ('line-padding' in cueStyle) {
            var valuePadding = parseFloat(cueStyle['line-padding'].slice(cueStyle['line-padding'].indexOf(':') + 1, cueStyle['line-padding'].indexOf('c')));
            if ('id' in cueStyle) {
                linePadding[cueStyle.id] = valuePadding;
            }
            var valuePaddingInPx = valuePadding * cellUnit[0] + 'px;';
            properties.push('padding-left:' + valuePaddingInPx);
            properties.push('padding-right:' + valuePaddingInPx);
        }
        // Font size is computed from the cellResolution.
        if ('font-size' in cueStyle) {
            var valueFtSize = parseFontSize(cueStyle['font-size'], cellUnit);
            if ('id' in cueStyle) {
                fontSize[cueStyle.id] = valueFtSize;
            }
            
            properties.push('font-size:' + valueFtSize);
        }

        if ('line-height' in cueStyle) {
            if (cueStyle['line-height'] === 'normal') {
                properties.push('line-height: normal;');
            } else {
                var lhValue = parseLineHeight(cueStyle['line-height'], cellUnit);
                properties.push('line-height' + ':' + lhValue);
                if ('id' in cueStyle) {
                    lineHeight[cueStyle.id] = lhValue;
                }
            }

        }
        // Font-family can be specified by a generic family name or a custom family name.
        if ('font-family' in cueStyle) {
            var fontSplit = cueStyle['font-family'].split(',');
            var classes = "";
            for (var s = 0; s < fontSplit.length;) {
                if (fontSplit[s] in fontBlocked) {
                    fontSplit.splice(s,1);
                    continue;
                }
                if (fontSplit[s] in fontClasses) {
                    classes += fontClasses[fontSplit[s]] + ' ';
                    fontSplit.splice(s,1);
                    continue;
                } else if (fontSplit[s] in fontFamilies) {
                    fontSplit[s] = fontFamilies[fontSplit[s]];
                }
                s++;
            }

            if (classes) {
                properties.push("_element-classes:" + classes + ';');
                // if there are fonts as well as classes then fallback
                // may not work correctly.
                if (fontSplit.length>0) {
                    // XXX this also needs to take account of
                    // ReithSans being loaded etc.
                    fontSplit.push("Arial, Helvetica, freesans, sans-serif");
                }
            }
            if (fontSplit.length > 0) {
                properties.push('font-family:' + fontSplit.join(',') + ';');
            }

        }
        // Text align needs to be set from two properties:
        // The standard text-align CSS property.
        // The justify-content property as we use flex boxes.
        if ('text-align' in cueStyle) {
            if (cueStyle['text-align'] in textAlign) {
                properties.push(textAlign[cueStyle['text-align']][0]);
                properties.push(textAlign[cueStyle['text-align']][1]);
            }
        }
        // Multi Row align is set only by the text-align property.
        // It is handled last, as it overwrites text-align, so just insert the cueStyle here.
        if ('multi-row-align' in cueStyle) {
            properties.push('multi-row-align:' + cueStyle['multi-row-align'] + ';');
        }
        // Background color can be specified from hexadecimal (RGB or RGBA) value.
        var rgbaValue;
        if ('background-color' in cueStyle) {
            if (cueStyle['background-color'].indexOf('#') > -1 && cueStyle['background-color'].length - 1 === 8) {
                rgbaValue = convertHexToRGBA(cueStyle['background-color']);
                properties.push('background-color: ' + rgbaValue);
            } else {
                properties.push('background-color:' + cueStyle['background-color'] + ';');
            }
        }
        // Color can be specified from hexadecimal (RGB or RGBA) value.
        if ('color' in cueStyle) {
            if (cueStyle.color.indexOf('#') > -1 && cueStyle.color.length - 1 === 8) {
                rgbaValue = convertHexToRGBA(cueStyle.color);
                properties.push('color: ' + rgbaValue);
            } else {
                properties.push('color:' + cueStyle.color + ';');
            }
        }
        // Wrap option is determined by the white-space CSS property.
        if ('wrap-option' in cueStyle) {
            if (cueStyle['wrap-option'] in wrapOption) {
                properties.push(wrapOption[cueStyle['wrap-option']]);
            } else {
                properties.push('white-space:' + cueStyle['wrap-option']);
            }
        }
        // Unicode bidi is determined by the unicode-bidi CSS property.
        if ('unicode-bidi' in cueStyle) {
            if (cueStyle['unicode-bidi'] in unicodeBidi) {
                properties.push(unicodeBidi[cueStyle['unicode-bidi']]);
            } else {
                properties.push('unicode-bidi:' + cueStyle['unicode-bidi']);
            }
        }

        // Standard properties identical to CSS.

        if ('font-style' in cueStyle) {
            properties.push('font-style:' + cueStyle['font-style'] + ';');
        }
        if ('font-weight' in cueStyle) {
            properties.push('font-weight:' + cueStyle['font-weight'] + ';');
        }
        if ('direction' in cueStyle) {
            properties.push('direction:' + cueStyle.direction + ';');
        }
        if ('text-decoration' in cueStyle) {
            properties.push('text-decoration:' + cueStyle['text-decoration'] + ';');
        }

        // Handle white-space preserve
        if (ttml.tt.hasOwnProperty('xml:space')) {
            if (ttml.tt['xml:space'] === 'preserve') {
                properties.push('white-space: pre;');
            }
        }

        return properties;
    }
    
    // Find the style set by comparing the style IDs available.
    // Return null if no style is found
    function findStyleFromID(ttmlStyling, cueStyleID) {
        // For every styles available, search the corresponding style in ttmlStyling.
        for (var j = 0; j < ttmlStyling.length; j++) {
            var currStyle = ttmlStyling[j];
            if (currStyle['xml:id'] === cueStyleID || currStyle.id === cueStyleID) {
                // Return the style corresponding to the ID in parameter.
                return currStyle;
            }
        }
        return null;
    }
    // Return the computed style from a certain ID.
    function getProcessedStyle(reference, cellUnit) {
        var styles = [];
        var ids = reference.match(/\S+/g);
        ids.forEach(function (id) {
            // Find the style for each id received.
            var cueStyle = findStyleFromID(ttmlStyling, id);
            if (cueStyle) {
                // Process the style for the cue in CSS form.
                // Send a copy of the style object, so it does not modify the original by cleaning it.
                var stylesFromId = processStyle(JSON.parse(JSON.stringify(cueStyle)), cellUnit);
                styles = styles.concat(stylesFromId);
            }
        });
        return styles;
    }

    /**
     * Processing of layout information:
     * - processRegion: return an array of strings with the cue region under a CSS style form.
     * - findRegionFromID: Return the unprocessed region from TTMLLayout corresponding to the ID researched.
     * - getProcessedRegion: Return the processed region(s) from the ID(s) received in entry.
     ***/

    // Compute the region properties to return an array with the cleaned properties.
    function processRegion(cueRegion, cellUnit) {
        var properties = [];

        // Clean up from the xml2json parsing:
        for (var key in cueRegion) {
            if (cueRegion.hasOwnProperty(key)) {
                //Clean the properties from the parsing.
                var newKey = key.replace('tts:', '');
                newKey = newKey.replace('xml:', '');

                // Clean the properties' names.
                newKey = camelCaseToDash(newKey);
                cueRegion[newKey] = cueRegion[key];
                if (newKey !== key) {
                    delete cueRegion[key];
                }
            }
        }
        if ('extent' in cueRegion && 'origin' in cueRegion) {
            var coordsExtent = cueRegion.extent.split(/\s/);
            if (isValidPercentage(coordsExtent[0]) && isValidPercentage(coordsExtent[1])) {
                properties.push('width: ' + coordsExtent[0] + ';');
                properties.push('height: ' + coordsExtent[1] + ';');
            }

            var coordsOrigin = cueRegion.origin.split(/\s/);
            if (isValidPercentage(coordsOrigin[0]) && isValidPercentage(coordsOrigin[1])) {
                properties.push('left: ' + coordsOrigin[0] + ';');
                properties.push('top: ' + coordsOrigin[1] + ';');
            }
        }
        // DisplayAlign property corresponds to vertical-align
        if ('display-align' in cueRegion) {
            properties.push(displayAlign[cueRegion['display-align']]);
        }
        // WritingMode is not yet implemented (for CSS3, to come)
        if ('writing-mode' in cueRegion) {
            properties.push(writingMode[cueRegion['writing-mode']]);
        }
        // Style will give to the region the style properties from the style selected
        if ('style' in cueRegion) {
            var styleFromID = getProcessedStyle(cueRegion.style, cellUnit);
            properties = properties.concat(styleFromID);
        }

        // Standard properties identical to CSS.
        if ('padding' in cueRegion) {
            properties.push('padding:' + cueRegion.padding + ';');
        }
        if ('show-background' in cueRegion) {
            properties.push('show-background:' + cueRegion['show-background'] + ';');
        }
        if ('id' in cueRegion) {
            properties.push('regionID:' + cueRegion.id + ';');
        }

        return properties;
    }
    
    // Find the region set by comparing the region IDs available.
    // Return null if no region is found
    function findRegionFromID(ttmlLayout, cueRegionID) {
        // For every region available, search the corresponding style in ttmlLayout.
        if (ttmlLayout) {
            for (var j = 0; j < ttmlLayout.length; j++) {
                var currReg = ttmlLayout[j];
                if (currReg['xml:id'] === cueRegionID || currReg.id === cueRegionID) {
                    // Return the region corresponding to the ID in parameter.
                    return currReg;
                }
            }
        }
        return null;
    }

    // Return the computed region from a certain ID.
    function getProcessedRegion(id, cellUnit) {
        var region = [];
        // Find the region for each id received.
        var cueRegion = findRegionFromID(ttmlLayout, id);
        if (cueRegion) {
            if ((cueRegion.hasOwnProperty('origin') || cueRegion.hasOwnProperty('tts:origin')) && (cueRegion.hasOwnProperty('extent') || cueRegion.hasOwnProperty('tts:extent'))) {
                // Process the region for the cue in CSS form.
                // Send a copy of the style object, so it does not modify the original by cleaning it.
                region = processRegion(Utils.clone(cueRegion), cellUnit);

                var positioned = arrayContains('left', region) && arrayContains('top', region) && arrayContains('height', region) && arrayContains('width', region);
                //If positioning information is missing, just discard. No point supporting partial regions because they cannot be merged.
                if (!positioned) {
                    region = [];
                }
            }
        }

        return region;
    }

    //Return the cellResolution defined by the TTML document.
    function getCellResolution() {
        var defaultCellResolution = [32, 15]; // Default cellResolution.
        if (ttml.tt.hasOwnProperty('ttp:cellResolution')) {
            return ttml.tt['ttp:cellResolution'].split(' ').map(parseFloat);
        } else {
            return defaultCellResolution;
        }
    }

    // Return the cue wrapped into a span specifying its linePadding.
    function applyLinePadding(cueHTML, paddingLeft, paddingRight) {

        if (!paddingLeft || !paddingRight) {
            return;
        }

        // List all the nodes of the subtitle.
        var nodeList = Array.prototype.slice.call(cueHTML.children);

        var addClassName = function (span) {
            if (span.className.indexOf('p_spanPadding') < 0) {
                span.className = span.className + ' p_spanPadding';
            }
        };
        var lastSpan;
        var newLine = true;
        for (var i = 0; i < nodeList.length; i++) {
            var span = nodeList[i];
            if (span.tagName === 'SPAN') {
                if (newLine) {
                    //First span, apply left line padding.
                    span.style.paddingLeft = paddingLeft;
                    addClassName(span);
                    newLine = false;
                }
                lastSpan = span;
            } else if (span.tagName === 'BR') {
                //Last span.
                if (lastSpan) {
                    lastSpan.style.paddingRight = paddingRight;
                    addClassName(span);
                }
                newLine = true;
            }
        }
        if (!newLine && lastSpan) { //If ended and newLine is false, no terminating <BR> so add end padding here.
            lastSpan.style.paddingRight = paddingRight;
            addClassName(span);
        }
    }

    function stripWhitespace(cue) {
        cue.textContent = cue.textContent.replace(/\s+/g, " ");
        cue.textContent = cue.textContent.replace(/^\s|\s$/g, "");
    }

    function getClasses(properties) {
        var ret = "";
        var val = getValueFromArray("_element-classes", properties);
        if (val) {
            ret += val;
            deletePropertyFromArray("_element-classes", properties);
        }
        return ret;
    }
    /*** Create the cue element
     * I. The cues are text only:
     *      i) The cue contains a 'br' element
     *      ii) The cue contains a span element
     *      iii) The cue contains text
     * ***/

    function constructCue(cueElements, cellUnit, ebuMode) {
        var cue = document.createElement('div');
        cueElements.forEach(function (el) {
            // If metadata is present, do not process.
            if (el.hasOwnProperty('metadata')) {
                return;
            }

            /**
             * If the p element contains spans: create the span elements.
             */
            if (el.hasOwnProperty('span')) {

                // Stock the span subtitles in an array (in case there are only one value).
                var spanElements = el.span.__children;

                if (spanElements && spanElements.length > 0) {
                    // Create the span element.
                    var spanHTMLElement = document.createElement('span');

                    //Check for inline styles.
                    var spanStyle = processStyle(Utils.clone(el.span), cellUnit);
                    Utils.className(spanHTMLElement, getClasses(spanStyle));
                    spanHTMLElement.style.cssText = spanStyle.join(' ');
                    if (ebuMode && supportsBoxDecorationBreak) {
                        Utils.applyVendorStyles([spanHTMLElement],"boxDecorationBreak","clone");
                    } else {
                        spanHTMLElement.style.display = 'inline-block';
                    }
                    if (!spanHTMLElement.style.paddingLeft) {
                        spanHTMLElement.style.paddingLeft = '0.25em';
                    }
                    if (!spanHTMLElement.style.paddingRight) {
                        spanHTMLElement.style.paddingRight = '0.25em';
                    }

                    // if the span has more than one element, we check for each of them their nature (br or text).
                    var spanParse = function (spanEl, index, array) {
                        if (spanEl.span && spanEl.span.__children) {
                            spanEl.span.__children.forEach(spanParse);
                        }

                        // If metadata is present, do not process.
                        if (spanElements.hasOwnProperty('metadata')) {
                            return;
                        }
                        // If the element is a string
                        if (spanEl.hasOwnProperty('#text')) {
                            var textNode = document.createTextNode(spanEl['#text']);
                            stripWhitespace(textNode);
                            spanHTMLElement.appendChild(textNode);
                            // If the element is a 'br' tag
                        } else if ('br' in spanEl) {
                            // To handle br inside span we need to add the current span
                            // to the cue and then create a br and add that the cue
                            // then create a new span that we use for the next line of
                            // text, that is a copy of the current span

                            // Add the current span to the cue, only if it has childNodes (text)
                            if (spanHTMLElement.hasChildNodes()) {
                                cue.appendChild(spanHTMLElement);
                            }

                            // Create a br and add that to the cue
                            var brEl = document.createElement('br');
                            brEl.className = 'p_lineBreak';
                            cue.appendChild(brEl);

                            if (index + 1 < array.length) {
                                // Create an replacement span and copy the style and classname from the old one
                                var newSpanHTMLElement = document.createElement('span');
                                newSpanHTMLElement.className = spanHTMLElement.className;
                                newSpanHTMLElement.style.cssText = spanHTMLElement.style.cssText;

                                // Replace the current span with the one we just created
                                spanHTMLElement = newSpanHTMLElement;
                            } else {
                                spanHTMLElement = null;
                            }
                        }
                    };

                    spanElements.forEach(spanParse);
                    // We append the element to the cue container.
                    if (spanHTMLElement) {
                        cue.appendChild(spanHTMLElement);
                    }
                }
            }
            /**
             * Create a br element if there is one in the cue.
             */
            else if (el.hasOwnProperty('br')) {
                // We append the line break to the cue container.
                var brEl = document.createElement('br');
                brEl.className = 'p_lineBreak';
                cue.appendChild(brEl);
            }
            /**
             * Add the text that is not in any inline element
             */
            else if (el.hasOwnProperty('#text')) {
                // Add the text to an individual span element (to add line padding if it is defined).
                var textNode = document.createElement('span');
                textNode.textContent = el['#text'];
                if (ebuMode && supportsBoxDecorationBreak) {
                    Utils.applyVendorStyles([textNode],"boxDecorationBreak","clone");
                } else {
                    textNode.style.display = 'inline-block';
                }
                stripWhitespace(textNode);

                // We append the element to the cue container.
                cue.appendChild(textNode);
            }
        });

        return cue;
    }

    function constructCueRegion(cue, div, cellUnit) {
        var cueRegionProperties = []; // properties to be put in the "captionRegion" HTML element
        // Obtain the region ID(s) assigned to the cue.
        var pRegionID = cue.region;
        // If div has a region.
        var divRegionID = div.region;
        var pRegionOrigin = cue.origin || cue['tts:origin'];
        var pRegionExtent = cue.extent || cue['tts:extent'];

        if (pRegionOrigin && pRegionExtent) {
            var coordsExtent = pRegionExtent.split(/\s/);
            if (isValidPercentage(coordsExtent[0]) && isValidPercentage(coordsExtent[1])) {
                cueRegionProperties.push('width: ' + coordsExtent[0] + ';');
                cueRegionProperties.push('height: ' + coordsExtent[1] + ';');
            }

            var coordsOrigin = pRegionOrigin.split(/\s/);
            if (isValidPercentage(coordsOrigin[0]) && isValidPercentage(coordsOrigin[1])) {
                cueRegionProperties.push('left: ' + coordsOrigin[0] + ';');
                cueRegionProperties.push('top: ' + coordsOrigin[1] + ';');
            }
        }
        // If the p element reference a region.
        else if (pRegionID) {
            cueRegionProperties = getProcessedRegion(pRegionID, cellUnit);
        }
        // If the div element reference a region.
        else if (divRegionID) {
            cueRegionProperties = getProcessedRegion(divRegionID, cellUnit);
        }

        return cueRegionProperties;
    }

    function constructCueStyle(cue, cellUnit) {
        var cueStyleProperties = [];
        cueStyleProperties = mergeArrays(cueStyleProperties, processStyle(ttml.tt.body, cellUnit));
        cueStyleProperties = mergeArrays(cueStyleProperties, processStyle(ttml.tt.body.div, cellUnit));
        cueStyleProperties = mergeArrays(cueStyleProperties, processStyle(cue, cellUnit));
        applyDefaultProperties(cueStyleProperties, defaultStyleProperties);
        return cueStyleProperties;
    }

    function applyDefaultProperties(array, defaultProperties) {
        for (var key in defaultProperties) {
            if (defaultProperties.hasOwnProperty(key)) {
                if (!arrayContains(key, array)) {
                    array.push(key + ':' + defaultProperties[key]);
                }
            }
        }
    }

    function applyBackgroundColorDefaults(para) {
        if(para.style.cssText.indexOf('background-color') < 0) {
            //Then check the spans. Find the bidi wrapper and look at its children.
            var bidiWrappers = para.getElementsByClassName('p_cueDirUniWrapper');
            for (var i = 0; i < bidiWrappers.length; i++) {
                if(bidiWrappers[i].children) {
                    for (var j = 0; j < bidiWrappers[i].children.length; j++) {
                        var span = bidiWrappers[i].children[j];
                        applyBackgroundColorToSpans(span);
                    }
                }
            }
        }
    }

    function applyBackgroundColorToSpans(span) {
        if(span.children && span.children.length > 0) {
            for (var i = 0 ; i < span.children.length; i++) {
                applyBackgroundColorToSpans(span.children[i]);
            }
        } else if (span.style.cssText.indexOf('background-color') < 0) {
            span.style.backgroundColor = 'black';
        }
    }

    function isValidPercentage(str) {
        return str.match(/(100|[0-9]{1,2})(.[0-9]+)?%/);
    }

    function getTimesFromElement(obj) {
        var beginStr;
        var endStr;

        if (obj) {
             beginStr = obj.begin || obj["tt:begin"];
             endStr = obj.end || obj["tt:end"];
        }

        return {
            begin: parseTimings(beginStr),
            end: parseTimings(endStr)
        };
    }

    // NARRATIVE SUBS WIP
    function getForcedDisplayFromElement(obj) {
        var isForcedDisplay = false;
        var forcedDisplayString = '';

        if (obj) {
            forcedDisplayString = obj["itts:forcedDisplay"];
            isForcedDisplay = (forcedDisplayString == 'true');
        }

        return {
            forcedDisplay : isForcedDisplay
        };
    }

    function mergeTimes(obj, overwrite) {
        return {
            begin: !isNaN(overwrite.begin) ? overwrite.begin : obj && obj.begin,
            end: !isNaN(overwrite.end) ? overwrite.end : obj && obj.end
        };
    }

    instance = {
        parse: parse,
        applyLinePadding: applyLinePadding
    };

    setup();
    return instance;
})();

var SubtitlesItem = (function() {

    var SubtitlesItem = function(href, protocol, supplier, dpw) {
        var subsItem = this;
        subsItem.live = false;
        subsItem.href = href;
        subsItem.protocol = protocol;
        subsItem.supplier = supplier;
        subsItem.dpw = dpw;
        subsItem.override = false;
        subsItem.captionsList = null;
        subsItem.kind = (/^us_closed_captions/.test(supplier+"")) ? "closedCaptions" : "subtitles";

        // NARRATIVE SUBS WIP
        subsItem.loaded = false;

        return subsItem;
    };

    SubtitlesItem.prototype = {
        loadSubtitles: function (callback, error) {
            var subsItem = this;
            var href = subsItem.href;

            if (subsItem.captionsList && subsItem.captionsList.length>0) {
                callback(href);
                return;
            }

            var cb = function (xmldoc) {
                if (subsItem.subtitlesLoaded(xmldoc)) {
                    callback(href);
                } else {
                    error(href);
                }
            };
            Utils.getXML(href, cb, error, subsItem);
        },
        subtitlesLoaded: function (xml) {
            var subsItem = this;
            var ok = false;
            try {
                var captionsList = TTMLParser.parse(xml);
                if (DEBUG_FULL) {
                    console.log("TTMLParser: loaded:"+ captionsList.length);
                }
                if (captionsList.length > 0) {
                    subsItem.captionsList = captionsList;
                    ok=true;

                    // NARRATIVE SUBS WIP
                    subsItem.loaded = true;
                } 
            } catch (e) {
                if (DEBUG_FULL) {
                    console.log("Failed to parse subtitles - TTMLParser:  " + e.message);
                }
            }
            return ok;
        }
    };

    return SubtitlesItem;
})();
var NarrSubtitles = (function() {

    var _firstTimePlaying = true;
    var _forcedDisplayList = [];
    var _listUpdated = false;

    function feedTheList(narrSub){
        var subsLoaded = narrSub.player.Subtitles && narrSub.player.Subtitles.currentSubItem && narrSub.player.Subtitles.currentSubItem.loaded;
        if (!_listUpdated && subsLoaded) {
            var list = narrSub.player.Subtitles.currentSubItem.captionsList;
            for (var i=0; i<list.length; i++) {
                if (list[i].forcedDisplay) {
                    _forcedDisplayList.push(list[i]);
                }
            }
            _listUpdated = true;
        }
        return _forcedDisplayList !== 0;
    }

    function reset(){
        _firstTimePlaying = true;
        _listUpdated = false;
    }

    function getCallbackObject(narrSub) {

        return {

            timeupdate : function() {
                if (!_firstTimePlaying) {
                    narrSub.render(); 
                }
            },

            playing : function(){
                if (_firstTimePlaying) {
                    narrSub.player.Subtitles.load(true);
                    _firstTimePlaying = false;
                }
            },

            // playlistEnded : reset,
            playlistLoaded : reset

        };

    }
     
    /**
     * Constructor for NarrSubtitles class
     *
     */
    var NarrSubtitles = function(player) {
        var narrSub = this;

        narrSub.player = player;
        narrSub.container = document.createElement('div');
        narrSub.container.id = 'narrSubsContainer';

        // display none for now
        narrSub.container.style.cssText = 'display:none;';

        narrSub.player.mediaContainer.appendChild(narrSub.container);

        narrSub.narrativeMainWrap = document.createElement('div');
        narrSub.narrativeMainWrap.id = 'narrative';
        narrSub.narrativeMainWrap.className = 'Narrative';
        narrSub.container.appendChild(narrSub.narrativeMainWrap);

        narrSub.narrSubWrap = document.createElement('div');

        // is here where the magic will happen?
        // newslab is working on it at the moment, 
        // will the style be in the ttml file or in the player css? to be defined
        // so we may update the class list or pass a string of css
        // narrSub.narrSubWrap.className = 'Horizontal Middle Bar-red Text-white Scene Bar BuildIn';

        narrSub.narrativeMainWrap.appendChild(narrSub.narrSubWrap); 

        narrSub.textContainer = document.createElement('p');
        narrSub.narrSubWrap.appendChild(narrSub.textContainer);

        narrSub.eventCallbacks = getCallbackObject(this);

        return narrSub;

    };

    NarrSubtitles.prototype = {

        render : function() {
            var narrSub = this;

            var hasCaption = feedTheList(narrSub);
            if (!hasCaption) {
                return;
            }

            var currentTime = narrSub.player.timeHelper.time;

            var matchCurrentTime = function(caption){
                return caption.start <= currentTime && currentTime < caption.end;
            };

            var caption = _forcedDisplayList.filter(matchCurrentTime);
            var text = (caption[0] && caption[0].cueHTMLElement) ? caption[0].cueHTMLElement.innerText : '';

            if (narrSub.textContainer.firstChild && narrSub.textContainer.firstChild.innerText === text) {
                return;
            }

            var captionSpan = document.getElementById('caption');
            if (captionSpan) {
                narrSub.textContainer.removeChild(captionSpan); 
            }

            if (text !== ''){
                captionSpan = document.createElement('span');
                captionSpan.id = 'caption';
                captionSpan.textContent = text;
                narrSub.textContainer.appendChild(captionSpan);
            }

        }

    };

    return NarrSubtitles;

})();
var LiveSubtitlesItem = (function () {

    function templateLiveUrl(baseUrl, segment) {
        return baseUrl + segment + ".m4s";
    }

    function mergeLiveSubs(subsItem, newCaptions,type) {
        var list="captionsList";
        if (type) {
            list+="2";
        }
        if (!subsItem[list]) {
            subsItem[list]= [];
        }
        for (var i = 0; i < newCaptions.length; i++) {
            subsItem[list].push(newCaptions[i]);
        }
        subsItem[list] = Utils.stableSort(subsItem[list],Utils.sortByStart);
    }

    function loadSubtitleChunk(subsItem) {
        if (subsItem.loadQueue.length > 0) {
            var segment = subsItem.loadQueue[0];

            if (subsItem.loadedSegments.indexOf(segment.index) < 0 && subsItem.baseUrl) {
                var href = templateLiveUrl(subsItem.baseUrl, segment.index);
                subsItem.loadedSegments.push(segment.index);
                var count = 0;
                var cb = function (text) {
                    var xmlText=text.split(/<\?xml version=\"1.0\" encoding=\"UTF-8\"\?>/i)[1];
                    var xmlParser = new DOMParser();
                    try {
                        var xml = xmlParser.parseFromString(xmlText, "text/xml");
                        if (parseLiveSubtitles(subsItem, segment.start, xml, segment.index)) {
                            if (subsItem.loadedCallback) {
                                subsItem.loadedCallback(href);
                                subsItem.loadedCallback = null;
                            }
                        } else {
                            subsItem.errorCallback(href);
                        }
                    } catch (e) {
                        subsItem.errorCallback(href);
                    }
                    subsItem.loadQueue.shift();
                    loadSubtitleChunk(subsItem);
                };
                var error = function() {
                    if (count++>3) {
                        subsItem.errorCallback(href);
                    } else {
                        setTimeout(function() {
                                       Utils.getText(href, cb, error, subsItem);
                                   },400);
                    }
                };
                Utils.getText(href, cb, error, subsItem);
            } else {
                subsItem.loadQueue.shift();
                loadSubtitleChunk(subsItem);
                return false;
            }
        }
        return true;
    }

    function parseLiveSubtitles(subsItem, time, xml, segmentIndex) {
        var ret = true;
        if (xml) {
            try {
                var captionsList = TTMLParser.parse(xml);
                if (captionsList && captionsList.length > 0) {
                    for (var i = 0; i < captionsList.length; i++) {
                        // USP 1.7.9 streams will use times relative to
                        // the fragment start time. USP 1.7.25 will use
                        // times relative to the presentationStartTime (epoch)
                        // Assume values > 1h do not need the fragment offset applying
                        if (captionsList[i].start < 3600) {
                            captionsList[i].start += (time-3.84);
                            captionsList[i].end += (time-3.84);
                        }
                        captionsList[i].start += subsItem.timeOffset;
                        captionsList[i].end += subsItem.timeOffset;
                        captionsList[i].liveSegmentIndex = segmentIndex;

                        if (subsItem.enableReformat) {
                            fixRegionWidth(captionsList[i]);
                            fixFont(captionsList[i]);
                            forceAlignment(captionsList[i]);
                        }
                    }
                    mergeLiveSubs(subsItem, captionsList);

                    if (subsItem.enableDesnake) {
                        mergeSubtitles(subsItem.captionsList, desnakeStrategy);
                    }

                    if (subsItem.enableReformat) {
                        mergeSubtitles(subsItem.captionsList, mergeLinesStrategy);
                        for (var b = 0; b < captionsList.length; b++) {
                            var sub = captionsList[b];
                            if (subsItem.lastBaseline) {
                                repositionToBaseline(subsItem.lastBaseline, sub);
                            }
                            if (isSuitableBaseline(sub)) {
                                subsItem.lastBaseline = sub;
                            }
                        }
                    }

                    var totalCount = subsItem.captionsList.length;
                    if (totalCount > 180) {
                        var removedIndexes = [];
                        var st = captionsList[0].start;
                        for (var j = 0; j < subsItem.captionsList.length;) {
                            var c = subsItem.captionsList[j];
                            if (c.start < st - 120 || c.start > st + 300 || removedIndexes.indexOf(c.liveSegmentIndex) > 0) { //2 minutes behind fragment (1 behind current time if full buffer, 5 mins ahead)
                                if (removedIndexes.indexOf(c.liveSegmentIndex) < 0) {
                                    removedIndexes.push(c.liveSegmentIndex);
                                }
                                subsItem.captionsList.splice(j, 1);
                            } else {
                                j++;
                            }
                        }
                        subsItem.loadedSegments = subsItem.loadedSegments.filter(function(index) { return removedIndexes.indexOf(index) < 0; });
                        if (DEBUG_FULL) {
                            console.log("Pruning simulcast captions list, was " + totalCount + " long, now " + subsItem.captionsList.length);
                        }
                    }
                }
            } catch (e) {
                if (DEBUG_FULL) {
                    console.log("Failed to parse subtitles - TTMLParser:  " + e.message);
                }
            }
        } else {
            if (DEBUG_FULL) {
                console.log("Failed to load subtitles file.");
            }
            ret = false;
        }
        return ret;
    }

    function inLiveSnake(latest, old) {
        var ret = false;
        if (latest.cueHTMLElement.textContent.indexOf(old.cueHTMLElement.textContent) === 0) {
            if(latest.cueHTMLElement.style.left === old.cueHTMLElement.style.left &&
                latest.cueHTMLElement.style.top === old.cueHTMLElement.style.top &&
                latest.cueHTMLElement.style.width === old.cueHTMLElement.style.width &&
                latest.cueHTMLElement.style.height === old.cueHTMLElement.style.height) {
                ret = true;
            }
        }

        return ret;
    }

    function mergeSubtitles(captionsArray, strategy) {
        for (var i = 0; i < captionsArray.length;) {
            var removed = false;
            var sub = captionsArray[i];
            for (var j = i - 1; j >= 0; j--) {
                var other = captionsArray[j];
                
                var replacement = strategy(sub, other);
                if (replacement) {
                    captionsArray.splice(i, 1, replacement);
                    captionsArray.splice(j, 1);
                    removed = true;
                    break;
                }
            }

            if (!removed) {
                i++;
            }
        }
    }

    function desnakeStrategy(sub, other) {
        var ret = null;
        if (sub.start <= other.end) {
            if (inLiveSnake(sub, other)) {
                sub.start = other.start;
                //If it's in the displayed subtitles list, flag it so we can remove it there too.
                other.desnaked = true;
                ret = sub;
            }
        }

        return ret;
    }

    function getRegionAttr(sub) {
        return {
            left: parseFloat(sub.cueHTMLElement.style.left),
            top: parseFloat(sub.cueHTMLElement.style.top),
            width: parseFloat(sub.cueHTMLElement.style.width),
            height: parseFloat(sub.cueHTMLElement.style.height)
        };
    }

    var TT_LINE_SIZE = 4.17;
    //var TT_CHAR_SIZE = 2.5;
    // Where two lines look like they are part of the same paragraph, merge them.
    // This relies on a lot of a priori assumptions about the nature of the teletext source and how it
    // converts to TTML
    // Baseline is the .top of the last two line sub. Because a one line sub can either appear as a top line (news)
    // or a bottom line (recorded), it's impossible to know when the position has changed or the vertical alignment
    // has reversed. So, we look for the last two-line paragraph and try and use that as a guide to stop the position
    // from jumping about - of course there might not be this history available so theres still jumping until the baseline
    // is decided.
    function mergeLinesStrategy(sub, other) {
        var subRegion = getRegionAttr(sub);
        var otherRegion = getRegionAttr(other);
         
        //swap them round if they are ordered in the file in an order bottom-top (would this ever happen??)
        if (subRegion.top > otherRegion.top) {
            var tmp = other;
            other = sub;
            sub = tmp;

            var tmpRegion = otherRegion;
            otherRegion = subRegion;
            subRegion = tmpRegion;
        } else if (subRegion.top === otherRegion.top) {
            return null;
        }

        if (areTimesSame(sub, other) && doLinesOverlap(subRegion, otherRegion)) {
            for (var i = 0; i < other.cueHTMLElement.children.length; i++) {
                var p = sub.cueHTMLElement.children[0];
                //p.appendChild(document.createElement('br'));
                var otherP = other.cueHTMLElement.children[0];
                for (var c = 0; c < otherP.children.length; c++) {
                    p.appendChild(otherP.children[c]);
                }
            }
            sub.cueHTMLElement.style.left = Math.min(subRegion.left, otherRegion.left) + '%';
            sub.cueHTMLElement.style.width = Math.max(subRegion.width, otherRegion.width) + '%';
            sub.cueHTMLElement.style.height = (subRegion.height + otherRegion.height + (otherRegion.top - subRegion.top)) + '%';
            return sub;
        }

        return null;
    }

    //What looks to be centred text is offset to the right because left + width = 100%. Make width smaller so left === right.
    function fixRegionWidth(sub) {
        sub.cueHTMLElement.style.width = parseFloat(sub.cueHTMLElement.style.width) - parseFloat(sub.cueHTMLElement.style.left) + '%';
    }

    function fixFont(sub) {
        var pEls = sub.cueHTMLElement.children;
        for (var i = 0; i < pEls.length; i++) {
            pEls[i].style.fontFamily = "ReithSans, sans-serif";
        }
    }

    function forceAlignment(sub) {
        var top = parseFloat(sub.cueHTMLElement.style.top);
        for (var j = 0; j < sub.flexBoxAttr.length; j++) {
            if (sub.flexBoxAttr[j].indexOf("align-items:") === 0) {
                sub.flexBoxAttr[j] = "align-items:" + top < 40 ? "flex-start;" : "flex-end;";
                break;
            }
        }
    }

    function areTimesSame(sub, other) {
        return sub.start === other.start && sub.end === other.end;
    }

    //The live subs come in as double line sized - there should not be a gap between regions,
    //but our source apparently doesn't know they're double sized so there's a one line gap(TT_LINE_SIZE) between them
    function doLinesOverlap(upperRegion, lowerRegion) {
        var ret = lowerRegion.top - (upperRegion.top + upperRegion.height) <= TT_LINE_SIZE + 0.1;//Floating point rounding
        //Horizontal overlap - Does the lower have any portion that lies on the midpoint of the upper region?
        var upperMidpoint = upperRegion.left + upperRegion.width / 2;
        ret &= lowerRegion.left <= upperMidpoint && lowerRegion.left + lowerRegion.width >= upperMidpoint;
        return ret;
    }

    //Is two lines long - maybe restrict further for is centred?
    function isSuitableBaseline(sub) {
        return isTwoLineSubtitle(sub);
    }

    function isTwoLineSubtitle(sub) {
        var height = parseFloat(sub.cueHTMLElement.style.height);

        return height > 2 * TT_LINE_SIZE && height <= 4 * TT_LINE_SIZE; //two lines height (it's double a TT_LINE)
    }

    // Duplicate the region of baseline if it exists (based on number of lines).
    // Basically, extend the region to the height of the previous 2 line sub.
    function repositionToBaseline(baseline, sub) {
        if (baseline && !isTwoLineSubtitle(sub)) {
            var baselineRegion = getRegionAttr(baseline);
            var subRegion = getRegionAttr(sub);
            if (Math.abs(baselineRegion.top - subRegion.top) <= TT_LINE_SIZE) { //If the topside of the baseline matches, make the region height the same.
                sub.cueHTMLElement.style.height = Math.max(baselineRegion.height, subRegion.height) + '%';//Math.max to protect against shrinking for large subs.
            } else if (Math.abs((subRegion.top + subRegion.height) - (baselineRegion.top + baselineRegion.height)) <= TT_LINE_SIZE)  { //If the bottomside of the baseline matches, make the height + top the same.
                sub.cueHTMLElement.style.height = Math.max(baselineRegion.height, subRegion.height) + '%';
                sub.cueHTMLElement.style.top = Math.min(baselineRegion.top, subRegion.top) + '%';
            }
        }
    }

    function getCatchUpSubtitles(unloadedArray) {
        return unloadedArray.slice(-17); //We can do something smarter than this with the current player time... but it is probably not worth it. 17 fragments would nornally be 61 seconds and we'll never have a buffer that large, the small extra download here is not worth the extra complexity.
    }

    var LiveSubtitlesItem = function(sampleUrl, isLiveHls) {
        var subsItem = this;
        subsItem.live = true;
        subsItem.loadedSegments = [];
        subsItem.unloadedSegments = [];
        subsItem.captionsList = null;
        subsItem.off();
        subsItem.enableDesnake = false;
        subsItem.hasHLSliveSubs = false;
        subsItem.baseUrl = null;
        subsItem.lastBaseline = null;

        var arr = sampleUrl.match( /.*\/([^\/]*)\.isml/ );
        if ( arr && arr.length > 0 ) {
            if (isLiveHls) {
                subsItem.hasHLSliveSubs = true;
                var firstPart = arr[0].replace('hls', 'dash');
                subsItem.baseUrl = firstPart + "/dash/" + arr[1] + "-caption1=64000-";
            } else {
                subsItem.baseUrl = arr[0] + "/dash/" + arr[1] + "-caption1=64000-";
            }
            subsItem.timeOffset = 0;
        }

        return subsItem;
    };

    LiveSubtitlesItem.prototype = {
        loadSubtitles: function (callback, error) {
            var subsItem = this;
            // XXX if baseUrl is dead we should call error directly
            // here probably
            subsItem.loadedCallback = callback;
            subsItem.errorCallback = error;
            subsItem.active = true;

            var unloaded = getCatchUpSubtitles(subsItem.unloadedSegments);
            while (unloaded.length > 0) {
                var segment = unloaded.shift();
                if (segment) {
                    subsItem.loadQueue.push(segment);
                    if (subsItem.loadQueue.length == 1) {
                        loadSubtitleChunk(subsItem);
                    }
                } else {
                    break;
                }
            }
        },
        onFragmentLoaded: function (chunk, request) {
            var subsItem = this;
            var urlIndex = /-([0-9]*)\.m4s/g.exec(request.url);

            if (urlIndex && urlIndex.length === 2) {
                var segment = {
                    index: +urlIndex[1],
                    start: chunk.start
                };

                if (subsItem.active) {
                    subsItem.loadQueue.push(segment);
                    if (subsItem.loadQueue.length == 1) {
                        loadSubtitleChunk(subsItem);
                    }
                } else {
                    subsItem.unloadedSegments.push(segment);
                }
            }
        },
        loadHLSsubs:function(time) {
            var subsItem = this;

            var segment = {
                index: Math.floor(time / 3.84),
                start: time - (time % 3.84)
            };
            
            if (subsItem.active) {
                subsItem.loadQueue.push(segment);
                if (subsItem.loadQueue.length == 1) {
                    loadSubtitleChunk(subsItem);
                }
            } else {
                subsItem.unloadedSegments.push(segment);
            } 

        },
        off: function() {
            var subsItem = this;
            subsItem.active = false;
            subsItem.loadQueue = [];
            subsItem.loadedCallback = null;
            subsItem.errorCallback = null;
        }
    };

    return LiveSubtitlesItem;
})();
/**
 * Data structure for storing media item information
 *
 */
var MediaItem = (function() {
    /**
     * Constructor for MediaItem class
     *
     */

    function isProgramme(str) {
        return str == 'programme' || str == 'radioProgramme' || str == 'audio' || str == 'video' || str == 'trailer' || str == '360';
    }

    function isIdent(str) {
        return str == 'ident';
    }

    function isIdentOrWarning(str) {
        return str == 'ident' || str=='warning';
    }

    function getGettersAndSetters(mediaItem) {
        return {
           startTime : {
                get : function() {
                    return mediaItem._startTime;
                }
            },
            changeEvent: {
                get : function() {
                    return mediaItem.annotateEvent({type:"mediaItemChanged"});
                }
            },
            failSilent: {
                get : function() {
                    return (mediaItem.failureMode == MediaItem.SILENT || mediaItem.failureMode == MediaItem.FAST_SILENT);
                }
            },
            failFast: {
                get : function() {
                    return (mediaItem.failureMode == MediaItem.FAST || mediaItem.failureMode == MediaItem.FAST_SILENT);
                }
            }
        };
    }
    var MediaItem = function(mediatorIdentifier, itemVersionId, itemServiceId, itemVpid, itemId, itemKind, itemLive, itemSimulcast, mediaConnections, mediaCaptionsHref, thumbManifestHref, itemGroup, itemAlternate, itemCvId) {
		var mediaItem = this;
        mediaItem.identifier = mediatorIdentifier;
        mediaItem.versionID = itemVersionId;
        mediaItem.serviceID = itemServiceId;
        mediaItem.cvid = itemCvId;
        mediaItem.vpid = itemVpid;
        mediaItem.id = itemId;
		mediaItem.kind = itemKind;
		mediaItem.live = itemLive;
		mediaItem.simulcast = itemSimulcast;

		mediaItem.type = (itemKind == "360") ? "360" : (itemKind == "audio" || itemKind == "radioProgramme") ? "audio" : "video";

        mediaItem.itemGroup = itemGroup;
        mediaItem._startTime = 0;
        mediaItem.itemAlternate = itemAlternate;
        mediaItem.isProgramme = isProgramme(itemKind);
        mediaItem.isIdent = isIdent(itemKind);
        mediaItem.isIdentOrWarning = isIdentOrWarning(itemKind);
        mediaItem.connections = mediaConnections;
        mediaItem.originalConnections = Utils.clone(mediaConnections);
        mediaItem.thumbManifestHref = thumbManifestHref;

        mediaItem.mediationAttempted = true;
        mediaItem.failureMode = (mediaItem.isIdent ? MediaItem.FAST : MediaItem.NORMAL);

        mediaItem.subtitleConnections = [];
        mediaItem.thumbnailConnections = [];
        mediaItem.failedConnections = [];

        if (mediaCaptionsHref) {
            mediaItem.subtitleConnections.push(new SubtitlesItem(mediaCaptionsHref, null));
        }

        Utils.defineProperties(mediaItem,getGettersAndSetters(mediaItem));

		return mediaItem;
    };

    MediaItem.NORMAL = "normal";
    MediaItem.FAST = "fast";
    MediaItem.FAST_SILENT = "fastsilent";
    MediaItem.SILENT = "silent";

    function cp(fromObj,toObj) {
        toObj.kind = fromObj.kind;
        toObj.identifier = fromObj.identifier;
        toObj.isLive = !!fromObj.live;
        toObj.duration = fromObj.duration;
        toObj.simulcast = !!fromObj.simulcast;
        toObj.versionID = fromObj.versionID;
        toObj.serviceID = fromObj.serviceID;
        toObj.type = toObj.type || fromObj.type;
        var subtitles = fromObj.getSubtitlesOfKind("subtitles");
        toObj.captionsURL = subtitles.length > 0 ? subtitles[0].href : null;//the subtitle href that is returned when settings are at default.
        toObj.captionsList = fromObj.subtitleConnections;//All possible subtitles.
        toObj.thumbnailList = fromObj.thumbnailConnections;
        return toObj;
    }

	MediaItem.prototype = {
        annotateEvent : function(event) {
            var mediaItem = this;
            cp(mediaItem,event);
            event.mediaItem = cp(mediaItem,{});
            return event;
        },
        addFailedConnection: function(str) {
            var mediaItem = this;
            if (DEBUG_FULL) {
                console.info("connection:"+str+" is being marked as failed");
            }
            mediaItem.failedConnections.push(str);
                           if (DEBUG_FULL) {
                               console.info(mediaItem.failedConnections);
                           }

            setTimeout(function() {

                           if (DEBUG_FULL) {
                               console.info("connection:"+str+" is being marked as as okay again.");
                           }
                           mediaItem.failedConnections=mediaItem.failedConnections.filter(function(item) { return item!=str; });

                           if (DEBUG_FULL) {
                               console.info(mediaItem.failedConnections);
                           }


                       },120000);

        },
        getSubtitlesOfKind : function(kind) {
            var mediaItem = this;
            if (mediaItem.subtitleConnections.length > 0) {
                var filtered = mediaItem.subtitleConnections.filter(function(subtitleItem) {return subtitleItem.kind == kind;});
                if(filtered.length > 0) {
                    return filtered;
                } else {
                    return mediaItem.subtitleConnections;
                }
            }

            return [];
        },
        // Also gets the bitrates
        getRewindWindow: function(callback) {
            var mediaItem=this;
            if (!mediaItem.gotWindow && mediaItem.connections[0].format=='hls') {
                mediaItem.gotWindow = true;
                var url = mediaItem.connections[0].href;
                var baseHref=url.substring(0,url.lastIndexOf('/')+1);

                if (DEBUG_FULL) { console.log("requesting:"+url);}
                if (DEBUG_FULL) { console.log("baseHref:"+baseHref);}

                var xhr=new XMLHttpRequest();
                xhr.open("GET",url, true);
                xhr.onerror = function() {
                    // XXX: Why don't we log this to rdot or something?
                    if (DEBUG_FULL) { console.log("XHR ERROR:"+xhr.status+" / "+xhr.statusText);}
                };
                xhr.onload = function() {
                    mediaItem.bitratesMap = {};
                    var filename="";
                    var arr=(xhr.responseText+"").split('\n');
                    var resolution;
                    var bitrate;
                    for (var i=0;i<arr.length-1;i++) {

                        if (arr[i].indexOf('#EXT-X-STREAM-INF:')!=-1) {
                            filename=decodeURIComponent((arr[i+1]).trim());
                            if (arr[i].indexOf('BANDWIDTH=') != -1 && arr[i].indexOf('RESOLUTION=') != -1) {
                                resolution = arr[i].match('RESOLUTION=([0-9]*)')[1];
                                bitrate = Math.round(parseInt(arr[i].match('BANDWIDTH=([0-9]*)')[1]) / 1000);
                                mediaItem.bitratesMap[resolution] = bitrate;
                            }
                        }
                    }
                    if (filename!=="") {
                        var xhr2=new XMLHttpRequest();
                        // if it's not an http url, add the base href in
                        if (filename.indexOf('http')!==0) {
                            filename=baseHref+filename;
                        }

                        if (DEBUG_FULL) { console.log("requesting: "+filename); }
                        xhr2.open("GET", filename, true);
                        xhr2.onload=function() {
                            arr=(xhr2.responseText+"").split('\n');
                            var start = 0;
                            for (var i=0;i<arr.length-1;i++) {
                                var arri=arr[i];
                                var line = arri.split('#EXT-X-PROGRAM-DATE-TIME:')[1];
                                if (line) {
                                    if (!start) {
                                        start=Utils.parseISODate(line.trim());
                                    } else {
                                        if (DEBUG_FULL) { console.log("multiple EXT-X-PROGRAM-DATE-TIME's found, discontinuity"); }
                                    }
                                }
                            }
                            if ( start ) {
                                start = start.valueOf();
                                if (isNaN(start)) {
                                    start = 0;
                                }
                                mediaItem._startTime = start/1000;
                                callback();
                            } else {
                                if (DEBUG_FULL) { console.log("no #EXT-X-PROGRAM-DATE-TIME found");  }
                            }
                        };
                        xhr2.send(null);
                    }
                };
                xhr.send(null);
            }
        },
        startLiveHLSsubs : function(player) {
            var mediaItem = this;

            if (mediaItem.connections[0].format=='hls') {

                var url = mediaItem.connections[0].href;
                var xhr = new XMLHttpRequest();
                xhr.open('GET', url, true);

                xhr.onerror = function() {
                    if (DEBUG_FULL) { console.log("XHR ERROR:"+xhr.status+" / "+xhr.statusText);}
                };

                xhr.onload = function() {
                    var arr = (xhr.responseText+"").split('\n');
                    var sampleURL = arr[3];
                    mediaItem.liveSubsItem = new LiveSubtitlesItem(sampleURL,true);
                    mediaItem.subtitleConnections.push(mediaItem.liveSubsItem);
                    player.Subtitles.considerHLSdelay = true;
                    player.Subtitles.load();
                    player.ui.updateLayout();
                };

                xhr.send(null);
            }

        }
	};

    return MediaItem;
})();
/**
 * Retreives and parses playlists
 *
 */
var Playlist = (function() {

    function getGettersAndSetters() {
        return {
           onlyAdverts : {
                get : function() {
                    for (var i=0;i<this.items.length;i++) {
                        if (this.items[i].kind!=="advert") {
                            return false;
                        }
                    }
                    return true;
                }

           },
           hasAds : {
                get : function() {
                    for (var i=0;i<this.items.length;i++) {
                        if (this.items[i].kind=="advert") {
                            return true;
                        }
                    }
                    return false;
                }
            },
            mediaType : {
                get : function() {
                    // returns the mediaType of the first programme.
                    for (var i=0;i<this.items.length;i++) {
                        if (this.items[i].isProgramme) {
                            return this.items[i].type;
                        }
                    }
                    return "video";
                }
            },
            firstProgramme : {
                get : function() {
                    //return index of first programme
                    for (var i=0;i<this.items.length;i++) {
                        if (this.items[i].isProgramme) {
                            return i;
                        }
                    }
                    return 0;
                }
            }
        };
    }

    function getFromListWithAttribute(els,attribute,value,property) {
        if (els) {
            for (var i=0;i<els.length;i++) {
                if (els[i].getAttribute(attribute)==value) {
                    if (!property) {
                        return els[i];
                    }
                    return els[i].getAttribute(property);
                }
            }
        }
    }

    function getSingleItemValue(el,id,attribute,defaultValue) {
        var els=el.getElementsByTagName(id);
        if (els.length) {
            if (attribute) {
                return els[0].getAttribute(attribute);
            }
            return els[0].textContent || els[0].nodeValue;
        }
        return defaultValue || "";
    }

    function getLowerCaseAttribute(el,attribute,defaultValue) {
        var val = el.getAttribute(attribute);
        if (val) {
            return val.toLowerCase();
        }
        return defaultValue;
    }
    function getAttributeNumber(el,attribute,defaultValue) {
        var val = getLowerCaseAttribute(el,attribute,defaultValue);
        if (isNaN(val)) {
            return 0;
        }
        return val;
    }

    var upgradeMatches=[/meta\/dps/,/playlists\.bbc\.co\.uk/i,/news.bbc.co.uk\/media\/emp/i];
    function upgradeUrl(url) {
        if (url && url.replace) {
            if ((location.protocol + '').toLowerCase() === 'https:') {
                if (url.indexOf('http://')===0) {
                    for (var i=0;i<upgradeMatches.length;i++) {
                        if (upgradeMatches[i].test(url)) { 
                            return url.replace("http://","https://");
                        }
                    }
                }
            }
        }
        return url;
    }

    function upgradeiChef(url) {
        if (url && url.replace) {
            return url.replace("http://ichef.bbci.co.uk","https://ichef.bbci.co.uk").replace("http://newsimg","https://newsimg");
        }
        return url;
    }

    /**
     * Parse a playlist and populate this instance
     *
     */
    function parseXML(playlist, xmlDoc) {
        if(xmlDoc.getElementsByTagName('parsererror').length) {
            throw {
                'message' : 'invalid/incomplete playlist xml'
            };
        }

        var links = xmlDoc.getElementsByTagName('link');
        var items =  xmlDoc.getElementsByTagName('item');

        playlist.id = getSingleItemValue(xmlDoc,"id");
        playlist.title = getSingleItemValue(xmlDoc,"title");
        playlist.summary = getSingleItemValue(xmlDoc,"summary");
        playlist.updated = getSingleItemValue(xmlDoc,"updated");
        playlist.noItemsReason = getSingleItemValue(xmlDoc,"noItems","reason");
        playlist.guidance = getSingleItemValue(xmlDoc,"guidance");
        playlist.warning = getSingleItemValue(xmlDoc,"warning");
        playlist.posterImg = upgradeiChef(getFromListWithAttribute(links,"rel","holding","href"));
        playlist.posterRecipe = upgradeiChef(getFromListWithAttribute(links,"rel","holdingrecipe","href"));
        playlist.alternateHref = getFromListWithAttribute(links,"rel","alternate","href");

        if(getSingleItemValue(xmlDoc,'right', 'name') === "embed"){
            var right = getSingleItemValue(xmlDoc,'right');
            playlist.embedRights = right;
            playlist.embedRight = (right=="true" || right=="allowed");
        }

        var relatedLinks =  xmlDoc.getElementsByTagName('relatedLink');
        for (var i=0;i<relatedLinks.length;i++) {
            var lnk = relatedLinks[i];
            var lnkSummary = getSingleItemValue(lnk,"summary");
            var lnkTitle = getSingleItemValue(lnk,"title",false,lnkSummary);
            var href = getFromListWithAttribute(links,"rel","alternate","href");
            if(lnkTitle && href) {
                var lnks=lnk.getElementsByTagName('link');
                var img = getFromListWithAttribute(lnks,"rel","thumb");
                var thumb = (img ? {href : img.getAttribute('href'), width : img.getAttribute('width'), height : img.getAttribute('height')} : null);
                playlist.relatedLinks.push({
                        title : lnkTitle,
                        summary : lnkSummary,
                        href : href,
                        thumb : thumb
                });
            }
        }
        var programmeFound = false;
        // iterate over items in playlist
        for (i=0;i<items.length;i++) {
            var item = items[i];
            var med = null;
            var itemId = getSingleItemValue(item,"id");
            var itemKind = item.getAttribute('kind');
            var itemLive = item.getAttribute('live')=='true';
            var itemSimulcast = item.getAttribute('simulcast') == 'true';
            var itemGroup = item.getAttribute('group');

            var itemAlternate = getSingleItemValue(item,"alternate","id");

            var mediaType = '';
            var mediaConnections = [];
            var mediaCaptionsHref = '';

            var mediatorIdentifier = getSingleItemValue(item,"mediator","identifier");
            if(mediatorIdentifier) {// mediator
                med = new MediaItem(mediatorIdentifier,
                                        null,
                                        null,
                                        itemId,
                                        itemId,
                                        itemKind,
                                        itemLive,
                                        itemSimulcast,
                                        [],
                                        null,
                                        null,
                                        itemGroup,
                                        itemAlternate,
                                        null
                );
                med.mediationAttempted = false;
            } else {
                var mediaItems = item.getElementsByTagName('media');
                for (var j=0;j<mediaItems.length;j++) {
                    var media = mediaItems[j];
                    mediaType = media.getAttribute('kind');
                    var connections = media.getElementsByTagName('connection');
                    for (var k=0;k<connections.length;k++) {
                        var connection = connections[k];
                        if (mediaType == "audio" || mediaType == "video") {
                            if (mediaType == "audio" && itemKind == "programme") {
                                itemKind = "radioProgramme";
                            }
                            href=connection.getAttribute('href');
                            mediaConnections.push({
                                href : href,
                                protocol : getLowerCaseAttribute(connection,"protocol"),
                                mimetype : getLowerCaseAttribute(media,"type"),
                                encoding : getLowerCaseAttribute(media,"encoding"),
                                format : getLowerCaseAttribute(connection,'transferFormat','plain'),
                                supplier : getLowerCaseAttribute(connection,'supplier'),
                                bitrate : getAttributeNumber(media,"bitrate")
                            });
                        } else {
                            if (mediaType == 'captions') {
                                mediaCaptionsHref = connection.getAttribute('href');
                            }
                        }
                    }
                }
                if(mediaConnections.length) {
                    med = new MediaItem(
                        "", /* What Identifier? */
                        null,
                        null,
                        null,
                        itemId,
                        itemKind,
                        itemLive,
                        itemSimulcast,
                        mediaConnections,
                        mediaCaptionsHref,
                        null,
                        itemGroup,
                        itemAlternate,
                        null
                    );
                    med.flashAvailable =  LoadBalancing.getFlashAvailable(mediaConnections);
                    med.flashAvailableUnlocked = LoadBalancing.getFlashAvailable(mediaConnections,true); 
                    LoadBalancing.validateConnections(med);                

                    med.fallbackPlaylist = playlist.url;
                }
            }

            if (med) {
                playlist.addItem(med);
                if (med.isProgramme && !programmeFound) {
                    programmeFound = true;
                    playlist.isRadio = med.type=="audio";
                    playlist.groupId = med.itemGroup;
                    playlist.identifier = (item.getAttribute('identifier') || '');
                    var masterbrand = item.getElementsByTagName('masterbrand');
                    if (masterbrand.length) {
                        masterbrand = masterbrand[0];
                        playlist.masterbrand =  {
                            id : masterbrand.getAttribute('id'),
                            href : masterbrand.getAttribute('href'),
                            title : masterbrand.textContent || masterbrand.nodeValue
                        };
                    }
                }
            }
        }
        filterAlternateIds(playlist);
    }

    function filterAlternateIds(playlist) {
        var items = playlist.items;
        var groups = [];
        var groupParts = {};
        for (var i=0;i<items.length;i++) {
            var grp = items[i].itemGroup;
            if (grp && grp!=="") {
                if (!groupParts[grp]) {
                    groupParts[grp]=[];
                    groups.push(grp);
                }
                groupParts[grp].push(i);
            }
        }
        var strip = [];
        for (i=0;i<groups.length;i++) {
            grp = groups[i];
            var gr = groupParts[grp];
            if (gr.length>1) {
                for (var j=0;j<gr.length;j++) {
                    var item = items[gr[j]];
                    if (item.itemAlternate!="default") {
                        strip.push(gr[j]);
                    }
                }
            }
        }
        strip.sort();
        for (i=strip.length-1;i>=0;i--) {
            playlist.items.splice(strip[i],1);
        }
    }

    function playlistDefaultValues(playlist){
        playlist.id = '';
        playlist.title = '';
        playlist.summary = '';
        playlist.updated = '';
        playlist.posterImg = '';
        playlist.noItemsReason = '';
        playlist.guidance = '';
        playlist.warning = '';
        playlist.groupId = '';
        playlist.identifier = '';
        playlist.isRadio = false;
        playlist.masterbrand = {};
        playlist.relatedLinks = [];
        playlist.items = [];
        playlist.hasLive = false;
    }

    function updateFromConfig(playlist, config){
        if (playlist.guidance === "" && config.forceGuidance) {
            playlist.guidance = config.forceGuidance;
        }
        if (config.overrideHoldingImage) {
            playlist.posterRecipe = config.overrideHoldingImage;
        }
        if (config.overrideCtaDuration) {
            playlist.programmeDuration = config.overrideCtaDuration;
        }
    }

    function updateProgrammeInfo(playlist) {
        for (var i = 0; i < playlist.items.length; i++) {
            var item = playlist.items[i];

            if(item.live) {
                playlist.hasLive = true;
            }

            if (item.isProgramme) {
                if (item.duration && !item.live) {
                    playlist.programmeDuration = Utils.secondsToTime(item.duration);
                }
                break;
            }
        }
    }

    function addConnection(hrefItem) {
        if (hrefItem) {
            this.push({ href: hrefItem.url, format:hrefItem.format, protocol:"http", supplier:hrefItem.supplier });
        }
    }

    function testValid(str) {
        if (str) {
            if (str!="undefined" && (str+"").match(/^[a-z0-9_]+$/)) {
                return true;
            }
        }
        return false;
    }

    function getMediatorID(item) {
        if (testValid(item.versionID)) {
            return item.versionID;
        }

        if (item.serviceID) {
            return item.serviceID;
        }

        if (testValid(item.vpid)) {
            return item.vpid;
        }

        if (item.cvid) {
            return "CVID:"+item.cvid;
        }

        return null;
    }

    function inHttpsWhitelist(mediatorID, whitelist) {
        if (mediatorID) {
            if (whitelist && whitelist.indexOf(mediatorID) >= 0) {
                return true;
            }
        }

        return false;
    }


    function parsePlaylistObject(playlist, playlistObject, playerConfig) {
        playlist.title = playlistObject.title || "";
        playlist.guidance = playlistObject.guidance || "";
        playlist.warning = playlistObject.warning || "";
        playlist.posterImg = playlist.holdingImageURL = playlistObject.holdingImageURL || "";
        playlist.videoHoldingImage = playlistObject.videoHoldingImage || "";
        playlist.summary = playlistObject.summary || "";
        playlist.liveRewind = playlistObject.liveRewind !== false;
        playlist.embedRights = playlistObject.embedRights || "";
        playlist.embedRight = (playlist.embedRights == "true" ||  playlist.embedRights == "allowed");
        playlist.allowContinuousCast = playlistObject.allowContinuousCast || false;

        if (playlistObject.masterBrandName) {
            playlist.masterbrand = {
                title : playlistObject.masterBrandName
            };
        }

        if (playlistObject.items) {
            for (var i = 0; i < playlistObject.items.length; i++) {

                var mediaItem;
                if (playlistObject.items[i].createdItem) {
                    mediaItem = playlistObject.items[i].createdItem;
                } else {
                    mediaItem = playlist.createMediaItem(playlistObject, i, playerConfig);
                }

                if(mediaItem) {

                    if (mediaItem.simulcast) {
                        playlistObject.simulcast = true;
                    }

                    var parentPID = "0";

                    if (playerConfig.statsObject) {
                        if (playerConfig.statsObject.parentPID) {
                            parentPID = playerConfig.statsObject.parentPID;
                        }

                        if (playerConfig.statsObject.episodePID) {
                            parentPID = playerConfig.statsObject.episodePID;
                        }

                        if (playerConfig.statsObject.clipPID) {
                            parentPID = playerConfig.statsObject.clipPID;
                        }
                    }

                    var assetIdentifier = parentPID;

                    // Add groupID, asset identifier 'I' for stats
                    if (mediaItem.live && assetIdentifier == "0") {
                        assetIdentifier = mediaItem.identifier;
                    }

                    mediaItem.itemGroup = assetIdentifier;

                    // Again this is for playlistobject only
                    playlist.groupId = assetIdentifier;


                    playlist.addItem(mediaItem);

                }

            }
        }

        playlist.queuedPlaylist = playlistObject.queuedPlaylist;
        playlist.queuedOptions = playlistObject.queuedOptions;

        if (playlist.items.length===0) {
            if (playlistObject.noItemsReason) {
                playlist.noItemsReason = playlistObject.noItemsReason;
            } else {
                playlist.noItemsReason = "EmptyPlaylistObject"+(playlist.filteredItem ? "Filtered":"");
            }
        }
    }

    /**
     * Constructor for Playlist class
     *
     */
    function Playlist(url, successCallback, errorCallback, playlistObject, config) {
        var playlist = this;

        Utils.defineProperties(playlist,getGettersAndSetters(playlist));

        playlist.suppressItemKind = config.suppressItemKind || [];
        playlist.programmeDuration = "";

        playlistDefaultValues(playlist);

        playlist.filterIdentAndWarning = (config.startTime>0);

        if (playlistObject) {
            parsePlaylistObject(this, playlistObject, config);
            updateProgrammeInfo(playlist);
            updateFromConfig(playlist, config);
            // playlist loading cannot be sync or events become unordered
            Utils.asyncDelay(successCallback);
        } else {

            url=upgradeUrl(url);

            playlist.url = url;

            var error = function(href,parsing) {
                var er = parsing ? SMPError.ERROR_PARSING_PLAYLIST : SMPError.ERROR_LOADING_PLAYLIST;
                var errorObj = SMPError.getError(er);
                errorObj.extra = url;
                errorCallback(errorObj);
            };

            var callback = function(xmldoc) {
                try {
                    parseXML(playlist,xmldoc);
                } catch (e) {
                    if (DEBUG_FULL) { console.log("Playlist: Error parsing:",e); }
                    error(url,true);
                    return;
                }
                updateFromConfig(playlist, config);
                updateProgrammeInfo(playlist);
                successCallback();
            };
            Utils.asyncDelay(function() {
                                 Utils.getXML(url, callback, error, playlist,false,config.setWithCredentials);
                             });
        }
        return playlist;
    }

    Playlist.prototype = {
        getNextItem : function(index) {
            var playlist = this;
            if (playlist.items) {
                //return index of first programme
                for (var i=index+1;i<playlist.items.length;i++) {
                    if (playlist.items[i] && playlist.items[i].kind !== 'advert') {
                        return playlist.items[i];
                    }
                }
            }
            return null;
        },
        getPreviousItemIndex : function(index) {
            var playlist = this;
            if (playlist.items) {
                //return index of first programme
                for (var i=index-1;i>=0;i--) {
                    if (playlist.items[i] && playlist.items[i].kind !== 'advert') {
                        return i;
                    }
                }
            }
            return null;
        },
        addItem : function(item) {
            var playlist = this;
            var filter = false;
            if (item.kind!="advert" && item.kind!="ad") {
                filter = (playlist.filterIdentAndWarning && (item.kind=="ident" || item.kind=="warning")) || (playlist.suppressItemKind.indexOf(item.kind)>-1);
                filter=filter || (item.mediationAttempted===false && (item.identifier=="null" || item.identifier=="undefined"));
            }
            if (filter) {
                playlist.filteredItem=true;
                if (DEBUG_FULL) { console.info('item kind:'+item.kind+" suppressed by suppressItemKind", item); }
            } else {
                playlist.items.push(item);
            }
        },

        createMediaItem : function(playlistObject, i, playerConfig) {

            var item = playlistObject.items[i];
            var simulcast = playlistObject.simulcast;

            var mediatorID = getMediatorID(item);
            if (item.serviceID && mediatorID === item.serviceID) {
                //if the mediatorID used is the serviceID set live
                //to true and simulcast to true unless they are explicitly
                //set simulcast to false
                item.live = true;
                if (simulcast !== false) {
                    simulcast = true;
                }
            }

            if (mediatorID) {//mediator
                var med = new MediaItem(mediatorID+"",
                    item.versionID,
                    item.serviceID,
                    item.vpid,
                    item.id,
                    item.kind || "programme",
                    item.live,
                    simulcast,
                    [],
                    null,
                    null,
                    null,
                    null,
                    item.cvid
                );
                med.preferProtocol = inHttpsWhitelist(mediatorID, playerConfig.httpsVpids) ? 'https' : null;
                med.mediationAttempted = false;
                med.samltoken = item.samltoken;
                med.ceiling = item.ceiling;
                med.duration = item.duration;
                if (item.failureMode) {
                    med.failureMode = item.failureMode;
                }
                return med;
            } else {
                var connections =[];
                if (item.href) {
                    if (item.href.forEach) {
                        item.href.forEach(addConnection,connections);
                    } else {
                        connections.push({ href: item.href, format: "plain", protocol: "http"});
                    }
                }
                if (connections.length > 0 || item.kind == "advert" || item.kind == "ad") {
                    med = new MediaItem(null,
                        null,
                        null,
                        null,
                        item.id,
                        item.kind || "programme",
                        item.live,
                        simulcast,
                        connections,
                        item.captionsUrl,
                        item.thumbManifestUrl,
                        null
                    );
                    med.duration = item.duration;
                    if (item.failureMode) {
                        med.failureMode = item.failureMode;
                    }
                    if(item.kind == "ad"){
                        med.mediationAttempted = false;
                    }
                    LoadBalancing.validateConnections(med);
                    return med;
                }
            }

        }
    };


    return Playlist;
})();
/**
 * Adds support for event reporting via the iPlayerLiveStats API
 *
 */
var IStats = (function() {

    var END_EVENT = 'SonarEndEvent',
        ERROR_EVENT = 'SonarErrorEvent',
        PAUSE_EVENT = 'SonarPauseEvent',
        RESUME_EVENT = 'SonarResumeEvent',
        SEEK_EVENT = 'SonarSeekEvent',
        PLAY_EVENT = 'SonarPlayEvent';

    function getCallbackObject(istats) {
        return {
            blockUnwanted : true,
            playing : function(event) {
                if (event._.shouldReport) {
                  if (!istats.hasPlayed) {
                    istats.hasPlayed = true;
                    istats.updateStats(PLAY_EVENT);
                  } else {
                    if (istats.dispatchResume) {
                      istats.updateStats(RESUME_EVENT);
                      istats.dispatchResume = false;
                    }
                  }
                }
            },
            waiting : function(event) {
                if (event._.shouldReport) {
                    istats.dispatchResume = true;
                }
            },
            ended : function() {
                istats.hasPlayed = false;
                istats.dispatchResume = false;
            },
            playlistLoaded : function() {
                istats.hasPlayed = false;
                istats.dispatchResume = false;
            },
            pause : function(event) {
                istats.dispatchResume = false;
                istats.hasPlayed = false;
                if (event._.shouldReport && !event._.mediaPlayer.ended) {
                    istats.updateStats(PAUSE_EVENT);
                }
            },
            seeked : function(event) {
                istats.updateStats(SEEK_EVENT);
                if (!event._.paused) {
                    event._.dispatch({ type: PLAY_EVENT});
                }
            },
            playlistEnded : function() {
                istats.dispatchResume = false;
                istats.updateStats(END_EVENT);
            },
            playerDisconnected : function(event) {
                istats.dispatchResume = false;
                event._.dispatch({ type: PAUSE_EVENT});
            },
            playerDestroying : function(event) {
                event._.dispatch({ type: PAUSE_EVENT});
                istats.dispatchResume = false;
            },
            error : function(event) {
                if (event.code!=4237) {
                    istats.updateStats(ERROR_EVENT, event);
                }
            }
        };
    }

    var UNKNOWN_PLAYLIST = {mediaType:"-", groupId:"unknown", identifier:"unknown"};


    function updateStats(eventType, smpError) {
        var player = this.player;
        var mediaItem = player.mediaItem || UNKNOWN_PLAYLIST;
        var item={ type: eventType, mediaItem: mediaItem};
        if (smpError) {
          item.errorItem = smpError.toSimple();
        }
        player.dispatch(item);
    }

    /**
     * Constructor for IStats class
     *
     */
    var IStats = function(player) {
        var istats = this;
        this.player = player;
        this.eventCallbacks = getCallbackObject(this);
        this.hasPlayed = false;

        return istats;
    };

    IStats.prototype = {
        updateStats : updateStats,
    };

    return IStats;
})();
/**
 * Manages Quality of Service
 *
 */

var INFO_INTERVAL = 1000;

var QOS = (function() {

    function testCheckSendInfo(qos) {
        if (qos) {
            if (qos.lastInfoTime < (Utils.now() - qos.infoTimeMultiplier * 1000)) {
                if ( (qos.infoEventObject && qos.infoEventObject.averageBufferLength != qos.lastBufferLength) || (qos.lastInfoCurrentTime!=qos.player.time.toFixed(1)) || (qos.lastInfoBitrate != getBitrate(qos))) {
                    sendQOSInfo(qos);

                }
            }
        }
    }

    function getBitrate(qos,rendering) {
        var lastBitrate = "-";
        if (qos.infoAdapter) {
            var bitrates = qos.infoAdapter.bitrateList;
            var index;
            if (rendering) {
                index=qos.infoAdapter.bitrateIndex;
            } else {
                index = qos.infoAdapter.downloadingBitrateIndex;
            }
            if (bitrates[index]) {
                lastBitrate = bitrates[index];
            }
        }
        return lastBitrate;
    }

    var DefaultQosAdapter = (function() {
        function DefaultQosAdapter(qos) {
            this.qos = qos;
        }

        var defaultFunc = function(){};
        DefaultQosAdapter.prototype = {
            _audioBufferLength: defaultFunc,
            _bitrateIndex: defaultFunc,
            _downloadingBitrateIndex: defaultFunc,
            _bitrateList: function() {
                return [];
            },
            _bufferLength: function() {
                var player = this.qos.player;
                var buffLength = 0;
                if (player.mediaPlayer) {
                    buffLength = player.buffered - player.mediaPlayer.currentTime;
                }
                return Math.max(0,isNaN(buffLength) ? 0 : buffLength);
            },
            _currentBitsPerSecond: defaultFunc,
            _videoBufferLength: defaultFunc
        };

        Utils.defineProperties(DefaultQosAdapter.prototype, {
            audioBufferLength : {
                get: function () {
                    return this._audioBufferLength();
                }
            },
            bitrateIndex : {
                get: function() {
                    return this._bitrateIndex();
                }
            },
            downloadingBitrateIndex : {
                get: function() {
                    return this._downloadingBitrateIndex();
                }
            },
            bitrateList : {
                get: function() {
                    return this._bitrateListCached || this._bitrateList();
                }
            },
            bufferLength : {
                get: function() {
                    return this._bufferLength();
                }
            },
            currentBitsPerSecond : {
                get: function () {
                    return this._currentBitsPerSecond();
                }
            },
            videoBufferLength : {
                get: function () {
                    return this._videoBufferLength();
                }
            }
        });

        return DefaultQosAdapter;
    })();

    var DashQosAdapter = (function() {

        function DashQosAdapter(qos) {
            this.qos = qos;
        }

        DashQosAdapter.prototype = Object.create(DefaultQosAdapter.prototype);

        DashQosAdapter.prototype._audioBufferLength = function() {
            return this.qos.player.dashEvents.bufferLevel.audio;
        };
        DashQosAdapter.prototype._downloadingBitrateIndex = function() {
            if (!this.qos.player.dashEvents.dashPlayer) {
                return;
            }
            try {
                var quality = this.qos.player.dashEvents.dashPlayer.getQualityFor(this.qos.player.elType);
            } catch (e) {
                // this can error
            }
            return quality;
        };
        DashQosAdapter.prototype._bitrateIndex = function() {
            if (!this.qos.player.dashEvents.dashPlayer) {
                return;
            }
            return this.qos.player.dashEvents.currentBitrateIndex;
        };

        DashQosAdapter.prototype._bitrateList = function() {
            if (!this.qos.player.dashEvents.dashPlayer) {
                return [];
            }
            var elType = this.qos.player.elType;
            try {
                var list = this.qos.player.dashEvents.dashPlayer.getBitrateInfoListFor(elType);
            } catch (e) {
                // XXX in dash this errors if you've not done things,
                // some errors can come out here which would result in
                // no rdot message.
                return [];
            }
            var toAdd = 0;
            if (elType === 'video') {
                toAdd = this.qos.player.consideredMobileConnection ? 48 : 96;
            }

            var bitrates = [];

            if (list) {
                for (var i = 0; i < list.length; i++) {
                    bitrates.push(((list[i].bitrate / 1000) + toAdd).toFixed(0));
                }
            }
            this._bitrateListCached = bitrates;
            return bitrates;
        };

        DashQosAdapter.prototype._bufferLength = function() {
            return Math.min(this.audioBufferLength, this.videoBufferLength || Number.POSITIVE_INFINITY);
        };

        DashQosAdapter.prototype._currentBitsPerSecond = function() {
            return this.qos.player.dashEvents.currentBitsPerSecond;
        };

        DashQosAdapter.prototype._videoBufferLength = function() {
            return this.qos.player.dashEvents.bufferLevel.video;
        };

        return DashQosAdapter;
    })();

    var HlsQosAdapter = (function() {
        // Format: map.supplier_substring.videoWidth
        var hlsGuestimatedBitratesMap = {
            // Note: HLS includes 48/96 audio in all bitrates, not included here
            mf_: {
                '192': 86,
                '256': 156,
                '384': 281,
                '512': 437,
                '704': 827,
                '960': 1604
            }
        };

        function HlsQosAdapter(qos) {
            this.qos = qos;
        }

        HlsQosAdapter.prototype = Object.create(DefaultQosAdapter.prototype);

        HlsQosAdapter.prototype._bitrateIndex = function() {
            var map = this.bitrateMap;
            var player = this.qos.player;
            var width = player.mediaPlayer.videoWidth;
            var bitrateList = this.bitrateList;
            var bitrateChanges = this.qos.bitrateChanges;
            var bitrate;
            var index;
            if (!map) {
                return;
            }
            
            if (map.hasOwnProperty(width)) {
                for (var i = 0; i < this.bitrateList.length; i++) {
                    if (bitrateList[i] == map[width]) {
                        bitrate = bitrateList[i];
                        index = i;
                        break;
                    }
                }
            }

            if (!bitrateChanges.length || bitrateChanges[bitrateChanges.length-1][0] !== index) {
                player.dispatch({
                    type: 'bitrateChanged',
                    streamType: this.qos.player.elType,
                    previousBitrate: bitrateChanges.length ? bitrateList[bitrateChanges[bitrateChanges.length-1][0]] : 0,
                    newBitrate: bitrate,
                    newIndex: index
                });

                player.dispatch({
                    type: 'loadedmetadata',
                    bitrate: bitrate,
                    cdn: this.qos.currentSupplier
                });
            }

            return index;
        };

        HlsQosAdapter.prototype._currentBitsPerSecond = function() {
            var bitrateList = this.bitrateList;
            var bitrateChanges = this.qos.bitrateChanges;
            if (bitrateChanges.length>0) {
                return bitrateList[bitrateChanges[bitrateChanges.length-1][0]];
            }
        };


        HlsQosAdapter.prototype._bitrateList = function() {
            var map = this.bitrateMap;
            var list = [];

            if (map) {
                for (var bitrate in map) {
                    if (map.hasOwnProperty(bitrate)) {
                        list.push(map[bitrate]);
                    }
                }

                return list;
            }
        };

        Utils.defineProperties(HlsQosAdapter.prototype, {
            bitrateMap : {
                get: function () {
                    var mediaItem = this.qos.player.mediaItem;
                    // bitratesMap is populated for live streams
                    if (mediaItem && mediaItem.bitratesMap) {
                        return mediaItem.bitratesMap;
                    } else {
                        for (var supplier in hlsGuestimatedBitratesMap) {
                            if ((this.qos.currentSupplier + '').indexOf(supplier) !== -1) {
                                return hlsGuestimatedBitratesMap[supplier];
                            }
                        }
                    }
                    return {};
                }
            }
        });

        return HlsQosAdapter;
    })();



    function sendQOSInfo(qos) {
        if (qos.infoEventObject && qos.infoAdapter) {
            var bitrates = qos.infoAdapter.bitrateList;
            if (bitrates.length) {
                var arr = [];
                arr.push(qos.getMediaType());
                arr.push(bitrates.join('~'));
                arr.push(getTimeSpent(qos).join('~'));
                arr.push(getDroppedFrames(qos).join('~') || '-');
                arr.push(qos.infoEventObject.droppedFrames);
                arr.push(qos.infoEventObject.droppedFrames);
                arr.push(qos.timeSpentTotal.join('~'));
                arr.push(qos.droppedFramesTotal.join('~') || '-');
                var startupTime =  qos.startupTime ? qos.startupTime.toFixed(0) : 0;

                qos.lastBufferLength = qos.infoEventObject.averageBufferLength;

                arr.push(startupTime);
                
                qos.lastInfoCurrentTime = qos.player.time.toFixed(1);

                arr.push(getBitrateChanges(qos).join('~'));

                qos.lastInfoTime = Utils.now();
                qos.infoTimeMultiplier = 60;

                var qosInfo =  arr.join('/');
                
                // baa - see
                // https://confluence.dev.bbc.co.uk/display/mystats/rDot+Common+AV+Reporting+Format
                RDotReporting.trackQOSInfo(qosInfo, "baa");
            }
        }
    }

    function getBitrateChanges(qos) {
        var arr = [];
        for (var i = Math.max( 0, qos.bitrateChanges.length - 5 ); i < qos.bitrateChanges.length; i++) {
            arr.push(qos.bitrateChanges[i].join(','));
        }
        return arr;
    }

    function getTimeSpent(qos) {
        if (!qos.infoAdapter) {
            return [];
        }
        var bitrateList = qos.infoAdapter.bitrateList;
        // timeSpent bitrate index is matched to timeSpentTotal's here
        var arr = [];
        for (var i = 0; i < bitrateList.length; i++) {
            var time = qos.timeSpent[i] || 0;
            arr.push(time);
            if (!qos.timeSpentTotal[i]) {
                qos.timeSpentTotal[i] = time;
            } else {
                qos.timeSpentTotal[i] += time;
            }
        }
        qos.timeSpent = [];
        return arr;
    }

    function getDroppedFrames(qos) {
        var arr = [];
        for (var i = 0; i < qos.droppedFramesArray.length; i++) {
            arr.push(qos.droppedFramesArray[i] || 0);
            if (!qos.droppedFramesTotal[i]) {
                qos.droppedFramesTotal[i] = qos.droppedFramesArray[i] || 0;
            } else {
                qos.droppedFramesTotal[i] += qos.droppedFramesArray[i] || 0;
            }
        }
        qos.droppedFramesArray = [];
        return arr;
    }

    function softReset(qos) {
        qos.infoAdapter = null;
        qos.currentFormat = null;
        qos.timeSpent = [];
        qos.timeSpentTotal = [];
        qos.bitrateChanges = [];
        qos.infoEventObject = null;
        qos.lastInfoTime = -999999;
    }

    function qos_getCallbackObject(qos) {

        return {
            blockUnwanted : true,
            error : function(e) {
                var mediaItem = qos.player.mediaItem;
                var obj = {};
                if (e.extra && typeof e.extra=='string') {
                    obj.bbc_smp_detail = e.extra;
                }
                obj.is_background = true;
                qos.player.trackAction('error_' + e.code,"error",obj);

                if (e.code==1065 || e.code==1066 || e.code==1003) {
                    if (!e.extra) {
                        var url = (qos.player.config.embedPageURL+'').match(/[^\?]*/);
                        if (url) {
                            e.extra = url[0];
                        }
                    }
                }

                RDotReporting.trackError(e,mediaItem);
                var reportData=[];
                if (e.code==4200) {
                    try {
                        var dashPlayer=qos.player.dashEvents.dashPlayer;
                        var metrics=dashPlayer.getMetricsFor('stream');
                        var streamHttp=metrics.HttpList;
                    } catch (err) {
                        streamHttp=[];
                    }
                    for (var j=streamHttp.length-1;j>-1;j--) {
                        if (streamHttp[j].url==e.extra) {
                            reportData.push(e.extra);
                            reportData.push(streamHttp[j].responsecode);
                            reportData.push(streamHttp[j]._responseHeaders);
                            break;
                        }
                    }
                    RDotReporting.trackError({code:5022,severity:'i',extra:reportData.join('_')},mediaItem);
                }

                if ((e.code==5003 || e.code==5004) && qos.player.isPlayingDash) {
                    try {
                        // if we have a decode error find out more about it.
                        var currentTime=qos.player.mediaPlayer.currentTime;
                        dashPlayer=qos.player.dashEvents.dashPlayer;
                        try {
                            metrics=dashPlayer.getMetricsFor('audio');
                            var audioHttp=metrics.HttpList;
                            var audioReq=metrics.RequestsQueue.executedRequests;
                        } catch (err) {
                            audioHttp=[];
                            audioReq=[];
                        }
                        try {
                            metrics=dashPlayer.getMetricsFor('video');
                            var videoHttp=metrics.HttpList;
                            var videoReq=metrics.RequestsQueue.executedRequests;
                        } catch (err) {
                            videoHttp=[];
                            videoReq=[];
                        }
                        for (var i=0;i<audioReq.length;i++) {
                            var req=audioReq[i];
                            if (currentTime>=req.startTime && currentTime<req.startTime+req.duration) {
                                reportData.push(req.url);
                                for (j=audioHttp.length-1;j>-1;j--) {
                                    if (audioHttp[j].url==req.url) {
                                        reportData.push(audioHttp[j]._responseHeaders);
                                        reportData.push(audioHttp[j].responsecode);
                                        reportData.push(req.bytesLoaded);
                                        reportData.push(req.bytesTotal);
                                        break;
                                    }
                                }
                                break;
                            }
                        }
                        for (i=0;i<videoReq.length;i++) {
                            req=videoReq[i];
                            if (currentTime>=req.startTime && currentTime<req.startTime+req.duration) {
                                reportData.push(req.url);
                                for (j=videoHttp.length-1;j>-1;j--) {
                                    if (videoHttp[j].url==req.url) {
                                        reportData.push(videoHttp[j]._responseHeaders);
                                        reportData.push(videoHttp[j].responsecode);
                                        reportData.push(req.bytesLoaded);
                                        reportData.push(req.bytesTotal);
                                        break;
                                    }
                                }
                            }
                        }
                        RDotReporting.trackError({code:5020,severity:'i',extra:reportData.join('_')},mediaItem);
                    } catch (err) {
                        if (DEBUG_FULL) {
                            console.log("Error getting DASH metrics for failed fragment",err);
                        }
                    }
                }
            },

            info : function(e) {
                var bitrateIndex = (qos.infoAdapter && qos.infoAdapter.bitrateIndex) || 0;
                var previousDroppedFrames = qos.infoEventObject ? qos.infoEventObject.droppedFrames : 0;

                if (!qos.timeSpent[bitrateIndex]) {
                    qos.timeSpent[bitrateIndex] = INFO_INTERVAL/1000;
                } else {
                    qos.timeSpent[bitrateIndex] += INFO_INTERVAL/1000;
                }

                if (e.droppedFrames > previousDroppedFrames) {
                    if (!qos.droppedFramesArray[bitrateIndex]) {
                        qos.droppedFramesArray[bitrateIndex] = e.droppedFrames - previousDroppedFrames;
                    } else {
                        qos.droppedFramesArray[bitrateIndex] += e.droppedFrames - previousDroppedFrames;
                    }
                }

                qos.infoEventObject = e;
            },

            mediaItemChanged: function() {
                softReset(qos);
            },

            changingsrc : function(e) {
                if (qos.currentSupplier!== e.supplier){
                    qos.currentSupplier = e.supplier;
                }

                if (qos.currentFormat !== e.format) {
                    // Drop data that may not relate between formats
                    softReset(qos);
                    qos.currentFormat = e.format;
                    if (qos.currentFormat === 'hls') {
                        qos.infoAdapter = new HlsQosAdapter(qos);
                    } else {
                        if (qos.currentFormat === 'dash') {
                            qos.infoAdapter = new DashQosAdapter(qos);
                        } else {
                            qos.infoAdapter = new DefaultQosAdapter(qos);
                        }
                    }
                }
            },
            timeupdate: function() {
                testCheckSendInfo(qos);
                if (!qos.sentPS) {
                    if (qos.firstPSTime===undefined) {
                        qos.firstPSTime = qos.player.time;
                    } else {
                        if (qos.firstPSTime!=qos.player.time) {
                            RDotReporting.trackPlaySuccess();
                            qos.sentPS = true;
                            if (qos.infoAdapter && qos.infoAdapter._bitrateList) {
                                // XXX need to cache the bitrate list
                                qos.infoAdapter._bitrateList();
                            }
                        }
                    }
                }
            },
            bitrateChanged: function(e) {
                if (e.streamType == qos.player.elType) {
                    qos.bitrateChanges.push([e.newIndex, qos.player.time.toFixed(1)]);
                }
            },
            waiting: function() {
                clearInterval(qos.updateTimer);
                clearInterval(qos.sendInfoTimer);
                qos.sendInfoTimer = setInterval(testCheckSendInfo,1000,qos);
            },
            tryingToPlay: function() {
                qos.startupStart = Utils.now();
                qos.startupTime = null;
                qos.sentPS = false;
                qos.firstPTime=undefined;
                RDotReporting.trackPlayIntent();
            },
            ended : function() {
                qos.playing = false;
                clearInterval(qos.updateTimer);
                sendQOSInfo(qos);
                qos.infoTimeMultiplier = 10;
            },
            pause : function() {
                qos.playing = false;
                clearInterval(qos.updateTimer);
                clearInterval(qos.sendInfoTimer);
                qos.sendInfoTimer = setInterval(testCheckSendInfo,1000,qos);
            },
            canplay : function() {
                if (!qos.startupTime) {
                    qos.startupTime = Utils.now() - qos.startupStart;
                    qos.timeSpentBufferingStart = 0;
                    // first timeupdate starts the 10 second timer
                    qos.lastInfoTime = Utils.now();
                    if (DEBUG_FULL) {
                        console.log("QOS: Startup Time is:"+qos.startupTime);
                    }
                }
            },
            playlistLoading : function() {
                sendQOSInfo(qos);
                qos.resetProperties();
            },
            playing : function() {
                clearInterval(qos.sendInfoTimer);
                clearInterval(qos.updateTimer);
                if (qos.player.mediaItem && !qos.player.mediaItem.useFlash) {
                    qos.updateTimer = setInterval(function() {
                        updateRates(qos);
                    }, INFO_INTERVAL);
                }
                qos.playing = true;
            }
        };
    }

    /**
    * Based on https://trac.webkit.org/browser/trunk/ManualTests/video-statistics.html
    */
    function updateRates(qos) {
        var player = qos.player;
        var element = player.mediaPlayer;
        var info = qos.infoAdapter;
        //HTMLMediaElement.HAVE_CURRENT_DATA = 2, but might not be available in all browsers
        if (element.readyState <= 2 || element.paused) {
            return;
        }

        var decodedFrames;
        if (element.getVideoPlaybackQuality) {
            var vpq=element.getVideoPlaybackQuality();
            decodedFrames = vpq.totalVideoFrames;
            qos.droppedFrames = vpq.droppedVideoFrames;
        } else {
            if (element.webkitDecodedFrameCount) {
                decodedFrames = element.webkitDecodedFrameCount;
                qos.droppedFrames = element.webkitDroppedFrameCount;
                qos.decodedBytes = element.webkitAudioDecodedByteCount + (element.webkitVideoDecodedByteCount ? element.webkitVideoDecodedByteCount : 0);
            } else {
                if (element.mozParsedFrames) {
                    decodedFrames = element.mozParsedFrames;
                    qos.droppedFrames = element.mozDecodedFrames - element.mozPresentedFrames;
                }
            }
        }

        /**
        * FPS values are likely not to be accurate
        * There's not much of a guarantee that this is fired acccurately on the second.
        */
        qos.currentFPS = decodedFrames - qos.decodedFrames;
        if (qos.currentFPS < 0 || qos.currentFPS > 100) {
            qos.currentFPS = 0;
        }
        qos.maxFPS = Math.max(qos.currentFPS, qos.maxFPS);
        qos.decodedFrames = decodedFrames;

        qos.averageDroppedFrames = ((qos.averageDroppedFrames * qos.averagesCounter) + qos.droppedFrames) / (qos.averagesCounter + 1);

        if (info) {
            qos.averageBufferLength = ((qos.averageBufferLength * qos.averagesCounter) + info.bufferLength) / (qos.averagesCounter + 1);

            player.dispatch({
                audioBufferLength: info.audioBufferLength,
                averageBufferLength: qos.averageBufferLength,
                averageDroppedFPS: qos.averageDroppedFrames,
                averageMaxBandwidth: null,
                bufferLength: info.bufferLength,
                currentBitsPerSecond: info.currentBitsPerSecond,
                currentFPS: qos.currentFPS,
                decodedBytes: qos.decodedBytes,
                decodedFrames: qos.decodedFrames,
                droppedFrames: qos.droppedFrames,
                maxFPS: qos.maxFPS,
                maxBandwidth: null,
                type: "info",
                videoBufferLength: info.videoBufferLength
            });
        }
    }

    function QOS(thePlayer) {
        var qos = this;
        qos.eventCallbacks = qos_getCallbackObject(qos);
        qos.player = thePlayer;
        qos.reportError = qos.eventCallbacks.error;

        qos.resetProperties();

        return qos;
    }

    QOS.prototype = {
        buffering:function() {
            var qos = this;
            if (qos.timeSpentBufferingStart===0) {
                qos.player.dispatch({ type: "SonarBufferEvent"});
                qos.timeSpentBufferingStart = Utils.now();
            }
        },
        endBuffering:function() {
            var qos = this;
            if (qos.timeSpentBufferingStart!==0 && qos.startupTime) {
                var time = Utils.now()- qos.timeSpentBufferingStart;
                qos.timeSpentTotalBuffering+=time/1000;
                qos.timeSpentBufferingStart = 0;
                qos.bufferingEvents++;
                if (DEBUG_FULL) {
                    console.log("QOS: buffered for:"+time+' now:',qos.timeSpentTotalBuffering);
                }
            }
        },
        resetProperties: function() {
            var qos = this;
            qos.currentFPS = 0;
            qos.maxFPS = 0;
            qos.decodedFrames = 0;
            qos.droppedFrames = 0;
            qos.decodedBytes = 0;
            qos.timeSpent = [];
            qos.timeSpentTotal = [];
            qos.timeSpentTotalBuffering = 0;
            qos.timeSpentBufferingStart = 0;
            qos.droppedFramesArray = [];
            qos.droppedFramesTotal = [];
            qos.infoEventObject = null;
            qos.bufferingEvents = 0;
            qos.lastInfoTime = -999999;
            qos.infoTimeMultiplier = 10;
            qos.bitrateChanges = [];
            qos.averageBufferLength = 0;
            qos.averageDroppedFrames = 0;
            qos.averagesCounter = 0;
            qos.playing = false;

        },
        getMediaType:function() {
            var qos=this;
            var player=qos.player;
            var type = "od";
            if (player.mediaItem) {
                if (player.isLive) {
                    if (player.mediaItem.simulcast) {
                        type="simulcast";
                    } else {
                        type="live";
                    }
                } else {
                    if (player.mediaItem.kind!="programme" && player.mediaItem.kind!="radioProgramme") {
                        type=player.mediaItem.kind || "unknown";
                    }
                }
            }
            return player.elType+"-"+type;
        },
        getInfoData:function() {
            var qos = this;
            var infoData = [];
            var lastBitrate = getBitrate(qos);
            qos.lastInfoBitrate = lastBitrate;
            // playback and current the same for now
            infoData.push(lastBitrate);
            infoData.push(getBitrate(qos,true));

            infoData.push(qos.bufferingEvents);
            infoData.push(qos.timeSpentTotalBuffering.toFixed(1));

            var avgBuffer = qos.averageBufferLength ? qos.averageBufferLength.toFixed(1) : "-";
            infoData.push(avgBuffer);
            var th=qos.player.timeHelper;
            var time = "-";
            if (!isNaN(th.time)) {
                time = th.time.toFixed(1);
            }
            infoData.push(time);
           
            var durationOrLive = "-";
            if (th.latestSeek) {
                durationOrLive = th.latestSeek.toFixed(1);
            } else {
                if (!isNaN(th.duration)) {
                    durationOrLive = th.duration;
                }
            }
            infoData.push(durationOrLive);
            return infoData;
        }
    };

    return QOS;
})();
/*jshint -W082 */ 
var DebugConsole = (function() {

    var MEDIA_TOUCH_TIMEOUT = 10000; // how long to wait to show the debug menu
    var debugTouchMenuTimer;
    var currentBitRate;
    var currentCodecs;
    var currentFormat;
    var lastErrorEncountered;
    var touchBitmask = 0; // track touches on media element
    var player = null;
    var versionDetails;
    var contextMenu;
    var streamInfoItem;
    var errorInfoItem;
    var errorHistory=[];

    if (DEBUG_FULL) {
        var dashLoggingOptionItem;
        // cookie access errors in sandboxed frames.
        try {
            var showDebugConsoleLog = (document.cookie.match('overlayJsDebug=([^;]*)')||0)[1];
        } catch (e) {}
        var debugConsoleLog;
        var pauseScroll = false;
        var scrollTopMax;
        var scrollContainer;
        var consoleList;
        var consoleItem;
        var currentScrollTop = 0;
    }


    function showFunc(event) {
        if ((event.target == player.mediaContainer || event.target == player.mediaPlayer) && event.changedTouches) {
            var xpct = (event.changedTouches[0].pageX / window.innerWidth);
            var ypct = (event.changedTouches[0].pageY / window.innerHeight);
            if (xpct < 0.25) {
                touchBitmask |= 1;
            }
            if (xpct > 0.75) {
                touchBitmask |= 2;
            }

            if (ypct < 0.25) {
                touchBitmask |= 4;
            }
            if (ypct > 0.66) {
                touchBitmask |= 8;
            }

            if(DEBUG_FULL) {
                if (!debugTouchMenuTimer) {
                    debugTouchMenuTimer =  setTimeout(debugMenuTimerFn,MEDIA_TOUCH_TIMEOUT);
                }
            }
        }
    }

    function updateContextMenu(update) {
        if (update || contextMenu.style.display == 'block') {
            versionDetails.textContent = versionDetails.title = player.build;

            var info = getStreamInfo()+"\n ";
            try {
                streamInfoItem.firstChild.textContent = info.split('\n')[0];
                streamInfoItem.lastChild.textContent = info.split('\n')[1];
            } catch (e) {
                streamInfoItem.textContent=info;
            }
                streamInfoItem.title = info;

            
            errorInfoItem.textContent = errorInfoItem.title = lastErrorEncountered ? ('Error: ' + lastErrorEncountered.code+(lastErrorEncountered.extra ? ", "+lastErrorEncountered.extra : ""))  : '';

            if (DEBUG_FULL) {
                if (player.dashEvents && player.dashEvents.dashPlayer && player.isPlayingDash) {
                    dashLoggingOptionItem.textContent = 'Dash logging ' + (player.dashEvents.dashJsDebug ? String.fromCharCode(10003) : '');
                } else {
                    dashLoggingOptionItem.textContent = "";
                }
                consoleItem.textContent = 'Overlay Console ' + (showDebugConsoleLog ? String.fromCharCode(10003) : '');
            }
            
            var els = contextMenu.getElementsByTagName('li');
            for (var i=0;i< els.length;i++) {
                els[i].style.display=(els[i].textContent==="") ? "none" : "";
            }
        }
    }

    function displayContextMenu(event) {
        updateContextMenu(true);
        contextMenu.style.display = 'block';
        var mediaContainerRect = Utils.getOffsets(player.mediaContainer);
        var containerOffsetX = mediaContainerRect.left + mediaContainerRect.width;
        var containerOffsetY = mediaContainerRect.top + mediaContainerRect.height;

        var xPos = event.type == 'touchstart' ? event.targetTouches[0].pageX : event.pageX;
        var yPos = event.type == 'touchstart' ? event.targetTouches[0].pageY : event.pageY;

        var menuFitsVertically = (containerOffsetY - yPos > Utils.getOffset(contextMenu, 'height'));
        var menuFitsHorizontally = (containerOffsetX - xPos > Utils.getOffset(contextMenu, 'width'));

        contextMenu.style.left = (menuFitsHorizontally ? (xPos + 'px') : 'auto');
        contextMenu.style.right = (menuFitsHorizontally ? 'auto' : '0');
        contextMenu.style.top = (menuFitsVertically ? (yPos + 'px') : ('auto'));
        contextMenu.style.bottom = (menuFitsVertically ? ('auto') : '0');
    }

    function onContextMenuBlur(e) {
        if (e.type !== 'keydown' || e.keyCode === KEY_ESCAPE) {
            hideContextMenu();
        }
    }

    function hideContextMenu() {
        document.documentElement.removeEventListener('click', onContextMenuBlur);
        document.documentElement.removeEventListener('keydown', onContextMenuBlur);
        contextMenu.style.display = 'none';
    }

    function createContextMenu() {
        contextMenu = document.createElement('ul');
        contextMenu.style.display="none";
        contextMenu.className = 'p_contextMenu';
        versionDetails = createContextMenuItem(onDebugItemSelected);
        versionDetails.textContent = versionDetails.title = player.build;

        streamInfoItem = createContextMenuItem(onStreamInfoItemSelected);
        streamInfoItem.innerHTML=" <br> ";
        errorInfoItem = createContextMenuItem(onErrorItemSelected);

        dashLoggingOptionItem = createContextMenuItem(onDashLoggingOptionItemSelectedFn);

        consoleItem = createContextMenuItem(onDebugLoggerSelectedFn);
        player.mediaContainer.appendChild(contextMenu);

        Utils.multiAddEventListener(document.documentElement, 'click keydown', onContextMenuBlur, true);
    }

    function createContextMenuItem(clickHandler) {
        var itemContainer = document.createElement('li');
        contextMenu.appendChild(itemContainer);
        var contextMenuItem = document.createElement('a');
        contextMenuItem.className = 'p_contextMenuItem';
        if (clickHandler) {
            contextMenuItem.addEventListener('click', clickHandler);
        }
        itemContainer.appendChild(contextMenuItem);
        return contextMenuItem;
    }


    if(DEBUG_FULL) {
        // Hoisting is fine as DEBUG_FULL is used purely to limit the
        // presence of the code, it should be compiled away as it's
        // always true.
        function debugMenuTimerFn() {
            clearTimeout(debugTouchMenuTimer);
            debugTouchMenuTimer = 0;
            
            if (touchBitmask == 15) {
                displayContextMenu();
            }
            touchBitmask = 0;
        }

        function createDebugLogFn() {
            debugConsoleLog = document.createElement('div');
            debugConsoleLog.className = 'p_debugConsoleLog';
            var mc = document.getElementById('mediaContainer');
            mc.appendChild(debugConsoleLog);

            consoleList = scrollContainer = document.createElement('ul');
            consoleList.className = 'p_consoleLogList';
            consoleList.id = 'p_consoleList';
            debugConsoleLog.appendChild(consoleList);
            scrollContainer.addEventListener('scroll', handleScroll);
            scrollContainer.scrollTop = scrollContainer.scrollHeight;
        }

        function createLogItemFn(args) {
            var str = "";
            for (var i=0; i<args.length; i++) {
                if(typeof args[i] === 'string') {
                    str+=args[i] + " ";
                }
            }

            var logItem = document.createElement('li');
            logItem.className = 'p_consoleLogItem';
            logItem.textContent = str + " ";
            consoleList.appendChild(logItem);

            if(!pauseScroll) {
                scrollContainer.scrollTop = scrollContainer.scrollHeight;
                scrollTopMax = scrollContainer.scrollTop;
            }
        }

        function displayDebugLogFn() {
            showDebugConsoleLog = true;
            debugConsoleLog.style.display = 'block';
        }

        function hideDebugLogFn() {
            debugConsoleLog.style.display = 'none';
            document.documentElement.removeEventListener('scroll', handleScroll);
        }

        function onDebugLoggerSelectedFn(event) {
            if(!debugConsoleLog) {
                createDebugLogFn();
            }
            if (!showDebugConsoleLog) {
                displayDebugLogFn();
                hideContextMenu();
            } else {
                hideDebugLogFn();
                showDebugConsoleLog = false;
            }
            event.preventDefault();
        }

        function handleScroll() {
            currentScrollTop = scrollContainer.scrollTop;
            pauseScroll = currentScrollTop < scrollTopMax;
        }

        function onDashLoggingOptionItemSelectedFn(event) {
            var dashEvents = player.dashEvents;
            dashEvents.dashJsDebug = !dashEvents.dashJsDebug;
            dashLoggingOptionItem.textContent = 'Dash logging ' + (dashEvents.dashJsDebug ? String.fromCharCode(10003) : '');
            event.preventDefault();
            hideContextMenu();
        }
    }

    function onDebugItemSelected(event) {
        console.log(player.mediaConnection);
        console.log(player.mediaItem);
        console.log(player.playlist);
        console.log(player.config);
        console.log(player.ui.config);
        console.log(player.ui.markerData);
        console.log(navigator.userAgent);
        event.preventDefault();
        hideContextMenu();
    }

    function onErrorItemSelected(event) {
        var errorMessage = "Error code : " + lastErrorEncountered.code +
                        "\nSeverity : " + lastErrorEncountered.severity +
                        "\nDescription : " + lastErrorEncountered.description +
                        "\nResponsibility : " + lastErrorEncountered.responsibility +
                        "\nDetail : " + lastErrorEncountered.detail;
        console.log(errorMessage);
        event.preventDefault();
        hideContextMenu();
    }

    function onStreamInfoItemSelected(event) {
        console.log(streamInfoItem.textContent);
        event.preventDefault();
        hideContextMenu();
    }

    function getStreamInfo() {
        var vpid = (player.mediaItem && player.mediaItem.identifier ? player.mediaItem.identifier : 'unknown');
            
        var dimensions="";
        var mediaConnection = player.mediaConnection;
        if (mediaConnection) {
            var bitRate = currentBitRate || 'unknown bitrate';
            if (currentCodecs=="flac") {
                bitRate="lossless";
            }
            var transferFormat = currentFormat || (mediaConnection.format ? mediaConnection.format : 'unknown format');
            var cdn = mediaConnection.supplier ? mediaConnection.supplier : 'unknown cdn';
            if (player.elType=="video") {
                dimensions = " | "+((player.mediaPlayer && player.mediaPlayer.videoWidth && player.mediaPlayer.videoHeight) ? player.mediaPlayer.videoWidth + 'x' + player.mediaPlayer.videoHeight : 'unknown dimensions');
            }
            return bitRate + ' | ' + transferFormat + ' (' + cdn + ')'+"\n" + vpid + dimensions;
        }

        return vpid;
    }

    function touchMade(event) {
        // three finger tap to show context menu!
        if (event.targetTouches.length > 2) {
            displayContextMenu(event);
        }
    }

    function handleContextMenuClick(event) {
        var flashFallbackLoading = !player.swf.fake && !player.swf.ready && !player.swf.failed;
        if ( !flashFallbackLoading && (!contextMenu || contextMenu.style.display == 'none') ) {
            displayContextMenu(event);
            event.preventDefault();
        } else {
            hideContextMenu();
        }
    }

    var debugFunctions = {
        player : function(p) {
            player = p;
            var mc = p.mediaContainer;
            createContextMenu();
            Utils.multiAddEventListener(mc, 'touchend mouseup', showFunc);
            mc.addEventListener('contextmenu', handleContextMenuClick);
            mc.addEventListener('touchstart', touchMade);
        },
        addContextMenuItem : function(id,text,callback) {
            var reference="item_"+id;
            if (!additionalItems[reference]) {
                additionalItems[reference] = createContextMenuItem(callback);
            }
            additionalItems[reference].textContent = text;
        },
        updateContextMenuItem: function(id,text) {
            var reference="item_"+id;
            if (additionalItems[reference]) {
                additionalItems[reference].textContent = text;
            }
        },
        eventCallbacks : {
            mediaItemChanged : function() {
                currentBitRate = null;
                currentCodecs = null;
                currentFormat = null;
                updateContextMenu();
                errorHistory = [];
            },
            loadedmetadata : function(event) {
                var newBitrate = event.bitrate;
                var codecs = event.codecs;
                var transferFormat = event.transferFormat;
                if (newBitrate) {
                    currentBitRate = newBitrate + 'kbps';
                }
                if (codecs) {
                    currentCodecs=codecs;
                }
                if (transferFormat) {
                    currentFormat=transferFormat;
                }

                updateContextMenu();
            },
            info : function(e) {
                if (e.currentBitsPerSecond) {
                    currentBitRate = e.currentBitsPerSecond + 'kbps';
                }
            },
            error : function(error) {
                // 4205's come out async from the dash player and
                // aren't helpful, let's hide them from here.
                if (error.code==4205) {
                    return;
                }
                // 5000 is generic "Something didn't" and is unhelpful
                if (lastErrorEncountered && error.code == 5000) {
                    lastErrorEncountered.code = lastErrorEncountered.code + ' (' + error.code + ')';
                } else {
                    lastErrorEncountered = error;
                }
                errorHistory.push(error.code);
                updateContextMenu();
            },
            playlistLoading : function() {
                lastErrorEncountered = null;
                updateContextMenu();
            }
        }
    };

    var additionalItems={};


    if(DEBUG_FULL) {
        debugFunctions.updateConsoleLog = function(args) {
            if(debugConsoleLog && showDebugConsoleLog) {
                createLogItemFn(args);
            }
        };
        debugFunctions.testShowDebug = function() {
            if (showDebugConsoleLog) {
                createDebugLogFn();
                displayDebugLogFn();
            }
        };
    }
    return  debugFunctions;

})();
/*
 Copyright 2011 Abdulla Abdurakhmanov
 Original sources are available at https://code.google.com/p/x2js/

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

/*
 Modified to keep track of children nodes in order in attribute __children.
*/
/* jshint ignore:start */

function X2JS(matchers, attrPrefix, ignoreRoot) {
    if (attrPrefix === null || attrPrefix === undefined) {
        attrPrefix = "_";
    }
    
    if (ignoreRoot === null || ignoreRoot === undefined) {
        ignoreRoot = false;
    }
    
	var VERSION = "1.0.11";
	var escapeMode = false;

	var DOMNodeTypes = {
		ELEMENT_NODE 	   : 1,
		TEXT_NODE    	   : 3,
		CDATA_SECTION_NODE : 4,
		COMMENT_NODE       : 8,
		DOCUMENT_NODE 	   : 9
	};
	
	function getNodeLocalName( node ) {
		var nodeLocalName = node.localName;			
		if(nodeLocalName == null) // Yeah, this is IE!! 
			nodeLocalName = node.baseName;
		if(nodeLocalName == null || nodeLocalName=="") // =="" is IE too
			nodeLocalName = node.nodeName;
		return nodeLocalName;
	}
	
	function getNodePrefix(node) {
		return node.prefix;
	}
		
	function escapeXmlChars(str) {
		if(typeof(str) == "string")
			return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#x27;').replace(/\//g, '&#x2F;');
		else
			return str;
	}

	function unescapeXmlChars(str) {
		return str.replace(/&amp;/g, '&').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&quot;/g, '"').replace(/&#x27;/g, "'").replace(/&#x2F;/g, '\/')
	}	

	function parseDOMChildren( node ) {
		if(node.nodeType == DOMNodeTypes.DOCUMENT_NODE) {
			var result,
			    child = node.firstChild,
			    i,
			    len; 
			
			// get the first node that isn't a comment
			for(i = 0, len = node.childNodes.length; i < len; i += 1) {
			   if (node.childNodes[i].nodeType !== DOMNodeTypes.COMMENT_NODE) {
			       child = node.childNodes[i];
			       break;
			   } 
			}
			
			if ( ignoreRoot ) {
			    result = parseDOMChildren(child);
			} else {
			    result = {};
			    var childName = getNodeLocalName(child);
                result[childName] = parseDOMChildren(child);
			}
			
			return result;
		}
		else
		if(node.nodeType == DOMNodeTypes.ELEMENT_NODE) {
			var result = new Object;
			result.__cnt=0;

            var children = [];
			
			var nodeChildren = node.childNodes;
			
			// Children nodes
			for(var cidx=0; cidx <nodeChildren.length; cidx++) {
				var child = nodeChildren.item(cidx); // nodeChildren[cidx];
				var childName = getNodeLocalName(child);
				
				result.__cnt++;
				if(result[childName] == null) {
                    var c = parseDOMChildren(child);
                    if (childName != "#text" || /[^\s]/.test(c)) {
                        var o = {};
                        o[childName] = c;
                        children.push(o);
                    }
					result[childName] = c;
					result[childName+"_asArray"] = new Array(1);
					result[childName+"_asArray"][0] = result[childName];
				}
				else {
					if(result[childName] != null) {
						if( !(result[childName] instanceof Array)) {
							var tmpObj = result[childName];
							result[childName] = new Array();
							result[childName][0] = tmpObj;
							
							result[childName+"_asArray"] = result[childName];
						}
					}
					var aridx = 0;
					while(result[childName][aridx]!=null) aridx++;

                    var c = parseDOMChildren(child);
					if (childName != "#text" || /[^\s]/.test(c)) { // Don't add white-space text nodes
                        var o = {};
                        o[childName] = c;
                        children.push( o );
                    }
					(result[childName])[aridx] = c;
				}			
			}

            result.__children = children;
			
			// Attributes
			for(var aidx=0; aidx <node.attributes.length; aidx++) {
				var attr = node.attributes.item(aidx); // [aidx];
				result.__cnt++;
				
				var value2 = attr.value;
				for(var m=0, ml=matchers.length; m < ml; m++) {
				    var matchobj = matchers[m];
				    if (matchobj.test.call(this, attr))
				        value2 = matchobj.converter.call(this, attr.value);
				}
				
				result[attrPrefix+attr.name]=value2;
			}
			
			// Node namespace prefix
			var nodePrefix = getNodePrefix(node);
			if(nodePrefix!=null && nodePrefix!="") {
				result.__cnt++;
				result.__prefix=nodePrefix;
			}
			
			if( result.__cnt == 1 && result["#text"]!=null  ) {
				result = result["#text"];
			} 
			
			if(result["#text"]!=null) {
				result.__text = result["#text"];
				if(escapeMode)
					result.__text = unescapeXmlChars(result.__text)
				delete result["#text"];
				delete result["#text_asArray"];
			}
			if(result["#cdata-section"]!=null) {
				result.__cdata = result["#cdata-section"];
				delete result["#cdata-section"];
				delete result["#cdata-section_asArray"];
			}
			
			if(result.__text!=null || result.__cdata!=null) {
				result.toString = function() {
					return (this.__text!=null? this.__text:'')+( this.__cdata!=null ? this.__cdata:'');
				}
			}
			return result;
		}
		else
		if(node.nodeType == DOMNodeTypes.TEXT_NODE || node.nodeType == DOMNodeTypes.CDATA_SECTION_NODE) {
			return node.nodeValue;
		}	
		else
		if(node.nodeType == DOMNodeTypes.COMMENT_NODE) {
		    return null;
		}
	}
	
	function startTag(jsonObj, element, attrList, closed) {
		var resultStr = "<"+ ( (jsonObj!=null && jsonObj.__prefix!=null)? (jsonObj.__prefix+":"):"") + element;
		if(attrList!=null) {
			for(var aidx = 0; aidx < attrList.length; aidx++) {
				var attrName = attrList[aidx];
				var attrVal = jsonObj[attrName];
				resultStr+=" "+attrName.substr(1)+"='"+attrVal+"'";
			}
		}
		if(!closed)
			resultStr+=">";
		else
			resultStr+="/>";
		return resultStr;
	}
	
	function endTag(jsonObj,elementName) {
		return "</"+ (jsonObj.__prefix!=null? (jsonObj.__prefix+":"):"")+elementName+">";
	}
	
	function endsWith(str, suffix) {
	    return str.indexOf(suffix, str.length - suffix.length) !== -1;
	}
	
	function jsonXmlSpecialElem ( jsonObj, jsonObjField ) {
		if(endsWith(jsonObjField.toString(),("_asArray")) 
				|| jsonObjField.toString().indexOf("_")==0 
				|| (jsonObj[jsonObjField] instanceof Function) )
			return true;
		else
			return false;
	}
	
	function jsonXmlElemCount ( jsonObj ) {
		var elementsCnt = 0;
		if(jsonObj instanceof Object ) {
			for( var it in jsonObj  ) {
				if(jsonXmlSpecialElem ( jsonObj, it) )
					continue;			
				elementsCnt++;
			}
		}
		return elementsCnt;
	}
	
	function parseJSONAttributes ( jsonObj ) {
		var attrList = [];
		if(jsonObj instanceof Object ) {
			for( var ait in jsonObj  ) {
				if(ait.toString().indexOf("__")== -1 && ait.toString().indexOf("_")==0) {
					attrList.push(ait);
				}
			}
		}
		return attrList;
	}
	
	function parseJSONTextAttrs ( jsonTxtObj ) {
		var result ="";
		
		if(jsonTxtObj.__cdata!=null) {										
			result+="<![CDATA["+jsonTxtObj.__cdata+"]]>";					
		}
		
		if(jsonTxtObj.__text!=null) {			
			if(escapeMode)
				result+=escapeXmlChars(jsonTxtObj.__text);
			else
				result+=jsonTxtObj.__text;
		}
		return result
	}
	
	function parseJSONTextObject ( jsonTxtObj ) {
		var result ="";

		if( jsonTxtObj instanceof Object ) {
			result+=parseJSONTextAttrs ( jsonTxtObj )
		}
		else
			if(jsonTxtObj!=null) {
				if(escapeMode)
					result+=escapeXmlChars(jsonTxtObj);
				else
					result+=jsonTxtObj;
			}
		
		return result;
	}
	
	function parseJSONArray ( jsonArrRoot, jsonArrObj, attrList ) {
		var result = ""; 
		if(jsonArrRoot.length == 0) {
			result+=startTag(jsonArrRoot, jsonArrObj, attrList, true);
		}
		else {
			for(var arIdx = 0; arIdx < jsonArrRoot.length; arIdx++) {
				result+=startTag(jsonArrRoot[arIdx], jsonArrObj, parseJSONAttributes(jsonArrRoot[arIdx]), false);
				result+=parseJSONObject(jsonArrRoot[arIdx]);
				result+=endTag(jsonArrRoot[arIdx],jsonArrObj);						
			}
		}
		return result;
	}
	
	function parseJSONObject ( jsonObj ) {
		var result = "";	

		var elementsCnt = jsonXmlElemCount ( jsonObj );
		
		if(elementsCnt > 0) {
			for( var it in jsonObj ) {
				
				if(jsonXmlSpecialElem ( jsonObj, it) )
					continue;			
				
				var subObj = jsonObj[it];						
				
				var attrList = parseJSONAttributes( subObj )
				
				if(subObj == null || subObj == undefined) {
					result+=startTag(subObj, it, attrList, true)
				}
				else
				if(subObj instanceof Object) {
					
					if(subObj instanceof Array) {					
						result+=parseJSONArray( subObj, it, attrList )					
					}
					else {
						var subObjElementsCnt = jsonXmlElemCount ( subObj );
						if(subObjElementsCnt > 0 || subObj.__text!=null || subObj.__cdata!=null) {
							result+=startTag(subObj, it, attrList, false);
							result+=parseJSONObject(subObj);
							result+=endTag(subObj,it);
						}
						else {
							result+=startTag(subObj, it, attrList, true);
						}
					}
				}
				else {
					result+=startTag(subObj, it, attrList, false);
					result+=parseJSONTextObject(subObj);
					result+=endTag(subObj,it);
				}
			}
		}
		result+=parseJSONTextObject(jsonObj);
		
		return result;
	}
	
	this.parseXmlString = function(xmlDocStr) {
		var xmlDoc,
			parser,
			ns;

		if (window.DOMParser) {
			parser = new window.DOMParser();

			try {
				ns = parser.parseFromString('<', 'text/xml').getElementsByTagName("parsererror")[0].namespaceURI;
			} catch (e) {
				// IE11 will definitely throw SyntaxError here
				// ns will be undefined
			}

			try {
				xmlDoc = parser.parseFromString( xmlDocStr, "text/xml" );

				if (ns) {
					if(xmlDoc.getElementsByTagNameNS(ns, 'parsererror').length) {
						xmlDoc = undefined;
					}
				}
			} catch (e) {
				// IE11 may throw SyntaxError here if xmlDocStr is
				// not well formed. xmlDoc will be undefined
			}
		}
		else {
			// IE :(
			if(xmlDocStr.indexOf("<?")==0) {
				xmlDocStr = xmlDocStr.substr( xmlDocStr.indexOf("?>") + 2 );
			}
			xmlDoc=new ActiveXObject("Microsoft.XMLDOM");
			xmlDoc.async="false";
			xmlDoc.loadXML(xmlDocStr);
		}
		return xmlDoc;
	}

	this.xml2json = function (xmlDoc) {
		return parseDOMChildren ( xmlDoc );
	}
	
	this.xml_str2json = function (xmlDocStr) {
		var xmlDoc = this.parseXmlString(xmlDocStr);	
		return xmlDoc ? this.xml2json(xmlDoc) : undefined;
	}

	this.json2xml_str = function (jsonObj) {
		return parseJSONObject ( jsonObj );
	}

	this.json2xml = function (jsonObj) {
		var xmlDocStr = this.json2xml_str (jsonObj);
		return this.parseXmlString(xmlDocStr);
	}
	
	this.getVersion = function () {
		return VERSION;
	}		
	
	this.escapeMode = function(enabled) {
		escapeMode = enabled;
	}
}
/* jshint ignore:end */var Subtitles = (function() {

    var allowedRanges = {
        scale : {min: 0.5},
        fontSize : {min : 0.5} //em
    };

    function getPx(str) {
        return str ? parseFloat(str.split('px')[0]) : 0;
    }

    function inTime(subtitle, time) {
        return subtitle.start < time && subtitle.end > time;
    }

    function truncateToRange(val, range) {
        if (!isNaN(range.max) && !isNaN(range.min)) {
            return Math.min(Math.max(val, range.min), range.max);
        } else if (!isNaN(range.min)) {
            return Math.max(val, range.min);
        }

        return val;
    }


    function getSubsFunction(subtitles,str) {
        // Ensure that we're loading the subs we
        // thought we were. This also suppresses the
        // rdot error event, this seems reasonable.
        return function(href) {
            if (subtitles.currentSubItem && subtitles.currentSubItem.href === href) {
                subtitles[str](href);
            }
        };
    }

    function getCallbackObject(subtitles) {
        function clear() {
            subtitles.clearSubtitles();
        }
        function itemChanging() {
            subtitles.clearSubtitles();
            subtitles.captionsList = null;
            subtitles.overrideItem = null;
            subtitles.currentSubItem = null;
            subtitles.failedToLoad = false;
        }

        return {
            blockUnwanted : true,
            playlistLoading : itemChanging,
            playlistEnded : clear,
            seeking : clear,
            ended : clear,
            error : clear,
            losingControl : clear,
            mediaItemChanged : itemChanging,
            mediaItemInfoChanged : function() {
                subtitles.failedToLoad = false;
                subtitles.load();
            },
            timeupdate : function() {
                // XXX subtitles playing along is actually pretty good
                if (subtitles.showingSubs && !subtitles.player.Chromecast.isCasting) {
                    if (subtitles.currentSubItem && subtitles.currentSubItem.captionsList) {
                        subtitles.checkForSubtitles(subtitles.player.time);
                    }
                }

                if (subtitles.player.mediaItem.liveSubsItem && subtitles.player.mediaItem.liveSubsItem.hasHLSliveSubs) {
                    subtitles.player.mediaItem.liveSubsItem.loadHLSsubs(subtitles.player.timeHelper.time+6);
                }
            },
            seeked : function() {

                subtitles.clearSubtitles();
                var mediaItem = subtitles.player.mediaItem;
                if (mediaItem && mediaItem.liveSubsItem && mediaItem.liveSubsItem.hasHLSliveSubs) {
                    if (subtitles.player.mediaPlayer.paused) {
                        mediaItem.liveSubsItem.loadHLSsubs(subtitles.player.timeHelper.time);
                    }
                }
            },
            playing : function() {
                if (subtitles.player.mediaItem.liveSubsItem && subtitles.player.mediaItem.liveSubsItem.hasHLSliveSubs) {
                    subtitles.player.mediaItem.liveSubsItem.loadHLSsubs(subtitles.player.timeHelper.time+3.84);
                }
            }
        };
    }

    function getMaxSize(zone, str, val) {
        if (zone.from === str) {
            var size = zone.size;
            return size > val ? size : val;
        }
        return val;
    }

    function rectMap(rect1, rect2, func) {
        return {
            top : func(rect1.top, rect2.top),
            bottom : func(rect1.bottom, rect2.bottom),
            left : func(rect1.left, rect2.left),
            right : func(rect1.right, rect2.right)
        };
    }

    //Return the distance a needs to move towards to no longer intercept b
    function rectIntersect(rect, other) {
        return {
            top : rect.bottom - other.top,
            bottom : -(rect.top - other.bottom),
            left : rect.right - other.left,
            right : -(rect.left - other.right)
        };
    }

    function rectUnion(rects) {
        if (rects.length > 0) {
            var ret = {top : rects[0].top, bottom : rects[0].bottom, left : rects[0].left, right : rects[0].right};
            for (var i = 1; i < rects.length; i++) {
                var other = rects[i];
                ret.top = Math.min(ret.top, other.top);
                ret.bottom = Math.max(ret.bottom, other.bottom);
                ret.left = Math.min(ret.left, other.left);
                ret.right = Math.max(ret.right, other.right);
            }
            ret.width = ret.right - ret.left;
            ret.height = ret.bottom - ret.top;

            return ret;
        }
        return undefined;
    }

    function addWithUnits (valueStr, unitsStr, addValue) {
        return funcWithUnits(valueStr, unitsStr, function(value) {return value + addValue;});
    }

    function scaleWithUnits(valueStr, unitsStr, scaleFactor) {
        return funcWithUnits(valueStr, unitsStr, function(value) {return value * scaleFactor;});
    }

    function funcWithUnits(valueStr, unitsStr, func) {
        var value = parseFloat(valueStr.slice(0, valueStr.indexOf(unitsStr)));
        return func(value) + unitsStr;
    }

    //Because it checks against screen.width, this method doesn't give the zoom level when not in fullscreen.
    function getFullscreenZoomScale(containerDimensions) {
        if (window.screen && window.screen.width && window.screen.height &&
                containerDimensions.width && containerDimensions.height) {
            var width = window.screen.width / containerDimensions.width;
            var height = window.screen.height / containerDimensions.height;
            //Choose the one that is defining the scale; some aspect ratios, the container is not the full dimension
            return Math.min(height, width);
        }

        return 1;
    }

function makeControlBarMargin(ui) {
    var margin = {
        from : 'bottom'
    };

    Utils.defineProperties(margin, {
        size: {
            get : function() {
                var ret = 0;
                if (ui.areControlsVisible()) {
                    var controlsTop = 0;
                    var info = ui.UIinfoObject;
                    if (info.markersBarVisible) {
                        controlsTop = Utils.getOffset(ui.chapterMarkersHolder, 'top');
                    } else if (info.seekBarVisible) {
                        controlsTop = Utils.getOffset(ui.progressBar.seekBarHolder, 'top');
                    } else if (ui.controls) {
                        controlsTop = Utils.getOffset(ui.controls, 'top');
                    }

                    if(ui.subtitleSettingsPanel.isPanelOpen()) {
                        controlsTop = Math.min(controlsTop, ui.subtitleSettingsPanel.getPanelTop());
                    }

                    if(ui.playbackSettingsPanel.isPanelOpen()) {
                        controlsTop = Math.min(controlsTop, ui.playbackSettingsPanel.getPanelTop());
                    }

                    if (controlsTop > 0) {
                        var videoHeight = info.videoHeight ? info.videoHeight : Utils.getOffset(ui.container, "height");
                        var videoY = info.videoY ? info.videoY : 0;
                        ret = (videoY + videoHeight - controlsTop) + 10;//Extract +10 margin into variable.
                    } else {
                        ret = controlsTop;
                    }
                }

                return ret;
            }
    }});

    return margin;
}

function makeYOffsetMargin(ui) {
    var margin = {
        from : 'bottom'
    };

    Utils.defineProperties(margin, {
        size: {
            get : function() {
                if (!isNaN(ui.config.subtitles.yOffset)) {
                    var videoHeight = ui.UIinfoObject.videoHeight ? ui.UIinfoObject.videoHeight : Utils.getOffset(ui.container, "height");
                    var videoY = ui.UIinfoObject.videoY ? ui.UIinfoObject.videoY : 0;
                    return videoHeight + videoY - ui.config.subtitles.yOffset;
                }

                return 0;
            }
    }});

    return margin;
}


    var Subtitles = function(player) {
        var subtitles = this;
        subtitles.player = player;
        var con = subtitles.container = document.createElement('div');
        con.setAttribute('aria-live','polite');
        con.setAttribute('role','region');
        con.className = 'p_subtitlesContainer';
        subtitles.player.mediaContainer.appendChild(subtitles.container);
        subtitles.failedToLoad = false;
        subtitles.enabled = true;
        subtitles.eventCallbacks = getCallbackObject(this);
        subtitles.index = 0;
        subtitles.previousTime = 0;
        subtitles.subtitleMargins = [];
        subtitles.currentSubtitles = [];
        subtitles.leftToRight = [];
        subtitles.topToBottom = [];
        subtitles.currentSubItem = null;
        subtitles.overrideItem = null;
        subtitles.desnakeLiveSubs = false;
        subtitles.reformatLiveSubs = false;
        subtitles.kind = "subtitles";
        subtitles.considerHLSdelay = false;

        return subtitles;
    };

    Subtitles.prototype = {
        subsClasses : {},
        showingSubs : false,
        failedToLoad : false,
        enabled : true,

        getDefaultSizeAdjustment: function() {

            var playerWidth = window.innerWidth;
            var sizeAdjustment = 0.67;

            if(playerWidth < 601) {
                sizeAdjustment = 1;
            } else if(playerWidth < 1281) {
                sizeAdjustment = 0.67;
            } else if(playerWidth < 2561) {
                sizeAdjustment = 0.6;
            }

            return sizeAdjustment;
        },

        updateConfig : function (config) {
            var subtitles = this;
            config = config.subtitles;
            var opacity = 0.8;

            if (config.contrast) {
                if (typeof config.contrast === 'number' && config.contrast > 1.0) {
                    opacity = config.contrast / 100;
                }
            }

            subtitles.sizeAdjustment = subtitles.getDefaultSizeAdjustment();
            if (config.sizeAdjustment) {
                if (typeof config.sizeAdjustment === 'number' && config.sizeAdjustment > 0) {
                    subtitles.sizeAdjustment = config.sizeAdjustment;

                }
            }

            if (subtitles.player.ui && subtitles.player.ui.subtitleSettingsPanel && subtitles.player.ui.subtitleSettingsPanel.indicateSize) {
                subtitles.player.ui.subtitleSettingsPanel.indicateSize(subtitles.sizeAdjustment);
            }

            subtitles.container.style.opacity = opacity;

            subtitles.kind = config.kind || "subtitles";

            subtitles.subtitleMargins = [makeControlBarMargin(subtitles.player.ui),makeYOffsetMargin(subtitles.player.ui)];
            //And ones from the config.
            if (config.margins) {
                for (var i = 0; i < config.margins.length; i++) {
                    subtitles.subtitleMargins.push(config.margins[i]);
                }
            }

            subtitles.desnakeLiveSubs = config.desnakeLiveSubtitles;
            subtitles.reformatLiveSubs = config.reformatLiveSubtitles;
            if (subtitles.currentSubItem && subtitles.currentSubItem.live) {
                subtitles.currentSubItem.enableDesnake = config.desnakeLiveSubtitles;
            }

            if (config.defaultOn) {
                subtitles.on();
            }

            subtitles.updatePositions();
        },

        persistSizeAdjustment: function(sizeAdjustment) {

            var settingsCookie = Utils.getCookie('ckps_smpSettings');
            var settings = {};

            if(settingsCookie) {

                try {
                    settings = JSON.parse(settingsCookie);

                    if(!settings.subtitles) {
                        settings.subtitles = {
                            sizeAdjustment: sizeAdjustment
                        };
                    } else {
                        settings.subtitles.sizeAdjustment = sizeAdjustment;
                    }

                } catch(error) {

                    settings = {
                        subtitles: {
                            sizeAdjustment: sizeAdjustment
                        }
                    };

                }

            } else {

                settings = {
                    subtitles: {
                        sizeAdjustment: sizeAdjustment
                    }
                };

            }

            Utils.setCookie('ckps_smpSettings', JSON.stringify(settings));

        },

        checkForSubtitles : function(time) {
            var subtitles = this;

            //Check current subtitles first.
            //Remove any outside of the time.
            for (var i = 0; i < subtitles.currentSubtitles.length;) {
                if (!inTime(subtitles.currentSubtitles[i], time) || subtitles.currentSubtitles[i].desnaked) {
                    subtitles.removeSubtitle(subtitles.currentSubtitles[i]);
                } else {
                    i++;
                }
            }

            var start = 0;
            if (time > subtitles.previousTime) {
                start = subtitles.index;
            }
            var subtitle = null;
            for (i = start; i < subtitles.currentSubItem.captionsList.length; i++) {
                var sub = subtitles.currentSubItem.captionsList[i];
                if (sub.start > time) {
                    break;
                }
                if (sub.end > time) {
                    subtitles.displaySubtitle(sub);
                }
            }
            subtitles.previousTime = time;

            return subtitle;
        },
        displaySubtitle : function (subtitle) {
            var subtitles = this;
            if (subtitle && subtitles.currentSubtitles.indexOf(subtitle) < 0) {
                subtitles.container.appendChild(subtitle.cueHTMLElement);

                //Construct natural ordering.
                var sOffset = Utils.getOffsets(subtitle.cueHTMLElement);
                var cOffset = Utils.getOffsets(subtitles.container);
                var naturalPos = rectMap(sOffset, cOffset, Utils.sortSimple);

                naturalPos.left /= cOffset.width;
                naturalPos.right /= cOffset.width;
                naturalPos.top /= cOffset.height;
                naturalPos.bottom /= cOffset.height;
                naturalPos.right = -naturalPos.right;
                naturalPos.bottom = -naturalPos.bottom;

                subtitle.naturalPos = naturalPos;

                subtitles.topToBottom.push(subtitle);
                //Return 0 for equals. This will make order added to array as tie-breaker.
                subtitles.topToBottom.sort(function(a, b) {return a.naturalPos.top > b.naturalPos.top ? 1 : a.naturalPos.top === b.naturalPos.top ? 0 : -1;} );

                subtitles.leftToRight.push(subtitle);
                subtitles.leftToRight.sort(function(a, b) {return a.naturalPos.left > b.naturalPos.left ? 1 : a.naturalPos.left === b.naturalPos.left ? 0 : -1;} );

                subtitles.currentSubtitles.push(subtitle);
                subtitle.active = true;
                subtitles.updatePositions();
            }
        },
        removeSubtitle: function (subtitle) {
            var subtitles = this;
            var index = subtitles.currentSubtitles.indexOf(subtitle);
            if (index >= 0) {
                subtitles.currentSubtitles.splice(index, 1);
                subtitles.leftToRight.splice(subtitles.leftToRight.indexOf(subtitle), 1);
                subtitles.topToBottom.splice(subtitles.topToBottom.indexOf(subtitle), 1);
                subtitles.container.removeChild(subtitle.cueHTMLElement);
                subtitle.active = false;
            }
        },
        clearSubtitles : function() {
            var subtitles = this;
            subtitles.previousTime = 0;
            subtitles.index = 0;
            var list = subtitles.currentSubtitles;
            while (list.length > 0) {
                subtitles.removeSubtitle(list[list.length - 1]);
            }
        },
        showLoadErrorMessage : function() {
            var subtitles = this;
            if (subtitles.container) {
                var subsError = document.createElement("div");
                Utils.className(subsError,"p_subs");
                subsError.innerHTML = "Error Loading Subtitles";
                subsError.style.cssText = "text-align:center; color:#fff; font-size:1.25em; background-color:rgba(0,0,0,1); padding:2px 8px";
                subtitles.container.style.display = "block";
                subtitles.container.className = "p_subtitles";
                subtitles.container.appendChild(subsError);
                subtitles.updatePositions();

                setTimeout(function() {
                    if (subsError.parentNode) {
                        subsError.parentNode.removeChild(subsError);
                    }
                    subsError = null;
                }, 5000);
            }
        },
        updateSubs : function(url) {
            var subtitles = this;
            subtitles.failedToLoad = false;
            subtitles.overrideItem = url ? new SubtitlesItem(url, null) : null;
            subtitles.load();
            subtitles.player.ui.updateLayout();
        },
        on : function() {
            var subtitles = this;
            if (!subtitles.showingSubs || subtitles.considerHLSdelay) {
                subtitles.considerHLSdelay = false;
                subtitles.showingSubs = true;
                subtitles.container.style.display = "block";
                subtitles.load();
                subtitles.updatePositions();
                subtitles.player.ui.UIinfoObject.subtitles = true;
                subtitles.player.ui.dispatchUIInfo();
                subtitles.player.dispatch({type : "subtitles", active : true});
            }
        },
        off : function() {
            var subtitles = this;
            if (subtitles.showingSubs) {
                if (subtitles.currentSubItem && subtitles.currentSubItem.live) {
                    subtitles.currentSubItem.off();
                }
                subtitles.showingSubs = false;
                subtitles.container.style.display = "none";
                subtitles.clearSubtitles();
                subtitles.player.ui.UIinfoObject.subtitles = false;
                subtitles.player.ui.dispatchUIInfo();
                subtitles.player.dispatch({type : "subtitles", active : false});
                subtitles.player.ui.config.subtitles.defaultOn = false;
            }
        },
        subsAvailable : function() {
            var subtitles = this;
            var item = subtitles.player.mediaItem;
            return (!!subtitles.overrideItem  || (item && item.subtitleConnections && item.subtitleConnections.length > 0)) && !subtitles.failedToLoad ;
        },
        updatePositions : function() {
            var subtitles = this;
            subtitles.resizeContainer();
            for (var i = 0; i < subtitles.currentSubtitles.length; i++) {
                subtitles.resizeSubtitle(subtitles.currentSubtitles[i]);
                subtitles.positionSubtitle(subtitles.currentSubtitles[i]);
            }
            var deconflictedList = [];
            for (i = subtitles.topToBottom.length - 1; i >= 0; i--) {
                var subtitle = subtitles.topToBottom[i];

                subtitles.deconflictSubtitle(subtitle, deconflictedList, false);
                deconflictedList.push(subtitle);

                var topMargin = 0;
                for (var m = 0; m < subtitles.subtitleMargins.length; m++) {
                    topMargin = getMaxSize(subtitles.subtitleMargins[m], 'top', topMargin);
                }
                var sEls = subtitle.cueHTMLElement.getElementsByClassName('p_paragraph');
                if (sEls.length === 1) {
                    var topOverflow = -(Utils.getOffsets(sEls[0]).top - Utils.getOffsets(subtitles.container).top - topMargin);
                    //If above the margin, deconflict the other way(downwards).
                    if (topOverflow > 0) {
                        sEls[0].style.top = addWithUnits(sEls[0].style.top, 'px', topOverflow);
                        var downDeconflictList = [];
                        for (var j = i; j < subtitles.topToBottom.length; j++) {
                            subtitles.deconflictSubtitle(subtitles.topToBottom[j], downDeconflictList, true);
                            downDeconflictList.push(subtitles.topToBottom[j]);
                        }
                    }
                }
            }
        },
        deconflictSubtitle: function (subtitle, deconflictedList, downwards){
            var subtitles = this;

            for (var i = 0; i < deconflictedList.length; i++) {
                var other = deconflictedList[i];

                var sEls = subtitle.cueHTMLElement.getElementsByClassName('p_paragraph');
                var oEls = other.cueHTMLElement.getElementsByClassName('p_paragraph');
                if (sEls.length === 1 && oEls.length === 1) {
                    var subEl = sEls[0];
                    var otherEl = oEls[0];

                    var intersect = rectIntersect(Utils.getOffsets(subEl), Utils.getOffsets(otherEl));

                    var rightOf = subtitles.leftToRight.indexOf(subtitle) > subtitles.leftToRight.indexOf(other);
                    var xIntersect = rightOf ? intersect.right : intersect.left;
                    var yIntersect = downwards ? intersect.bottom : intersect.top;

                    if ((xIntersect > 0) && (yIntersect > 0)) {

                        if (xIntersect < yIntersect) {
                            if (rightOf) {
                                subEl.style.left = addWithUnits(subEl.style.left, 'px', xIntersect);
                            } else {
                                subEl.style.left = addWithUnits(subEl.style.left, 'px', -xIntersect);
                            }
                        } else {
                            if (downwards) {
                                subEl.style.top = addWithUnits(subEl.style.top, 'px', yIntersect);
                            } else {
                                subEl.style.top = addWithUnits(subEl.style.top, 'px', -yIntersect);
                            }
                        }
                    }
                }
            }
            return true;
        },
        resizeContainer: function () {
            var subtitles = this;
            var info = subtitles.player.ui.UIinfoObject;

            if (isNaN(info.videoWidth) || isNaN(info.videoHeight)) {
                subtitles.container.style.width = '100%';
                subtitles.container.style.height = '100%';
            } else {
                subtitles.container.style.width = info.videoWidth + 'px';
                subtitles.container.style.height = info.videoHeight + 'px';
            }
            subtitles.container.style.marginLeft = info.videoX + 'px';
            subtitles.container.style.marginTop = info.videoY + 'px';
        },
        positionSubtitle : function(subtitle) {
            var subtitles = this;

            if (subtitle) {
                //Calculate subtitle container margins.
                var margins = {top : 0, bottom : 0, left : 0, right : 0};
                for (var i = 0; i < subtitles.subtitleMargins.length; i++) {
                    var zone = subtitles.subtitleMargins[i];
                    margins.top = getMaxSize(zone, 'top', margins.top);
                    margins.bottom = getMaxSize(zone, 'bottom', margins.bottom);
                    margins.left = getMaxSize(zone, 'left', margins.left);
                    margins.right = getMaxSize(zone, 'right', margins.right);
                }

                var els = subtitle.cueHTMLElement.getElementsByClassName('p_paragraph');
                if (els.length === 1) {
                    var el = els[0];
                    el.style.position = 'relative';

                    //Let the el decide its preferred position without modification by this function.
                    el.style.top = '0px';
                    el.style.left = '0px';
                    var preferredPosition = Utils.getOffsets(el);

                    //Subtract the subtitle rectangle from the container rectangle. This will get the position relative
                    //from the edges of the render area.
                    var subDistance = rectMap(preferredPosition, Utils.getOffsets(subtitles.container), Utils.sortSimple);

                    //Convert bottom and right to distances away from the container wall.
                    subDistance.bottom = -subDistance.bottom;
                    subDistance.right = -subDistance.right;

                    var marginOverflows = rectMap(margins, subDistance, Utils.sortSimple);

                    var xChange;
                    var yChange;
                    //Then if it lies in the margin, push it out.
                    if (marginOverflows.top > 0) { //Fitting top of subtitle has priority over bottom.
                        yChange = marginOverflows.top;
                    } else if (marginOverflows.bottom > 0) {
                        yChange = (-Math.min(marginOverflows.bottom, -marginOverflows.top));
                    }

                    if (marginOverflows.left > 0) { //Left of subtitle has priority over right.
                        xChange = marginOverflows.left;
                    } else if (marginOverflows.right > 0) {
                        xChange = (-Math.min(marginOverflows.right, -marginOverflows.left));
                    }

                    if (yChange) {
                        el.style.top = yChange + 'px';
                        marginOverflows.top -= yChange;
                        marginOverflows.bottom += yChange;
                    }
                    if (xChange) {
                        el.style.left = xChange + 'px';
                        marginOverflows.left -= xChange;
                        marginOverflows.right += xChange;
                    }
                    subtitle.marginOverflows = marginOverflows;
                }
            }
        },
        resizeSubtitle : function(subtitle) {
            var subtitles = this;

            if (subtitle) {

                var videoHeight = Utils.getOffset(subtitles.container, 'height');
                var videoWidth = Utils.getOffset(subtitles.container, 'width');

                var originalHeight = subtitle.videoHeight;
                var originalWidth = subtitle.videoWidth;
                //Calculate the change in cell unit.
                if (videoWidth/videoHeight<2) {
                    var scale = {width: videoWidth / originalWidth, height: videoHeight / originalHeight};
                }  else {
                    scale={width:1,height:1};
                }
                scale.height = truncateToRange(scale.height, allowedRanges.scale);
                scale.width = truncateToRange(scale.width, allowedRanges.scale);
                var key;

                if (subtitle.linePadding) {

                    var newPaddingLeft = scaleWithUnits(subtitle.padding.left, 'px', (scale.width * subtitles.sizeAdjustment) );
                    var newPaddingRight = scaleWithUnits(subtitle.padding.right, 'px', (scale.width * subtitles.sizeAdjustment) );
                    // Compute the CellResolution unit in order to process properties using sizing (fontSize, linePadding, etc).
                    var spanWrappers = document.getElementsByClassName('p_cueDirUniWrapper');
                    for (var i = 0; i < spanWrappers.length; i++) {
                        TTMLParser.applyLinePadding(spanWrappers[i], newPaddingLeft, newPaddingRight);
                    }
                }
                if (subtitle.fontSize) {
                    for (key in subtitle.fontSize) {
                        if (subtitle.fontSize.hasOwnProperty(key)) {
                            var fontSizeStr = subtitle.fontSize[key].slice(0, subtitle.fontSize[key].indexOf('em'));
                            var fontSize = parseFloat(fontSizeStr) * scale.height;


                            //Make subtitle font sizes between 6% and
                            //10% of the video height only if ratio is
                            //sensible
                            if (videoWidth/videoHeight<2) {
                                var sixPercentLimit = videoHeight * 0.06 / 16;
                                fontSize = Math.max(fontSize, sixPercentLimit);
                                var tenPercentLimit = videoHeight * 0.10 / 16;
                                fontSize = Math.min(fontSize, tenPercentLimit);
                            }

                            if (subtitles.player.isFullScreen) {
                                var fullScreenZoomScale = getFullscreenZoomScale({width: videoWidth, height: videoHeight});
                                fontSize *= Math.sqrt(fullScreenZoomScale);
                            }
                            fontSize=fontSize*subtitles.sizeAdjustment;
                            fontSize += 'em';
                            var elements = subtitle.cueHTMLElement.getElementsByClassName('p_paragraph');
                            for (var j = 0; j < elements.length; j++) {
                                elements[j].style.fontSize = fontSize;
                            }
                        }
                    }
                }

                ////Resize the parent paragraph container. (Safari does not expand <p> to fit text.)
                var paragraphs = subtitle.cueHTMLElement.getElementsByClassName('p_paragraph');
                for (i = 0; i < paragraphs.length; i++) {
                    //Prior to resize, if the paragraph is set to word-wrap, resize it to the same size as its parent container.
                    paragraphs[i].style.width="100%";
                    paragraphs[i].style.height="100%";
                    var spans = paragraphs[i].getElementsByTagName('span');
                    var offsets = [];
                    for (j = 0; j < spans.length; j++) {
                        offsets.push(Utils.getOffsets(spans[j]));
                    }
                    var union = rectUnion(offsets);

                    // IE11 does odd things, a bit more space fixes
                    // most of those odd things.
                    var factor=1;
                    if (Device.trident) {
                        factor=1.05;
                    }

                    if (union) {
                        paragraphs[i].style.width = union.width*factor + 'px';
                        paragraphs[i].style.height = union.height*factor + 'px';
                    }
                }

                //Reimplement flex-box attributes through margins.
                for (i = 0; i < paragraphs.length; i++) {
                    var p = paragraphs[i];
                    var pOffset = Utils.getOffsets(p);
                    var regionOffset = Utils.getOffsets(subtitle.cueHTMLElement);
                    var regionStyle = subtitle.cueHTMLElement.style;
                    var regionPadding = {
                        left: getPx(regionStyle.paddingLeft),
                        right: -getPx(regionStyle.paddingRight),
                        top: getPx(regionStyle.paddingTop),
                        bottom: -getPx(regionStyle.paddingBottom)
                    };

                    regionOffset = rectMap(regionOffset, regionPadding, function(a, b) {return a + b;});
                    regionOffset.width = regionOffset.right - regionOffset.left;
                    regionOffset.height = regionOffset.bottom - regionOffset.top;
                    for (j = 0; j < subtitle.flexBoxAttr.length; j++) {
                        var attr = subtitle.flexBoxAttr[j];
                        if (attr.indexOf('align-items') >= 0) {
                            if (attr.indexOf('flex-start') >= 0) {
                                p.style.marginTop = '0px';
                            } else if (attr.indexOf('center') >= 0) {
                                p.style.marginTop = (regionOffset.height/2 - pOffset.height/2) + 'px';
                            } else if (attr.indexOf('flex-end') >= 0) {
                                p.style.marginTop = (regionOffset.height - pOffset.height) + 'px';
                            }
                        } else if (attr.indexOf('justify-content') >= 0) {
                            if (attr.indexOf('flex-start') >= 0) {
                                p.style.marginLeft = '0px';
                            } else if (attr.indexOf('center') >= 0) {
                                p.style.marginLeft = (regionOffset.width/2 - pOffset.width/2) + 'px';
                            } else if (attr.indexOf('flex-end') >= 0) {
                                p.style.marginLeft = (regionOffset.width - pOffset.width) + 'px';
                            }
                        }
                    }
                }
            }
        },
        resizeFix : function() {
            var subtitles = this;
            var cont = subtitles.container;
            if (cont) {
                cont.style.display = "none";
            }
        },
        resizeFixEnd : function() {
            var subtitles = this;

            if(!(subtitles.player.ui.config.subtitles && subtitles.player.ui.config.subtitles.sizeAdjustment)) {
                subtitles.sizeAdjustment = subtitles.getDefaultSizeAdjustment();
                if (subtitles.player.ui.subtitleSettingsPanel.indicateSize ) {
                    subtitles.player.ui.subtitleSettingsPanel.indicateSize(subtitles.sizeAdjustment);
                }
            }

            var cont = subtitles.container;
            if (cont && subtitles.showingSubs) {
                cont.style.display = "block";
                subtitles.updatePositions();
            }
        },
        load : function(isNarrative) {
            // NARRATIVE SUBS WIP, added isNarrative
            var subtitles = this;
            var item;
            if ( subtitles.subsAvailable() && (subtitles.showingSubs || isNarrative) ) {
                var mediaItem = subtitles.player.mediaItem;
                var subList = mediaItem.subtitleConnections;
                item = subtitles.overrideItem;
                if (!item && subList) {
                    var filteredSubList = subList.filter(function (subtitleItem) {
                        return subtitleItem.kind == subtitles.kind;
                    });
                    item = filteredSubList[0] || subList[0];
                }
                if (item) {
                    if (item.live) {
                        item.enableDesnake = subtitles.desnakeLiveSubs;
                        item.enableReformat = subtitles.reformatLiveSubs;
                    }
                    subtitles.currentSubItem = item;
                    subtitles.currentSubItem.loadSubtitles(
                        getSubsFunction(subtitles, "subtitlesLoaded"),
                        getSubsFunction(subtitles, "subtitlesFailed")
                    );
                }
            }
        },
        subtitlesFailed: function(href) {
            var subtitles = this;
            subtitles.failedToLoad = true;
            subtitles.showingSubs = false;
            Utils.callErrorFunction(subtitles.player, SMPError.SUBS_FAILED, href,true);
            subtitles.clearSubtitles();
            subtitles.showLoadErrorMessage();
            subtitles.player.ui.subtitleSettingsPanel.indicateSubsOff();
        },
        subtitlesLoaded : function() {
            var subtitles = this;
            subtitles.player.ui.UIinfoObject.subtitles = true;
            subtitles.player.ui.dispatchUIInfo();
            subtitles.clearSubtitles();
        },
        onNewConnection : function() {
            var subtitles = this;
            if (subtitles.showingSubs && !subtitles.currentSubItem) {
                subtitles.load();
            }
        }
    };

    return Subtitles;
})();
var Chromecast = (function() {


    /**
     * Constructor for Chromecast class
     *
     */
    var Chromecast = function(player) {
        var cc = this;
        cc.player = player;
        cc.deviceId = '';
        cc.isAvailable = false;
        cc.isCasting = false;
        cc.isCastPlaying =  false;
        cc.isAttemptingToCast = false;
        cc.isConnecting = false;
        cc.subtitlesEnabled = false;
        cc.needSetUp = true;
        cc.fakeTime = 0;
        cc.shortcutToProgramme = false;
        cc.newPlaylist = false;
        cc.postInterrupt = false;
        cc.duration = 0;
        cc.activeSession = false;
        cc.fromQueuedPlaylist = false;
        cc.settings = cc.player.config;
        cc.shiftCentralControls = ( cc.settings && cc.settings.ui  && cc.settings.ui.chromecast && cc.settings.ui.chromecast.shiftCentralControls ) ? true : false;
        cc.eventCallbacks = {
            subtitles : function(e) {
                cc.subtitlesEnabled = e.active;
                if (!cc.isCasting) {
                    return;
                }
                if (e.active) {
                    cc.player.dispatch({type:"ccSubsOn"});
                } else {
                    cc.player.dispatch({type:"ccSubsOff"});
                }
            },
            volumechange : function() {
                if (!cc.isCasting) {
                    return;
                }
                if (cc.player.muted) {
                    cc.ccVolume(0);
                } else {
                    cc.ccVolume(cc.player.volume);
                }
            },
            seeked : function() {
                // if (!cc.isCasting) {
                //     cc.player.ui.hideBuffer();
                // }
            },
            pause : function() {
                //dont hide the spinner when a cast is initiated from the
                //extension menu because the player is paused when
                //connecting to receiver/casting

            },
            playlistLoading : function() {
                if (cc.isCasting) {
                    cc.player.config.suppressItemKind = ['ident'];
                    cc.newPlaylist = true;
                    cc.interrupt();
                }
            },
            playlistEnded : function() {
                // SMPHTML-1412
                cc.newPlaylist = false;
            },
            playlistLoaded : function(e) {
                if(e.playlist && e.playlist.allowContinuousCast) {
                    if(cc.activeSession) {
                        cc.player.config.suppressItemKind = ['ident'];
                    }
                    cc.newPlaylist = true;
                    cc.needSetUp = true;
                }
            },
            canplay : function() {
                if(cc.newPlaylist && cc.activeSession) {
                    cc.needSetUp = true;
                    cc.newPlaylist = false;  // reset don't want to play this again if there's no onward journey
                    cc.on();
                }
                if(cc.shortcutToProgramme) {
                    cc.player.pause();
                    cc.shortcutToProgramme = false;
                }
            }
        };
        return cc;
    };

    Chromecast.prototype = {
        toggle : function() {
            var cc = this;
            if (cc.isCasting) {
                cc.off();
            } else {
                cc.isAttemptingToCast = true;
                cc.on();
            }
            cc.player.dispatch({type:"chromecastToggle"});
        },
        on : function() {
            var cc = this;
            var mediaItem = cc.player.mediaItem;
            var subs = cc.player.Subtitles;
            var playlist = cc.player.playlist;

            cc.player.minimise();
            cc.player.pause();
            if (subs.showingSubs) {
                subs.clearSubtitles();
            }

            cc.player.ui.hideControlBar();

            Utils.asyncDelay(function() {
                cc.player.hidePlayer();
                cc.drawCastOverlay();
                //when cast initiated from ident cast the first programme instead
                if (!mediaItem.isProgramme) {
                    var newIndex = playlist.firstProgramme;
                    mediaItem = playlist.items[newIndex];
                    cc.player.next(); // move to next item in playlist
                    cc.shortcutToProgramme = true;
                    // suppress all future idents in when in cc state.
                    cc.player.config.suppressItemKind = ['ident'];
                }
                cc.player.dispatch({ type:"chromecast", active: true});
                cc.player.dispatch({ type:"ccRequest", data:{mediatorIdentifer:mediaItem.identifier} });
            });
        },
        off : function() {
            var cc = this;
            cc.player.dispatch({type:"chromecast", active: false});
            cc.player.dispatch({type:"notPlayingState"});
            cc.player.dispatch({type:"ccCancel"});
        },
        interrupt : function() {
            var cc = this;
            if (cc.isCasting) {
                cc.player.dispatch({type:"chromecast", active: false});
                cc.removeByClass('p_castOverlay');
                cc.isCastPlaying = false;
                cc.isCasting = false;
                cc.isAttemptingToCast = false;
                cc.isConnecting = false;
                cc.needSetUp = true;
                cc.player.dispatch({type:"ccInterrupt"});
            }
        },
        stopCastAttempt : function() {
            var cc = this;
            cc.stopCast();
        },
        connect : function() {
            var cc = this;
            cc.player.mediaPlayer.pause();
            cc.isConnecting = true;
            cc.isAttemptingToCast = true;
            cc.player.mediaPlayer.style.left = HIDDEN_PLAYER_MINIMODE;
            cc.drawCastOverlay();
            cc.player.dispatch({type:"ccConnect"});
        },
        playing : function(castObject) {
            var cc = this;

            cc.isAttemptingToCast = false;
            cc.isCastPlaying = true;
            cc.player.clearFakeTimer();

            //for first time set up since there's no connected state
            if (cc.needSetUp) {
                cc.initialSetUp(castObject);
            }

            if (castObject.currentTime) {
                cc.fakeTime = castObject.currentTime;
            } else {
                if (DEBUG_FULL) { console.log('Receiver did not have currentTime'); }
                cc.player.dispatch({type:"ccStopMedia"});
                return;
            }

            cc.player.fakeTimeupdateTimer = setInterval(function() {
                cc.player.dispatch({type:"timeupdate", fake:true});
                cc.fakeTime++;
                cc.player.ui.updateDisplayedProgress(cc.fakeTime,false);
            },1000);

            cc.drawCastOverlay();
            cc.player.dispatch({type:"playingState"});
        },
        paused : function() {
            var cc = this;
            cc.isCastPlaying = false;
            cc.player.clearFakeTimer();
            cc.player.ui.updateDisplayedProgress(cc.fakeTime,false);
            cc.drawCastOverlay();
            cc.player.dispatch({type:"notPlayingState"});
        },
        buffering : function() {
            var cc = this;
            cc.player.clearFakeTimer();
            cc.removeByClass('p_castIcon');
            cc.player.dispatch({type:"ccBuffering"});
        },
        stopped : function() {
            var cc = this;

            if (!cc.postInterrupt) {
                if (cc.shortcutToProgramme) {
                    cc.player.config.startTime = cc.fakeTime;
                    cc.player.config.suppressItemKind = ['ident'];
                    cc.player.pauseTimes.splice(0,0,cc.player.config.startTime);
                    cc.player.loadPlaylist(cc.player.playlist);
                    cc.player.startPlayback();
                } else {
                    cc.player.time = cc.fakeTime;
                    // no longer casting - reset suppressing of idents
                    cc.player.config.suppressItemKind = [];
                }          
            }

            cc.stopCast();
        },
        finished : function() {
            var cc = this;
            cc.player.delayedDispatch({type: "ended", fakeEnded:true});
            cc.fromQueuedPlaylist = cc.player.playlist.queuedPlaylist;
            if (!cc.player.playlist.queuedPlaylist) {
                cc.player.time = 0;
                cc.player.clearFakeTimer();
                cc.postInterrupt = false;
                cc.stopCast();
            } else {
                cc.isCastPlaying = false;
                cc.isCasting = false;
                cc.isAttemptingToCast = false;
                cc.isConnecting = false;
                cc.needSetUp = true;
                cc.player.dispatch({type:"notPlayingState"});
                cc.removeByClass('p_castOverlay');
            }
        },
        setCastPlayState : function() {
            var cc = this;
            if (cc.isCasting) {
                if (cc.isCastPlaying) {
                    cc.isCastPlaying = false;
                    cc.ccPause();
                } else {
                    cc.ccPlay();
                }
                return true;
            }
            return false;
        },
        initialSetUp : function(castObject) {
            var cc = this;
            var subs = cc.player.Subtitles;
            var MAX = 1;

            cc.duration = castObject.castDuration ? Math.floor(castObject.castDuration) : cc.player.duration;
            if ((cc.subtitlesEnabled || subs.showingSubs) && !castObject.subtitlesEnabled) { 
                cc.player.dispatch({type:"ccSubsOn"});
            }
            cc.player.volume = MAX;
            cc.player.ui.showControlBar();
            cc.needSetUp = false;
        },
        drawCastOverlay : function() {
            var cc = this;
            var ui = cc.player.ui;
            var castOverlay = createElement('div','p_castOverlay');
            var messageDiv = createElement('div', 'p_messageDiv');
            var castIcon = createElement('div', 'p_castIcon rippleEffect');
            var deviceName = cc.deviceId;
            var castMessage;
            var deviceMessage;
            var text;

            cc.removeByClass('p_castOverlay');
            ui.showPoster();


            if (cc.isConnecting) {
                text = Language.ccConnectingTo;
                Utils.className(document.body,"CCisConnecting","CCisCasting CCisAttemptingToCast");
            } else {
                if (cc.isAttemptingToCast) {
                    text = Language.ccSelectDevice;
                    deviceName = '';
                    updateExistingSvg(castIcon, ( ui.config.controls.chromecastMode !== 'catcast' ) ? 'chromecast' : 'catcast' );
                    Utils.className(document.body,"CCisAttemptingToCast","CCisCasting CCisConnecting");
                }
            }

            if (cc.isCasting) {
                text = Language.ccCastingTo;

                castOverlay.onclick = function () {
                    cc.setCastPlayState();
                };

                if (cc.isCastPlaying) {
                    updateExistingSvg(castIcon,'pause');
                } else {
                    updateExistingSvg(castIcon,'play');
                }

                Utils.className(document.body,"CCisCasting","CCisAttemptingToCast CCisConnecting");
            }

            castMessage = createElement('p', 'p_castMessage', '<span class="p_text" aria-hidden="true"></span>', text);
            deviceMessage = createElement('p', 'p_deviceMessage', '<span class="p_text" aria-hidden="true"></span>', deviceName);

            messageDiv.appendChild(castMessage);
            messageDiv.appendChild(deviceMessage);
            castOverlay.appendChild(messageDiv);
            castOverlay.appendChild(castIcon);
            ui.container.appendChild(castOverlay);

            if (cc.shiftCentralControls) {
                Utils.className(castOverlay,"shiftCentralControls","");
            } else {
                Utils.className(castOverlay,"","shiftCentralControls");
            }

        },
        removeByClass : function(className) {
            var cc = this;
            var items = cc.player.ui.container.getElementsByClassName(className);
            if (items.length) {
                items[0].parentNode.removeChild(items[0]);
            }
        },
        externalControlCheck : function(castObject) {
            //keeping track of control changes outside the player
            //e.g. muting/pausing via cast extension or iPlayer app
            //Needs a better name
            var cc = this;
            var subs = cc.player.Subtitles;
            if (castObject.subtitlesEnabled && (castObject.subtitlesEnabled !== cc.subtitlesEnabled) ) {
                cc.subtitlesEnabled = castObject.subtitlesEnabled;
                if (cc.subtitlesEnabled) {
                    subs.on();
                } else {
                    subs.off();
                }
            }

            if (castObject.floatVolume && castObject.floatVolume !== cc.player.volume) {
                cc.player.volume = castObject.floatVolume || 0.7; //reset to default vol
                // XXX why do we need to dispatch here, the volume
                // player set will dispatch?
                cc.player.dispatch({type:"volumechange", volume:cc.player.volume,muted:cc.player.muted});
            }
        },
        stopCast : function () {
            var cc = this;

            if (!cc.postInterrupt) {

                cc.isCastPlaying = false;
                cc.isCasting = false;
                cc.isAttemptingToCast = false;
                cc.isConnecting = false;
                cc.needSetUp = true;
                cc.player.dispatch({type:"notPlayingState"});
                cc.player.dispatch({type:"ccDisconnected"});
                cc.removeByClass('p_castOverlay');

                if (cc.newPlaylist) {
                   cc.postInterrupt = true;
                   return;
                }

                // dont hide holding image when stopping the media session that started from an ident
                // or if there's another playlist about to be played
                if (cc.player.playlist.allowContinuousCast && !cc.fromQueuedPlaylist) {
                    return;
                }
                if (cc.shortcutToProgramme) {
                    cc.shortcutToProgramme = false;
                    return;
                }

                cc.player.clearFakeTimer();

                cc.player.mediaPlayer.style.left = '0px';
                cc.player.ui.hidePoster();

                Utils.className(document.body,"","CCisCasting CCisConnecting CCisAttemptingToCast");
            }
            cc.postInterrupt = false;
        },
        //events to send to the receiver
        ccPlay : function() {
            var cc = this;
            cc.isCastPlaying = true;
            cc.player.dispatch({type:"ccPlay"});
        },
        ccPause : function() {
            var cc = this;
            cc.isCastPlaying = false;
            cc.player.dispatch({type:"ccPause"});
        },
        ccSeek : function(time) {
            var cc = this;
            if (cc.isCasting) {
                cc.fakeTime = time;
                cc.player.dispatch({type:"ccSeek", data: {seekTime: time} });
                return true;
            }
            return false;
        },
        ccVolume : function(vol) {
            var cc = this;
            cc.player.dispatch({type:"ccVolume", data: {floatVolume: vol} });
        },
        updateConfig : function(uiConfig) {
            var cc = this;
            cc.shiftCentralControls = uiConfig.chromecast && uiConfig.chromecast.shiftCentralControls;
            var castOverlay = document.getElementsByClassName('p_castOverlay')[0];
            if (castOverlay) {
                cc.removeByClass('p_castOverlay');
                cc.drawCastOverlay();
            }
        }
    };
    return Chromecast;
})();

var PictureInPicture = (function() {
     
    /**
     * Constructor for PictureInPicture class
     *
     */
    var PictureInPicture = function(player, ui) {

        var pIp = this;
        pIp.player = player;
        pIp.supported = false;
        pIp.func = function() {
            ui.player.dispatch({ type: ( pIp.isPlayingInPicture() ? "picInPicStarted" : "picInPicStopped")});
        };
        pIp.addedListeners={};

        return pIp;
    };

    PictureInPicture.prototype = {

        isSupported : function() {
            var pIp = this;
            var video = pIp.player.mediaPlayer;

            if ( (pIp.player.elType == "audio") || (pIp.player.elType == "unknown") ) {
                Utils.className(document.body, "", "picInPic");
                pIp.supported = false;
                return false;
            }

            var supportedByStandard = document.pictureInPictureEnabled && (typeof video.requestPictureInPicture === "function");
            var supportedByOpera = (typeof video.operaRequestDetachedView === "function");
            var supportedByApple = ( (typeof video.webkitSupportsPresentationMode === "function") && (video.webkitSupportsPresentationMode('picture-in-picture')) );


            var supported = supportedByStandard || supportedByApple || supportedByOpera;
            if (supported) {
                Utils.className(document.body, "picInPic", "");
                if (!pIp.addedListeners[video.id]) {
                    pIp.addedListeners[video.id] = true;
                    Utils.multiAddEventListener(video,"enterpictureinpicture leavepictureinpicture webkitpresentationmodechanged operadetachedviewchange",pIp.func);
                }
            } else {
                Utils.className(document.body, "", "picInPic");
            }
            pIp.supported = supported;
            
            return supported;
        },

        toggle : function() {
            var pIp = this;
            var video = pIp.player.mediaPlayer;

            if (document.pictureInPictureEnabled && document.exitPictureInPicture) {
                if (document.pictureInPictureElement) {
                    document.exitPictureInPicture();
                } else {
                    // XXX should we use the promise?
                    video.requestPictureInPicture();
                }
                return;
            }



            if (video.webkitSetPresentationMode) {
                video.webkitSetPresentationMode(video.webkitPresentationMode === "picture-in-picture" ? "inline" : "picture-in-picture");
            } else {
                if (video.operaRequestDetachedView) {
                    if (video.operaDetachedView) {
                        video.operaReleaseDetachedView();
                    } else {
                        if (pIp.player.isFullScreen) {
                            pIp.player.minimise();
                            setTimeout(function(){
                                video.operaRequestDetachedView();
                            }, 1500);
                        } else {
                            video.operaRequestDetachedView();
                        }
                    }
                }
            }
            
        },
        isPlayingInPicture : function() {
            var pIp = this;
            if (document.pictureInPictureEnabled && document.pictureInPictureElement) {
                return true;
            }
            if ( (typeof pIp.player.mediaPlayer.operaRequestDetachedView === "function") && (pIp.player.mediaPlayer.operaDetachedView === true) ) {
                return true;
            }

            var video = pIp.player.els.video;
            if ( (video.webkitPresentationMode) && (video.webkitPresentationMode === 'picture-in-picture') ) {
                return true;
            }

            return false;

        },
        exitPicInPic : function() {
            var pIp = this;
            if ( pIp.isPlayingInPicture() ) {


                if (document.pictureInPictureElement && document.exitPictureInPicture) {
                    document.exitPictureInPicture();
                }

                var video = pIp.player.els.video;
                if (DEBUG_FULL) { console.log("Exiting Pic in Pic mode"); }
                if (video.webkitSetPresentationMode) {
                    video.webkitSetPresentationMode("inline"); 
                } else {
                    if (video.operaReleaseDetachedView) {
                        video.operaReleaseDetachedView();
                    }
                }
            }
        }
    };
    return PictureInPicture;
})();
/**
 * MarkersUI - Chapters and Key moments
 *
 */
var MarkersUI = (function() {

    var CHAPTER_LIVE_FREQUENCY = 5000;
    var KEY_TIP_WITH_CHAPTER = 73;
    var KEY_TIP_WITH_NO_CHAPTER = 26;
    var CHAPTER_TIP = 44;
    
    var BLACK = 'rgb(25, 25, 25)';
    var WHITE = 'rgb(255, 255, 255)';
    var GRAY_TRANSPARENCY = 'rgba(178,178,178,0.6)';
    var WHITE_TRANSPARENCY = 'rgba(255,255,255,0.6)';
    
    function hexToRGBA(hexColour, solid) {
        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hexColour);
        var rgb = result ? parseInt(result[1], 16)+","+parseInt(result[2], 16)+","+parseInt(result[3], 16)+"," : "0,0,0,";
        var alpha = solid ? "1" : "0.33";
        return 'rgba(' + rgb + alpha +')';
    }
    
    function addUIListeners(uiItem, pressFunction, hoverFunction, focusFunction) {
        Utils.multiAddEventListener(uiItem,"click mouseup touchend keydown", pressFunction);
    
        if (focusFunction) {
            Utils.multiAddEventListener(uiItem,"focus blur", focusFunction);
        }
    
        if (hoverFunction) {
            Utils.multiAddEventListener(uiItem,"mouseover mouseout",hoverFunction);
        }
    }

    /**
     * Constructor for Markers UI class
     *
     */
     var MarkersUI = function(ui) {
        var markersUI = this;
        markersUI.chapterLastDrawTime = 0;

        markersUI.ui = ui;
        markersUI.keyTipBottom = KEY_TIP_WITH_CHAPTER;
        markersUI.markerDisplayHeight = 0;
        markersUI.storedChapterMarkers = [];
        markersUI.storedKeyMoments = [];

        return markersUI;
    };


     function generateRandomID(){
         return Math.random().toString(36).substr(2, 10);
     }


    function reportMarker(player, actionType, marker) {
        player.trackAction("marker", actionType, {start :  Math.floor(marker.start), marker_type : marker.type, id : marker.identifier });
    }

    function getMarkerPressed(markersUI, marker) {
        return Utils.getActionFn(function(actionType, event) {

            if (event.type == "keydown" && (event.keyCode != KEY_SPACE && event.keyCode != KEY_ENTER)) {
                return;
            }
            reportMarker(markersUI.ui.player, actionType, marker);
            if (event.type!="touchend" || ( markersUI.currentlyOver &&markersUI.currentlyOver._id == marker._id)) {
                markersUI.seekToChapterMarker(marker);
            } else {
                markersUI.markerMouseOut(markersUI.currentlyOver, true);
                markersUI.drawMarkerTip(marker);
                markersUI.markerMouseOver(marker);
            }
            if (event.preventDefault) {
                event.preventDefault();
            }
         });
    }

    function getMarkerTipPressed(markersUI, markerTip) {
        return Utils.getActionFn(function(actionType) {
            // XXX why markerTip and currentlyOver?
            reportMarker(markersUI.ui.player, actionType, markerTip);
            markersUI.seekToChapterMarker(markersUI.currentlyOver);
        });
    }

    function getMarkerHover(markersUI, marker) {
        return function(event) {            
            if (event.type=="mouseover") {
                markersUI.drawMarkerTip(marker);
                markersUI.markerMouseOver(marker);
            } else {
                markersUI.markerMouseOut(marker);
            }
        };
    }

    function getMarkerFocus(markersUI, marker) {
        return function(event) {
            var focus = (event.type == "focus");
            if (focus) {
                markersUI.currentlyOver = marker;
                markersUI.drawMarkerTip(marker);
            } else {
                markersUI.currentlyOver = null;
                markersUI.markerTip.style.display='none';  
            }
            Utils.setOrUnsetClass(marker,"p_highlighted",focus);
            if (isChapter(marker.type)) {
                markersUI.fillChapters();
            }
        };
    }

    function isChapter(type) {
        return (type === "chapter" || type === "programme");
    }

    function isKey(type) {
        return (type === "key" || type === "highlight");
    }

    function resetMarkerProgressFlags(markerData) {
        if (markerData && markerData.length>0) {
            markerData.forEach(function (element) {
               element.startFired = false;
               element.endFired = false;
            });
        }
    }

    function setMarkerProperties(marker, data) {
        if (isChapter(data.type)) {
            marker.firstChild.textContent = data.text ?  data.text : data.type;
            marker.available = (data.available !== false);
            marker.end = data.end;

        }
        marker.text = data.text;
        marker.description = data.description;
        marker.start = data.start;
        marker.type = data.type;
        marker.identifier = data.id;
    }


    MarkersUI.prototype = {
        getDefaultLeftMargin : function() {
            var markersUI = this;

            if (markersUI.ui.player.isFullScreen) {
                return 0;
            }
            return 16;
        },
        testDrawMarkers : function(force) {
            var markersUI = this;

            if (!markersUI._markerData || markersUI._markerData.length === 0) {
                return;
            }
            if (markersUI.ui.player.isLive) {
                var d=Utils.now();
                if (force || (d-markersUI.chapterLastDrawTime) > CHAPTER_LIVE_FREQUENCY) {
                    markersUI.chapterLastDrawTime = d;
                    markersUI.updateMarkers();
                }

            }
            markersUI.fillChapters();
        },
        getCurrentChapter: function() {
            var markersUI = this;
            var nowTime =  markersUI.ui.player.timeHelper.time;
            if (!markersUI._markerData) {
                return;
            }
            for ( var i = markersUI._markerData.length-1; i >=0; i-- )
            {
                var marker =  markersUI._markerData[i] || {};
                var start = marker.start;
                var end =  marker.end;
                if ( isChapter(marker.type) && nowTime >= start && (isNaN(end) || nowTime<=end) )
                {
                    return marker;
                }
            }
            return null;
        },
        // NEED TO CHECK LIVE MARKERS ARE WORKING
        reportProgress : function() {
            var markersUI = this;
            var start;
            var end;
            var nowTime = Math.round( markersUI.ui.player.time * 2 );

            for ( var i = 0; i < markersUI._markerData.length; i++ )
            {
                var marker = markersUI._markerData[i];
                start = marker.start;
                // The round and * 2 here means that it's accurate to
                // nearest 1/2 second which is roughly the frequency
                // of time update events to make this reliable.
                if ( nowTime ==  Math.round(start * 2) && !marker.startFired )
                {
                    marker.startFired = true;
                    markersUI.ui.player.delayedDispatch({type:"markerStart", id:marker.id},false);
                }

                if ((markersUI._markerData.length > 0)&& !isNaN( marker.end ))
                {
                    end = marker.end;
                    if (  nowTime == Math.round(end * 2) && !marker.endFired )
                    {
                        marker.endFired = true;
                        markersUI.ui.player.delayedDispatch({type:"markerEnd", id:marker.id},false);
                    }
                }
            }
        },
        resetProgress : function() {
            resetMarkerProgressFlags(this._markerData);
        },
        setMarkers : function(markerData) {
            var markersUI = this;

            markersUI.resetStoredMarkers();

            if (markerData && markerData.length){
                markerData.sort(Utils.sortByStart);
                for(var i = 0; i < markerData.length; i++){
                    var marker = markerData[i];
                    marker.startFired = marker.endFired = false;
                    if (!marker._id) {
                        marker._id = marker.id || generateRandomID();
                    }

                }
            }
            markersUI._markerData = markerData;

            Utils.className(markersUI.ui.container, "", "p_hasMarkers p_chapterOnly p_keyMomentOnly");
            markersUI.updateMarkers();   
        },

        updateMarkers : function() { //Update all data
            var markersUI = this;

            if (!markersUI.markersHolder) {
                return;
            }

            // hide markers below specified width if required, or if they are disabled in the ui config
            if ( (markersUI.ui.container.offsetWidth < markersUI.ui.config.markers.hideBelowWidth) || !markersUI._markerData || markersUI._markerData.length === 0 || (markersUI.ui.progressBar.getSeekBarOffsetWidth() < 10) || !markersUI.ui.config.markers.enabled) {
                // XXX all of this check the subs boundary, dispatch
                // info etc. should be refactored into a single call
                // so we don't forget any place we show/hide a
                // feature.
                Utils.className(markersUI.ui.container, "", "p_hasMarkers p_chapterOnly p_keyMomentOnly");
                markersUI.ui.UIinfoObject.markersBarVisible = false;
                markersUI.ui.player.Subtitles.updatePositions();
                markersUI.ui.dispatchUIInfo();
                return;
            }

            var chapters = Utils.getMarkerByType(markersUI._markerData,markersUI.ui.config.markers.suppressMarkerKinds,"chapter");
            var keys = Utils.getMarkerByType(markersUI._markerData,markersUI.ui.config.markers.suppressMarkerKinds,"key");

            for(var j = 0; j < markersUI.storedChapterMarkers.length; j++) {

                if (markersUI.storedChapterMarkers[j].end <= markersUI.ui.player.timeHelper.earliestSeek) {
                    var removed = markersUI.storedChapterMarkers.splice(j,1);
                    markersUI.markersHolder.removeChild(removed[0]);
                }

            }

            if (chapters.length > 0) {

                for (var i = 0; i < chapters.length; i++) {

                    if (i < (chapters.length - 1)) {
                        if (!chapters[i].end || (chapters[i].end > chapters[i + 1].start)) {
                            chapters[i].end = chapters[i + 1].start;
                        }
                    } else {
                        if (!chapters[i].end) {
                            chapters[i].end = Infinity;
                        }
                    }

                    if (chapters[i].start < markersUI.ui.player.timeHelper.streamEnd && chapters[i].end > markersUI.ui.player.timeHelper.earliestSeek) {
                        markersUI.checkChapterMarker(chapters[i]);
                    }

                }

                if (markersUI.storedChapterMarkers.length > 0) {
                    markersUI.fillChapters();
                    markersUI.updateItemsDisplayed(markersUI.storedChapterMarkers);
                }
                
            }

            for(var k = 0; k < markersUI.storedKeyMoments.length; k++) {

                if (markersUI.storedKeyMoments[k].start <= markersUI.ui.player.timeHelper.earliestSeek) {
                    removed = markersUI.storedKeyMoments.splice(k,1);
                    markersUI.markersHolder.removeChild(removed[0]);
                }

            }

            if (keys.length>0) {

                for (var m = 0; m < keys.length; m++) {

                    if (keys[m].start < markersUI.ui.player.timeHelper.streamEnd && keys[m].start > markersUI.ui.player.timeHelper.earliestSeek) {
                        markersUI.checkKeyMoment(keys[m]);
                    }

                }

                if (markersUI.storedKeyMoments.length > 0) {
                    markersUI.updateItemsDisplayed(markersUI.storedKeyMoments);
                }

            }

            markersUI.markerDisplayHeight = 0;
            if (markersUI.storedChapterMarkers.length === 0) { // no chapters
                if (markersUI.storedKeyMoments.length === 0) { // no chapters and no keys
                    Utils.className(markersUI.ui.container, "", "p_hasMarkers p_chapterOnly p_keyMomentOnly");
                } else { // no chapters but keys
                    markersUI.markerDisplayHeight = KEY_TIP_WITH_NO_CHAPTER;
                    Utils.className(markersUI.ui.container,"p_hasMarkers p_keyMomentOnly");
                    markersUI.keyTipBottom = KEY_TIP_WITH_NO_CHAPTER;
                }
            } else { // chapters
                if (markersUI.storedKeyMoments.length === 0) { // chapters but no keys
                    Utils.className(markersUI.ui.container,"p_hasMarkers p_chapterOnly");
                    markersUI.markerDisplayHeight = CHAPTER_TIP;
                } else { // chapters and keys
                    Utils.className(markersUI.ui.container,"p_hasMarkers");
                    markersUI.keyTipBottom = KEY_TIP_WITH_CHAPTER;
                    markersUI.markerDisplayHeight = KEY_TIP_WITH_CHAPTER;
                }
            }

            markersUI.markersHolder.style.height = markersUI.markerDisplayHeight+"px";
            markersUI.ui.player.Subtitles.updatePositions();
            markersUI.ui.dispatchUIInfo();
            
        },

        checkChapterMarker : function(data) { // Create and store new chapters, calculate boundaries
            var markersUI = this;

            var chapterMarker = Utils.getItemById(markersUI.storedChapterMarkers,data._id);
            if (!chapterMarker) {

                if (DEBUG_FULL) { console.log("Creating new marker for:"+data._id); }
                chapterMarker = createElement('div','p_chapterMarker','<span class="p_chapterMarkerText"></span>');
                addUIListeners(chapterMarker, getMarkerPressed(markersUI, chapterMarker), getMarkerHover(markersUI, chapterMarker), getMarkerFocus(markersUI, chapterMarker));

                chapterMarker._id = data._id;
                chapterMarker.tabIndex = '0';
                chapterMarker.setAttribute('role', 'button');
                setMarkerProperties(chapterMarker, data);

                markersUI.storedChapterMarkers.push(chapterMarker);

            }

            var marker = chapterMarker;

            var markerLeft = markersUI.ui.player.timeHelper.timeToPercent(marker.start) * markersUI.ui.progressBar.getSeekBarOffsetWidth() + markersUI.getDefaultLeftMargin();

            var markerRight = markersUI.ui.player.timeHelper.timeToPercent(marker.end) * markersUI.ui.progressBar.getSeekBarOffsetWidth() + markersUI.getDefaultLeftMargin();

            var markerWidth = Math.max(0, markerRight - markerLeft - 1);

            marker.style.left = markerLeft + "px";
            marker.style.width = markerWidth + "px";

        },

        checkKeyMoment : function(data) {
            var markersUI = this;

            var keyMoment = Utils.getItemById(markersUI.storedKeyMoments,data._id);
            if (!keyMoment) {

                keyMoment = createElement('div','p_keyMoment');
                keyMoment.appendChild( createElement('div','p_keyMomentSquare') );
                keyMoment.appendChild( createElement('div','p_timeTipTriangle p_keyMomentTipTriangle') );
                addUIListeners(keyMoment, getMarkerPressed(markersUI, keyMoment), getMarkerHover(markersUI, keyMoment), getMarkerFocus(markersUI, keyMoment));

                keyMoment._id = data._id;
                keyMoment.tabIndex = '0';
                keyMoment.setAttribute('role', 'button');
                setMarkerProperties(keyMoment, data);

                markersUI.storedKeyMoments.push(keyMoment);

            }

            var percent = markersUI.ui.player.timeHelper.timeToPercent(keyMoment.start);
            var left = (percent*markersUI.ui.progressBar.getSeekBarOffsetWidth()) + markersUI.getDefaultLeftMargin() - 7;

            keyMoment.style.left = left+"px";


        },

        updateItemsDisplayed : function(arr) { // Get the right key moments to display
            var markersUI = this;
            var existingMarkers;
            var insertAfterNode;

            if (arr.length > 0) {
                for(var i = 0; i < arr.length; i++) {
                    if (!markersUI.markersHolder.contains(arr[i])) {

                        if (isChapter(arr[i].type)) {
                            existingMarkers = markersUI.markersHolder.querySelectorAll('.p_chapterMarker');
                        } else {
                            existingMarkers = markersUI.markersHolder.querySelectorAll('.p_keyMoment');
                        }

                        if (existingMarkers.length) {
                            insertAfterNode = existingMarkers[existingMarkers.length-1];
                            insertAfterNode.parentNode.insertBefore(arr[i], insertAfterNode.nextSibling);
                        } else {
                            markersUI.markersHolder.appendChild(arr[i]);
                        }


                    }
                }
            }
        },

        fillChapters : function(time) {
            var markersUI = this;
            var livePoint = markersUI.ui.player.timeHelper.latestAllowableSeekTime;
            var currentTimeInChapter;
            var liveTimeInChapter;

            if (time == null || time === 0) {
                time = markersUI.ui.player.timeHelper.time;
            }

            for(var i = 0; i < markersUI.storedChapterMarkers.length; i++) {

                var marker = markersUI.storedChapterMarkers[i];

                var highlighted = (marker == markersUI.currentlyOver);

                if (i == (markersUI.storedChapterMarkers.length - 1)) {
                    currentTimeInChapter = time >= marker.start && time <= marker.end;
                    liveTimeInChapter =  livePoint >= marker.start && livePoint <= marker.end;
                } else {
                    currentTimeInChapter = time >= marker.start && time < marker.end;
                    liveTimeInChapter =  livePoint >= marker.start && livePoint < marker.end;
                }

                if (liveTimeInChapter) {
                    markersUI.fillLiveChapter(marker, highlighted);
                } else if (currentTimeInChapter) {
                    markersUI.fillCurrentChapter(marker, highlighted);
                } else {
                    markersUI.fillWholeChapter(marker, highlighted);
                }
            }
        },

        fillCurrentChapter: function(marker, highlighted) {

            var markerStart;
            var markerEnd;
            var time;
            var progressColour;
            var remainderColour;
            var textColour;

            var markersUI = this;

            time = markersUI.ui.player.timeHelper.time;
            markerStart = Math.max(marker.start, markersUI.ui.player.timeHelper.earliestSeek);
            markerEnd = Math.min(marker.end, markersUI.ui.player.timeHelper.streamEnd);

            var percent = ((time-markerStart)/(markerEnd-markerStart) * 100);

            if (highlighted) {
                progressColour = WHITE;
                remainderColour = WHITE_TRANSPARENCY;
                textColour = BLACK;
            } else {
                progressColour = hexToRGBA(markersUI.ui.config.colour, true);
                remainderColour = hexToRGBA(markersUI.ui.config.colour, false);
                textColour = markersUI.ui.config.foreColour;
            }

            markersUI.applyBackgroundColor(marker, progressColour, remainderColour, percent, textColour);

        },

        fillWholeChapter : function(marker, highlighted) {

            var markersUI = this;

            if (!marker.available || marker.start > markersUI.ui.player.timeHelper.latestAllowableSeekTime) {
                marker.style.background = GRAY_TRANSPARENCY;
                marker.style.color = WHITE;
                return;
            }

            if (highlighted) {
                marker.style.background = WHITE;
                marker.style.color = BLACK;
            } else {
                marker.style.background = BLACK;
                marker.style.color = WHITE;
            }

        },

        fillLiveChapter : function(marker, highlighted) {

            var markersUI = this;

            var markerStart;
            var markerEnd;
            var time;
            var livePoint;
            var leftColour;
            var middleColour;
            var rightColour;
            var textColor;


            time = markersUI.ui.player.timeHelper.time;
            livePoint = markersUI.ui.player.timeHelper.latestAllowableSeekTime;

            markerStart = Math.max(marker.start, markersUI.ui.player.timeHelper.earliestSeek);
            markerEnd = Math.min(marker.end, markersUI.ui.player.timeHelper.streamEnd);

            var livePercent = (livePoint-markerStart)/(markerEnd-markerStart)*100;

            if (time > markerStart && time <= markerEnd) {

                var currentPercent = (time-markerStart)/(markerEnd-markerStart)*100;

                if (highlighted) {
                    leftColour = WHITE;
                    middleColour = WHITE_TRANSPARENCY;
                    rightColour = GRAY_TRANSPARENCY;
                    textColor = BLACK;
                } else {
                    leftColour = hexToRGBA(markersUI.ui.config.colour, true);
                    middleColour = hexToRGBA(markersUI.ui.config.colour, false);
                    rightColour = GRAY_TRANSPARENCY;
                    textColor = markersUI.ui.config.foreColour;
                }
                markersUI.applyBackgroundColorThree(marker, leftColour, middleColour, rightColour, currentPercent, livePercent, textColor);

            } else {

                if (!marker.available) {
                    markersUI.fillWholeChapter(marker, highlighted);
                    return;
                }
                
                if (highlighted) {
                    leftColour = WHITE;
                    rightColour = GRAY_TRANSPARENCY;
                    textColor = BLACK;
                } else {
                    leftColour = BLACK;
                    rightColour = GRAY_TRANSPARENCY;
                    textColor = WHITE;
                }

                markersUI.applyBackgroundColor(marker, leftColour, rightColour, livePercent, textColor);

            }
        },

        applyBackgroundColor : function(marker, leftColour, rightColour, percent, textColor) {

            var styles = ["-webkit-linear-gradient(0deg, "+leftColour+" "+percent+"%, "+rightColour+" "+percent+"%)",
                          "-moz-linear-gradient(0deg, "+leftColour+" "+percent+"%, "+rightColour+" "+percent+"%)",
                          "-ms-linear-gradient(0deg, "+leftColour+" "+percent+"%, "+rightColour+" "+percent+"%)",
                          "-o-linear-gradient(0deg, "+leftColour+" "+percent+"%, "+rightColour+" "+percent+"%)"
                        ];

            for (var s=0; s < styles.length; s++) {
                var style = styles[s];
                marker.style.background = style;
                marker.style.color = textColor;
            }

        },

        applyBackgroundColorThree : function(marker, leftColour, middleColour, rightColour, percent, percent2, textColor) {

            var styles = ["-webkit-linear-gradient(0deg, "+leftColour+" "+percent+"%, "+middleColour+" "+percent+"%, "+middleColour+" "+percent2+"%, "+rightColour+" "+percent2+"%)",
                "-moz-linear-gradient(0deg, "+leftColour+" "+percent+"%, "+middleColour+" "+percent+"%, "+middleColour+" "+percent2+"%, "+rightColour+" "+percent2+"%)",
                "-ms-linear-gradient(0deg, "+leftColour+" "+percent+"%, "+middleColour+" "+percent+"%, "+middleColour+" "+percent2+"%, "+rightColour+" "+percent2+"%)",
                "-o-linear-gradient(0deg, "+leftColour+" "+percent+"%, "+middleColour+" "+percent+"%, "+middleColour+" "+percent2+"%, "+rightColour+" "+percent2+"%)"
            ];

            for (var s=0; s < styles.length; s++) {
                var style = styles[s];
                marker.style.background = style;
                marker.style.color = textColor;
            }

        },

        markerMouseOver : function(marker) {
            var markersUI=this;

            markersUI.currentlyOver=marker;
            Utils.className(marker,"p_highlighted");
            if (isChapter(marker.type)) {
                markersUI.fillChapters();
            }
        },

        markerMouseOut : function(marker,ignoreTip) {
            var markersUI=this;
            markersUI.currentlyOver = null;
            if (marker) {
                Utils.className(marker,"","p_highlighted");
                if (isChapter(marker.type)) {
                    markersUI.fillChapters();
                }
                if (!ignoreTip) {
                    markersUI.markerTip.style.display = 'none';
                }
            }
        },

        seekToChapterMarker : function(chapterMarker) {
            var markersUI=this;

            if (chapterMarker.start > markersUI.ui.player.timeHelper.latestAllowableSeekTime) {
                markersUI.ui.player.time=markersUI.ui.player.timeHelper.latestAllowableSeekTime;
                markersUI.ui.updateDisplayedProgress(markersUI.ui.player.timeHelper.latestAllowableSeekTime, false);
            } else {
                markersUI.ui.player.time=chapterMarker.start;
                markersUI.ui.updateDisplayedProgress(chapterMarker.start, false);
            }

            markersUI.markerTip.style.display='none';
            if (markersUI.currentlyOver) {
                markersUI.markerMouseOut(markersUI.currentlyOver);
            }
        },

        drawMarkerTip : function(marker) {
            var markersUI = this;
            var text;
            if (marker.description ) {
                text = marker.description;
            } else if (isKey(marker.type) || marker.offsetWidth<marker.scrollWidth) {
                text = marker.text || marker.type;
            } else {
                markersUI.markerTip.style.display='none';
                return;
            }
            var item = markersUI.markerTip; //drawItem;
            var originalText = item.firstChild.textContent;
            item.style.display="block";
            item.style.width = "auto";
            item.firstChild.textContent=text;
            item.start = marker.start;
            item.type = marker.type;
            markersUI.markerTip.style.bottom = (isKey(item.type) ? markersUI.keyTipBottom : CHAPTER_TIP)+"px";

            // get chapter marker midpoint
            var chapterMarkerLeft = parseFloat(marker.style.left);
            var chapterMarkerHalf = Math.floor(marker.offsetWidth/2);
            var chapterMidpoint =  chapterMarkerHalf + Math.floor(chapterMarkerLeft);
            var chapterTipHalf = Math.floor(item.offsetWidth/2);
            var newTipLeft = chapterMidpoint - chapterTipHalf;

            var leftCollisionCheck = false;
            if (newTipLeft < 1) {
                newTipLeft = 1;
                leftCollisionCheck = true;
            }

            // SMPHTML-878 prevent tooltip from wiggling unnecesarily
            if ( originalText==text && Math.abs( newTipLeft - parseInt(markersUI.markerTip.style.left,10) ) < 10 ) {
                return;
            }

            markersUI.markerTip.style.left = newTipLeft + "px";

            // Do the triangle, it's a child of chapterTip, so left is
            // from start of chapterTip
            var tipChapterDifference = chapterTipHalf - chapterMarkerHalf;
            var newTriangleLeft = tipChapterDifference + chapterMarkerHalf- Math.floor(markersUI.chapterTipTriangle.offsetWidth/2);

            if (newTriangleLeft < 1) {
                newTriangleLeft = 1;
            } else if (leftCollisionCheck) {
                if (chapterMidpoint <= item.offsetWidth) {
                    newTriangleLeft = chapterMidpoint- Math.floor(markersUI.chapterTipTriangle.offsetWidth/2);

                } else {
                    newTriangleLeft = item.offsetWidth - markersUI.chapterTipTriangle.offsetWidth;
                }
            }
            markersUI.chapterTipTriangle.style.left = newTriangleLeft + "px";
        },

        resetStoredMarkers : function() {
            var markersUI = this;

            markersUI._markerData = [];
            markersUI.storedChapterMarkers = [];
            markersUI.storedKeyMoments = [];
            if (markersUI.markersHolder) {
                while(markersUI.markersHolder.firstChild) {
                    markersUI.markersHolder.removeChild(markersUI.markersHolder.firstChild);
                }
                // create marker tip, maybe reconsider all this and
                // don't delete it each time?
                markersUI.markerTip = createElement('div','p_chapterTip','<span></span>');
                markersUI.chapterTipTriangle = createElement('div','p_timeTipTriangle');
                markersUI.markerTip.appendChild(markersUI.chapterTipTriangle);
                addUIListeners(markersUI.markerTip,getMarkerTipPressed(markersUI, markersUI.markerTip));
                markersUI.markersHolder.appendChild(markersUI.markerTip);
            }
        },
        resetMarkerTip : function() {
            var markersUI = this;
            if (markersUI.markerTip) {
                markersUI.markerTip.style.display ='none';
            }
        }
    };

    return MarkersUI;
})();
/**
 * Retreives and parses language xml
 *
 */

var Language = (function() {

   function parseLangXML(url,callback) {
       var cb = function(xmldoc) {
           try {
               callback(parseMessages(xmldoc));
           } catch (e) {
               if (DEBUG_FULL) { console.log("Language: Error parsing:",e); }
               // window.publicAPI an interesting thing here...
               Utils.callErrorFunction(window.publicApi, SMPError.LANGUAGE_FAILED, url,true);
           }
       };
       Utils.getXML(url,cb, cb, Language, true);
    }

    function parseMessages(xmlDoc) {
        var messages =  xmlDoc.getElementsByTagName('message');
        var len = messages.length;
        var obj = {};
        for (var i = 0; i<len; i++ ) {
            var msg = messages[i];
            obj[msg.getAttribute('name')] = msg.textContent;
        }
        return obj;
    }

    function getCodeFor(code) {
        if(Language.mappings[code]) {
            return Language.mappings[code];
        }
        return code;
    }

     /**
     * Constructor for Language class
     *
     */
    var Language = {
        code:"en",
        mappings : {
            'en-GB'   : 'en',
            'en-gb'   : 'en',
            'cy-GB'   : 'cy',
            'cy-gb'   : 'cy',
            'gd-GB'   : 'gd',
            'gd-gb'   : 'gd',
            'ga-GB'   : 'ga',
            'ga-gb'   : 'ga',
            'ru-uk'   : 'ru',
            'zh'      : 'zh-hans',
            'sr-latn' : 'sr'
        }
    };

    Language.en= {
        //Errors
        networkNotAvailable         : "It appears your network is not available at this time.",
        defaultErrorMessage         : "This content doesn't seem to be working.",
        codecErrorMessage           : "The content is not available in a compatible codec",
        contentNotAvailableOnDevice : "This content is not currently available on this device.",
        contentPostAvailability     : "This live stream has ended.",
        tryAgainLater               : "Please try again later.",
        tryAgain                    : "Try Again",
        programmePreAvailability    : "This programme is not available to play yet.",
        programmeRegionRestriction  : "This content is not available in your location.",
        itemRevoked : "This content is no longer available",
        httpsOnlyFailure : "The content you want to play is not available over a secure connection. It may be available over a non-secure connection. Would you like to try this?",

        viewThisContentOnTheBBC : "More from the BBC",
        insufficientBandwidth : "Sorry, you don't have enough bandwidth to play this right now.",
        //Not currently translated
        guidanceStateOff1Text : "Turn Parental Guidance Lock on",
        guidanceStateOff2Text : "Visit BBC Guidance to change settings.",
        guidanceStateOn1Text : "Turn Parental Guidance Lock off",
        guidanceStateOn2Text : "Visit BBC Guidance to change settings.",

        volumeControlDescription : "Use the arrow keys to increase and decrease the volume",
        audioToolTipBuffering : "Buffering",
        seekBarDescription : "Use the arrow keys to forward and rewind",

        audioToolTipSeekBarPrefix : "Playback time is",
        audioToolTipSeekBarSuffix : "of",

        audioToolTipVolumeMuted: "Muted",
        audioToolTipVolume1 : "Volume level 1",
        audioToolTipVolume2 : "Volume level 2",
        audioToolTipVolume3 : "Volume level 3",
        audioToolTipVolume4 : "Volume level 4",
        audioToolTipVolume5 : "Volume level 5",
        audioToolTipVolume6 : "Volume level 6",
        audioToolTipVolume7 : "Volume level 7",
        audioToolTipVolume8 : "Volume level 8",
        audioToolTipVolume9 : "Volume level 9",
        audioToolTipVolume10 : "Volume level 10",
        audioToolTipVolume11 : "Volume level 11",

        //Tooltips
        toolTipEnterFullScreen  : "Enter full screen",
        toolTipExitFullScreen   : "Exit full screen",
        toolTipPause            : "Pause",
        toolTipPlay             : "Play",
        toolTipPlayAgain        : "Play this again",
        toolTipSubtitlesOn      : "Turn subtitles on",
        toolTipSubtitlesOff     : "Turn subtitles off",
        toolTipClosedCaptionsOn : "Turn closed captions on",
        toolTipClosedCaptionsOff: "Turn closed captions off",
        toolTipEmbed            : "Get embed code",
        toolTipMute             : "Mute",
        toolTipUnmute           : "Unmute",
        toolTipCTAPlay          : "Play {title}",
        toolTipFrameMedia       : "{title} Media",

        toolTipChromecast       : "Cast this programme",
        toolTipStopChromecast   : "Stop casting",

        seekBarName          : "Seek bar",

        toolTipPicInPic         : "Open Picture in Picture mode",
        toolTipStopPicInPic     : "Exit Picture in Picture mode",

        openSubtitlesMenuAndTurnOnSubs: "Turn subtitles on and open subtitles settings menu",
        openSubtitlesMenu: "Open subtitles settings menu",
        closeSubtitlesMenu: "Close subtitles settings menu",
        subtitles: "Subtitles",
        openClosedCaptionsMenuAndTurnOnCC: "Turn closed captions on and open closed captions settings menu",
        openClosedCaptionsMenu: "Open closed captions settings menu",
        closeClosedCaptionsMenu: "Close closed captions settings menu",
        closedCaptions: "Closed Captions",
        off: "OFF",
        on: "ON",
        useSmallestFontSize: "Use font size: Smallest",
        useSmallFontSize: "Use font size: Small",
        useMediumFontSize: "Use font size: Medium",
        useLargeFontSize: "Use font size: Large",
        useLargestFontSize: "Use font size: Largest",
        aa: "Aa",

        // PLAYBACK SETTINGS MENU --- --- WAITING for translations --- ---
        playbackSettingsHeading: "Playback settings",
        autoplaySettingHeading: "Autoplay",
        autoplaySettingSubheading: "Play next item automatically",
        openPlaybackSettingsMenu: "Open playback settings menu",
        closePlaybackSettingsMenu: "Close playback settings menu",
        openPlaybackSettingsMenuNew: "Open playback settings menu for autoplay and video quality settings",

        qualitySettingHeading: 'Video quality',
        qualityPanelLowRowHeading: 'Low',
        qualityPanelMediumRowHeading: 'Medium',
        qualityPanelHighRowHeading: 'Highest available',
        qualityPanelHighRowSubtitle: 'Automatically selects the best quality available',

        autoplaySettingGenericLabel: "Autoplay. Play next item automatically",
        qualitySettingOpenHighSelected : 'Video quality. Highest available is currently selected. Open video quality settings',
        qualitySettingOpenMediumSelected : 'Video quality. Medium quality is currently selected. Open video quality settings',
        qualitySettingOpenLowSelected : 'Video quality. Low quality is currently selected. Open video quality settings',
        qualitySettingOpenUnavailable: 'Currently unavailable',
        qualitySettingOpenUnavailableAccessible: 'Video quality settings are currently unavailable', //adding this one as it may be useful, ask confirmation about the message if used.
        qualitySettingInfo : 'Video quality options',
        qualitySettingLowSelect : 'Low quality',
        qualitySettingLowSelected : 'Low quality selected',
        qualitySettingMediumSelect : 'Medium quality',
        qualitySettingMediumSelected : 'Medium quality selected',
        qualitySettingHighSelect : 'Highest quality available',
        qualitySettingHighSelected : 'Highest quality available selected',
        // --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---



        //cast messages
        ccSelectDevice : "Select casting device...",
        ccConnectingTo : "Connecting to",
        ccCastingTo    : "Casting to",

        errorFlashPlayerNotInstalled : 'You need to install Flash Player to play this content.',
        errorFlashIsNeeded : "Sorry, you need Flash to play this.",
        enableFlash : "Enable it in your browser or {link}.",
        enableFlashShort : "Enable it or {link}.",
        downloadFlashLink: "download Flash Player here",

        errorUnsupported : 'Your device is not currently supported',
        errorCantPlayInBrowser : "Sorry, this won't play in your web browser.",
        useMediaPlayerApp : "Use BBC Media Player app",

        //Age Confirmation Screen
        pgHeader : 'Parental Guidance Lock',
        pgAgeConfirmation : 'I am aged 16 or over',
        pgClose : 'Close pop up',
        pgContinue : 'Continue',
        pgPasswordValidationError : 'Please confirm your age before continuing',
        pgAriaAgeConfirmCheckBox : 'Age confirmation check box. Checked.',
        pgAriaAgeConfirmCheckBoxUnchecked : 'Age confirmation check box. Check to confirm you are sixteen or over.',
        
        //Parental Guidance Lock Info Screen
        pgTurnOnParentalGuidance : 'Turn on the Parental Guidance Lock?',
        pgInfoPlusDownload : "lets you set up a PIN to control access to Guidance-labelled BBC content on your chosen browser.<p>To set up your PIN choose 'Turn On'. To continue without Parental Guidance choose 'Download'.</p>",
        pgInfoPlusPlay : "lets you set up a PIN to control access to Guidance-labelled BBC content on your chosen browser.<p>To set up your PIN choose 'Turn On'. To continue without Parental Guidance choose 'Play'.</p>",
        pgInfo : 'lets you set up a PIN to control access to Guidance-labelled BBC content on your chosen browser.',
        
        pgTurnOn : 'Turn On',
        
        //Set up PIN Screen
        pgEnterPIN : 'Please enter a four-digit PIN',
        pgActivateInfo : 'You will need your PIN to play Guidance-labelled content',
        pgPINValidationError : 'Your PIN must be four digits',
        pgAriaPINEntryDescription  : 'PIN entry text field',
        pgAriaPINPrompt : 'Please enter a valid four-digit PIN',
        
        //Enter PIN Screen
        pgEnterPINPrompt : 'Please enter your four-digit PIN to continue',
        pgManageYourPIN : 'Manage your PIN',
        pgUnlock : 'Unlock',
        pgIncorrectPIN : 'Incorrect PIN. Please try again',
        
        
        // ADD TO TRANS
        pgDownload : 'Download',
        pgActivate : 'Activate',

        // WIP NEW PG MP-2956
        newPgTurnOnParentalGuidance : 'Turn on Parental Guidance Lock?',
        newPgTurnOnParentalGuidancePINsection : 'Turn on Parental Guidance Lock',
        newPgTurnOnParentalGuidanceInsertPIN : 'Parental Guidance Lock',
        newPgTurnOn : 'Turn on PG Lock', 
        newToolTipPlay : 'Play without PG Lock', 
        findOutMore : 'Find out more', 
        notSuitableForChildMessage : "This programme may not be suitable for children. Turn on PG Lock and we'll ask you to set up a PIN to control who can watch BBC content with a Guidance label on this browser.",
        newPgAgeConfirmationUnder16 : "I've got permission.",
        newUnder16WithPermission : "You're signed in as someone who's under 16. So you need permission from a parent or guardian to play this.",
        newPgPlay : 'Play',
        newPgEnterPIN : 'Please choose a four-digit PIN.',
        newPgPINvalidationError : 'Your PIN must be four digits long.', 
        newPgIncorrectPIN : 'Wrong PIN. Please try again.',
        newPgManageYourPIN : 'Manage your lock',
        newPgEnterPINprompt : 'Please enter your four-digit PIN.',
        newPgActivateInfo : "You'll need this to play any content with a Guidance label.",
        newPgEnterPINinfo :'This programme has a Guidance label.',
        newAgeConfirmationTitle : 'Guidance',
        pgUnder16PermissionValidationError : 'Please confirm you have permission before continuing',

        //Audio UI
        skipBack: 'Skip back {seconds} seconds',
        skipForward: 'Skip forward {seconds} seconds',
        listenFromStart: 'Listen from start',
        goToLivePoint: 'Go to live point',
        previousItem: 'Previous item',
        nextItem: 'Next item',
        popOutPlayer: 'Pop-out player'

    };

    function languageUpdate() {
        var lang=Language[Language.code];
        if (lang) {
            for (var i in lang) {
                if (lang.hasOwnProperty(i)) {
                    Language[i] = lang[i];
                }
            }
        } else {
            languageLoad(Language.code);
        }
    }

    function isValid( code ) {
        if ( code ) {
            return (/^[\-a-zA-Z]{1,8}$/).test( code );
        }
        return false;
    }

    function languageLoad(code) {
        if ( isValid( code ) ) {
            var callback = function(lang) {
                Language[code] = lang;
                languageUpdate();
                Language.updated();
            };
            var url = Language.path.replace("{lang}",code);
            parseLangXML(url,callback);
        } else {
            if (DEBUG_FULL) { console.error("Language code:"+code+" is not considered valid, not loading"); }
        }
    }

    Language.get = function(name,obj) {
        var str = Language[name];
        if (!str) {
            return "";
        }
        for (var i in obj) {
            if (obj.hasOwnProperty(i)) {
                var val=obj[i] || "";
                str = str.replace("{"+i+"}",val);
            }
        }
        return str;
    };

    Language.init = function(obj,callback) {
        var code = obj.lang;
        // XXX why does this strip off the domain? - Because you
        // can inject html via the language script so locking it to
        // same domain as player is one route to securing it.
        Language.path = obj.path.replace(/\/\/.*?\//,'/');
        Language.code = getCodeFor(code);

        // populate english as the default;
        var lang = Language.en;
        for (var i in lang) {
            if (lang.hasOwnProperty(i)) {
                Language[i] = lang[i];
            }
        }

        languageUpdate();
        Language.updated = callback;
    };

    return Language;
})();


var ScreenReader = (function() {

  var DELAY = 500;
  var timer;
  var alertElement;

  function realAlert(message) {
      alertElement = document.getElementById('p_alert');
      alertElement.innerHTML = "<p></p>";
      alertElement.firstChild.textContent = message;
      alertElement.style.display = "block";
  }

  function alert(message) {
      clearTimeout(timer);
      timer = setTimeout(realAlert,DELAY,message);
  }

  function buffering(hide) {
      if (hide) {
          clearTimeout(timer);
          if (alertElement) {
              alertElement.innerHTML = "";
              alertElement.style.display = "none";
          }
      } else {
          alert(Language.audioToolTipBuffering);
      }
  }
  var ScreenReader = {
      alert: alert,
      buffering: buffering
  };
  return ScreenReader;
})();

var ParentalGuidance = (function() {

    var background, popup, body, footer, exitLink, header, pinEntry;
    var _currentTab, _tabList;
    var _ageConfirmation;
    var _lockClicked;
    var fromKey;


    //  Constructor for Parental Guidance Class
    var ParentalGuidance = function(ui, player) {
     
        var pG = this;
        pG.ui = ui;
        pG.player = player;

        pG.nowShowing = false;

        _tabList = [];
        _ageConfirmation = false;


        pG.isOver16 = player.config.over16;
        pG.isUnder16 = player.config.under16;
            
        // if both setting are set to true
        // we prefer under16
        if (pG.isOver16 && pG.isUnder16) {
            pG.isOver16 = false;
        }

        return pG;
    };

    function addOnOverListener(parentalGuidance, elementID, isButton) {
        var element = document.getElementById(elementID);

        var onMouseOver = function() {
            element.style.transition = '0.3s';

            if (isButton) {
                element.style.backgroundColor = parentalGuidance.player.config.ui.guidance.pgColour;
            } else {
                element.style.color = parentalGuidance.player.config.ui.guidance.pgColour;
            }
        };

        var onMouseOut = function() {
            element.style.transition = '0.3s';

            if (isButton) {
                element.style.backgroundColor = parentalGuidance.player.config.ui.guidance.pgBackgroundColour;
            } else {
                element.style.color = '#ffffff';
            }
            
        };

        element.onmouseover = element.onfocus = onMouseOver;
        element.onmouseout = element.onblur = onMouseOut;
    }


    function disableTouch(e) {
        if (e.preventDefault) {
            e.preventDefault();
        } else {
            e.returnValue = false;
        }
    }


    //Removes all child nodes of object
    function clearNode(node) {
        while (node.lastChild) {
            node.removeChild(node.lastChild);
        }
    }


    function addToKeyboardTrap(element, focus) {
        _tabList.push(element);
        element.setAttribute('tabindex', '0');

        element.onkeydown = function(e) {
            e = e || window.event;
            var keyCode = e.keyCode || e.which;
            if (keyCode != 9 && keyCode != 13) {
                return;
            }
            disableTouch(e);
            if (keyCode == 9) {  //Override tab controls to tab loop inside popup and prevent focus from moving to the page underneath

                var tl1=_tabList.length-1;
                if (e.shiftKey) {
                    _currentTab = (_currentTab === 0) ? tl1 : _currentTab - 1;
                } else {
                    _currentTab = (_currentTab === tl1) ? 0 : _currentTab + 1;
                }

                setTimeout(function () {
                    _tabList[_currentTab].focus();
                }, 200);
            } else {
                // Must be 13 so treat as click
                setTimeout(function () {
                    fromKey = true;
                    element.click();
                }, 200);
            }
        };

        if (focus) {
            _currentTab = _tabList.length-1;
            element.focus();
        }
    }


    function clearKeyboardTrap() {
        _currentTab = 0;
        _tabList = [];
        addToKeyboardTrap(exitLink);
    }


    function renderAgeConfirmationCheckbox(box, firstTimeShowing, parentalGuidance) {
        
        if (firstTimeShowing && parentalGuidance && parentalGuidance.isUnder16) {
            _ageConfirmation = false;
        }

        var l="";
        if (_ageConfirmation) {
            box.style.backgroundPosition  = 'center';
            l = Language.pgAriaAgeConfirmCheckBox;
        } else {
            box.style.backgroundPosition = '-30px';
            l = Language.pgAriaAgeConfirmCheckBoxUnchecked;
        }
        box.setAttribute('aria-label', l);
        box.textContent = box.innerText = l;
    }


    function renderError(container, message, insertBefore, parentalGuidance) {
        var errorContainer = document.getElementById('pgErrorMessage');
        var needPINinfo = document.getElementById('needPINinfo');

        if (errorContainer) {
            clearNode(errorContainer);
        } else {
            errorContainer = document.createElement('div');
            errorContainer.id = 'pgErrorMessage';
            var ecs=errorContainer.style;
            ecs.width = popup.style.width;
            ecs.backgroundColor = parentalGuidance.player.config.ui.guidance.pgSeparatorColour;
            ecs.marginTop = '15px';
            ecs.marginBottom = '5px';
            ecs.position = 'relative';
        }


        if (insertBefore) {
            container.insertBefore(errorContainer, container.firstChild);
        } else {

            if (needPINinfo) {
                needPINinfo.appendChild(errorContainer);
            } else {
                container.appendChild(errorContainer);
            }
     
        }

        var error = document.createElement('div');
        var es=error.style;
        es.fontSize = '14px';
        es.position = 'relative';
        es.width = '100%';
        es.color = '#ffffff';
        es.fontSize = '11px';
        es.textAlign = 'center';
        es.paddingTop = es.paddingBottom = '10px';
        es.lineHeight = '23px';

        if (parentalGuidance.ui.config.useHighResIcons) {   
            var messageDiv = document.createElement('div');
            messageDiv.innerHTML = message;
            messageDiv.style.display = "inline-block";
            messageDiv.style.marginLeft = "5px";

            var alertIconContainer = document.createElement('div');
            var aCs = alertIconContainer.style;
            aCs.width = aCs.height = "18px";
            aCs.display = "inline-block";

            var svgIcon = Utils.generateSVG(18,18,'guidance-alert','p_guidance-alertIcon');
            svgIcon.style.top="4px";

            alertIconContainer.appendChild(svgIcon);
            error.appendChild(alertIconContainer);
            error.appendChild(messageDiv);
        } else {
            error.innerHTML = '<span style="display:inline-block;  background-image: url(//emp.stage.bbci.co.uk/emp/assets/2.0.23/alert-color.png); background-repeat: no-repeat; background-size: 100% 100%; margin-right:5px; width:15px; height:13px;"></span>' + message;
        }
        
        errorContainer.appendChild(error);
    }


    function renderGuidance(parentalGuidance, guidanceContainer) {

        if (background) {
            // already rendered
            return false;
        }

        parentalGuidance.nowShowing = true;
        document.body.style.cursor = 'default';

        //Guidance background
        background = document.createElement("div");
        background.setAttribute('tabindex', '0');
        background.id = "parentalGuidanceBackground";
        background.className = "smpPG p_parentGuidanceBackground";

        //Guidance window popup
        popup = document.createElement("div");
        popup.id = "guidancePopup";
        popup.style.backgroundColor = parentalGuidance.player.config.ui.guidance.pgBackgroundColour;
        popup.setAttribute('role','alertdialog');
        popup.setAttribute('aria-labelledby','pgHeaderTitle');
        popup.className = "smpPG p_parentalGuidancePopup";

        guidanceContainer.appendChild(background);
        guidanceContainer.appendChild(popup);

        //Escape key listener for accessibility
        popup.onkeydown = function(e) {
            e = e || window.event;
            var keyCode = e.keyCode || e.which;
            if (keyCode === 27) {
                parentalGuidance.close(false);
            }
        };

        //Inner padding
        var container = document.createElement('div');
        container.id = "guidanceContainer";
        popup.appendChild(container);

        //Guidance Header
        var head =  document.createElement('div');
        head.id = 'pgHeaderTitle';
        container.appendChild(head);

        header = document.createElement('span');
        header.innerHTML = Language.pgHeader;
        header.id = 'pgHeader';
        header.style.color = parentalGuidance.player.config.ui.guidance.pgColour;
        head.appendChild(header);

        //Body
        body = document.createElement('div');
        body.id = "guidanceBody";
        container.appendChild(body);

        //Footer
        footer = document.createElement('div');
        footer.id = "guidanceFooter";
        popup.appendChild(footer);

        //Exit link
        exitLink = document.createElement('a');
        exitLink.setAttribute('aria-label', Language.pgClose);
        exitLink.id = 'pgExit';
        var es=exitLink.style;
        exitLink.title = Language.pgClose;
        
        if (parentalGuidance.ui.config.useHighResIcons) {
            var SVGicon = Utils.generateSVG(18,18,'gel-exitLink','p_gel-exitLinkIcon');
            exitLink.appendChild(SVGicon);
        } else {
            es.backgroundImage = 'url(//emp.stage.bbci.co.uk/emp/assets/2.0.23/GEL_Remove_icon.png)';
        }

        es.backgroundRepeat = 'no-repeat';
        popup.appendChild(exitLink);

        var allowClick = false;
        setTimeout(function() {
                       allowClick=true;
                   },500);


        exitLink.onclick = function(e) {
            if (allowClick) {
                e = e || window.event;
                disableTouch(e);
                parentalGuidance.player.trackAction(exitLink, fromKey ? 'key_press' :'click');
                fromKey = false;
                parentalGuidance.close(false);
            }
        };

        // var onMouseOver = function() {
        //     if (!SVGicon) {
        //         es.transition = 'background-image 0.2s ease-in-out';
        //         es.backgroundImage = 'url(//emp.stage.bbci.co.uk/emp/assets/2.0.23/GEL_Remove_icon_hover.png)';
        //     }
        // };
        //
        // var onMouseOut = function() {
        //     if (!SVGicon) {
        //         es.transition = 'background-image 0.2s ease-in-out';
        //         es.backgroundImage = 'url(//emp.stage.bbci.co.uk/emp/assets/2.0.23/GEL_Remove_icon.png)';
        //     }
        // };
        //
        // exitLink.onmouseover = exitLink.onfocus = onMouseOver;
        // exitLink.onmouseout = exitLink.onblur = onMouseOut;
        return true;
    }


    function renderDivider(parentalGuidance, container) {
        var divider = document.createElement('div');
        var ds=divider.style;
        ds.marginTop = '-1px';
        ds.position = 'absolute';
        ds.width = '100%';
        ds.height = '1px';
        ds.backgroundColor = parentalGuidance.player.config.ui.guidance.pgSeparatorColour;
        container.appendChild(divider);
    }


    function renderButton(parentalGuidance, data) {
        var button = document.createElement('a');
        button.id = data.id;
        button.innerHTML = data.text;
        button.setAttribute('aria-label', data.text + ' button');
        var bs=button.style;
        bs.cursor = 'pointer';
        try {
            bs.display = 'table';
        } catch (e) {
            bs.display = 'block';
        }
        bs.lineHeight = '3.5';

        bs.width = '100%';
        bs.fontSize = '14px';

        bs.color = '#ffffff';
        footer.appendChild(button);
        bs.backgroundColor = parentalGuidance.player.config.ui.guidance.pgBackgroundColour;

        addOnOverListener(parentalGuidance, data.id, true);

        var allowClick=false;
        setTimeout(function() {
                       allowClick=true;
                   },500);

        var cf=data.clickFunction;
        function clickFunction() {
            if (allowClick) {

                parentalGuidance.player.trackAction(button.id, fromKey ? 'key_press' :'click');
                fromKey = false;
                cf();
            }
        }

        button.onclick = clickFunction;
        addToKeyboardTrap( button, data.focus);
        return button;
    }


    function renderFooter(parentalGuidance, buttonOne, buttonTwo) {
        clearNode(footer);
        renderDivider(parentalGuidance, footer);

        var b1 = renderButton(parentalGuidance, buttonOne);
        if (buttonTwo) {
            b1.style.borderBottom = '1px solid ' + parentalGuidance.player.config.ui.guidance.pgSeparatorColour;
            renderButton(parentalGuidance, buttonTwo);
        }
    }


    function showAgeConfirmation(parentalGuidance, guidanceText) {
        clearNode(body);
        clearKeyboardTrap();

        //Guidance message
        var guidanceMessageContainer = document.createElement('div');
        guidanceMessageContainer.id = 'guidanceMessage';
        var gmcs = guidanceMessageContainer.style;
        gmcs.marginTop = parentalGuidance.ui.config.useHighResIcons ? '0' : '15px';
        gmcs.marginBottom = '5px';
        gmcs.width = '100%';
        gmcs.position = 'relative';
        gmcs.fontSize = '13px';
        body.appendChild(guidanceMessageContainer);

        updateHeaderTitle('newAgeConfirmationTitle');

        if (parentalGuidance.ui.config.useHighResIcons) {
            var iconContainer = document.createElement('div');
            iconContainer.id = 'guidanceG';
            iconContainer.style.display = 'inline-block';

            var svgIcon = Utils.generateSVG(44,44,'guidance','p_guidanceIcon');
            svgIcon.style.top="10px";
            iconContainer.appendChild(svgIcon);

            guidanceMessageContainer.appendChild(iconContainer);
        } else {
            //Red circle
            var circleContainer = document.createElement('div');
            circleContainer.id = 'guidanceG';
            var ccs= circleContainer.style;
            ccs.display = 'inline-block';
            ccs.margin = 'auto';
            ccs.borderRadius = '50%';
            ccs.width = ccs.height = '15px';
            ccs.backgroundColor = 'red';
            ccs.position = 'relative';
            ccs.top = '-2px';
            ccs.fontSize = '12px';
            guidanceMessageContainer.appendChild(circleContainer);

            var g = document.createElement('span');
            g.innerHTML = 'G';
            var gs=g.style;
            gs.lineHeight = 'normal';
            gs.position = 'relative';
            gs.left = '-0.5px';
            gs.top = '1px';
            gs.color = '#ffffff';
            circleContainer.appendChild(g);

            guidanceMessageContainer.appendChild(circleContainer);
        }

        //Guidance warning text
        var guidance = document.createElement('span');
        guidance.id = 'guidanceText';
        guidance.innerHTML =  parentalGuidance.isUnder16 ? (guidanceText + '</br></br>' + Language.newUnder16WithPermission) : guidanceText;
        gs = guidance.style;
        gs.left = '0px';
        gs.top = '16px';
        gs.marginLeft = parentalGuidance.ui.config.useHighResIcons ? '0' : '5px';
        gs.lineHeight = '16px';
        gs.color = '#b2b7c4';
        guidanceMessageContainer.appendChild(guidance);

        //Age confirmation check box
        var confirmationContainer = document.createElement('div');
        confirmationContainer.id = 'ageConfirm';
        var conCs = confirmationContainer.style;
        conCs.width = '100%'; //is this needed?
        conCs.height = '57px';
        conCs.position = 'relative';
        conCs.fontSize = '14px';
        conCs.color = '#ffffff';

        // IE11 need this
        conCs.display = '-ms-inline-flexbox';
        conCs.justifyContent = 'center';

        body.appendChild(confirmationContainer);

        var checkBox = document.createElement('button');
        checkBox.id = 'ageConfirmCheck';
        var cbs=checkBox.style;
        cbs.background = 'url(//emp.stage.bbci.co.uk/emp/assets/2.0.23/tick.png) no-repeat center';
        cbs.backgroundPosition = '-30px';
        cbs.position = 'absolute';
        cbs.top = '16px';
        cbs.height = cbs.width = '25px';
        cbs.cursor = 'pointer';
        cbs.backgroundColor = '#ffffff';
        cbs.borderWidth="0";
        cbs.textIndent="-9999px";
        cbs.whiteSpace="nowrap";
        cbs.overflow="hidden";
        confirmationContainer.appendChild(checkBox);
        addToKeyboardTrap( checkBox, true);

        renderAgeConfirmationCheckbox(checkBox, true, parentalGuidance);

        var checkBoxText = document.createElement('span');
        checkBoxText.innerHTML = parentalGuidance.isUnder16 ? Language.newPgAgeConfirmationUnder16 : Language.pgAgeConfirmation;
        checkBoxText.style.position = 'relative';
        checkBoxText.style.top = '20px';
        checkBoxText.style.marginLeft = '35px';
        confirmationContainer.appendChild(checkBoxText);

        var allowClick = false;
        setTimeout(function() {
                       allowClick=true;
                   },500);

        checkBox.onclick = function() {
            if (allowClick) {
                _ageConfirmation=!_ageConfirmation;
                renderAgeConfirmationCheckbox(checkBox);
            }
        };

        var onContinueClick = function() {

            if (parentalGuidance.isUnder16 && _ageConfirmation) {
                parentalGuidance.player.dispatch({type:'setGuidanceSkipped', skipped:true});
                parentalGuidance.player.dispatch({type:'setUnder16Permission', hasPermission:true});
                parentalGuidance.close(true);
            } else if (_ageConfirmation) {
                showParentalGuidanceInformation(parentalGuidance);
            } else {
                var message = parentalGuidance.isUnder16 ? Language.pgUnder16PermissionValidationError : Language.pgPasswordValidationError;
                renderError(guidanceMessageContainer, message, false, parentalGuidance);
            }
        };

        var buttonText = parentalGuidance.isUnder16 ? Language.newPgPlay : Language.pgContinue;

        renderFooter(parentalGuidance, {id : "pgAgeContinue", text : buttonText, clickFunction : onContinueClick});
    }

    
    function updateHeaderTitle(message) {
        var headerTitle = document.getElementById('pgHeader');
        headerTitle.innerHTML = Language[message];
    }


    function showParentalGuidanceInformation(parentalGuidance) {
        clearNode(body);
        clearKeyboardTrap();

        var container = document.createElement('div');
        container.setAttribute('role','alertdialog');
        container.setAttribute('aria-labelledby','pgInfoHeader');
        container.setAttribute('aria-describedby','pgInfo');
        container.style.marginBottom = '24px';
        body.appendChild(container);

        updateHeaderTitle('newPgTurnOnParentalGuidance');

        if (_lockClicked) {
            var txtId = "pgInfo";
            var txtId2 = "pgUnlock";
        } else {
            var intent = parentalGuidance._intent;
            if (intent == 'download') {
                txtId = "pgInfoPlusDownload";
                txtId2 = "pgDownload";
            } else {
                if (intent == 'play') {
                    txtId = "pgInfoPlusPlay";
                    txtId2 = "newToolTipPlay";
                } else {
                    txtId = "pgInfo";
                    txtId2 = intent;
                }
            }
        }

        var infoLinkContainer = document.createElement('div');
        infoLinkContainer.id = 'infoLinkContainer';

        var infoText = document.createElement('div');
        infoText.style.color = "#b2b7c4";

        //Guidance information
        var infoHTML = Language.notSuitableForChildMessage +
                        '</br> </br>  <a id="pgLink" target="_blank" style="color:#ffffff; text-decoration:none; font-size:0.9em;" href="//www.bbc.co.uk/iplayer/guidance">' + 
                        ' <div style="display:inline-block; margin-right: 5px; color:black; font-weight:bold; width:13px; height:13px; background-color:white; border-radius:50px;">i</div>' +
                        Language.findOutMore + '</a> ';

       
        var guidanceInfo = document.createElement('div');
        guidanceInfo.id = 'pgInfo';
        guidanceInfo.style.fontSize = '13px';
        guidanceInfo.style.color = '#868686';
        guidanceInfo.style.marginTop = '35px';
        container.appendChild(guidanceInfo);

        guidanceInfo.appendChild(infoLinkContainer);
        infoLinkContainer.style.margin = " 0 auto";

        infoLinkContainer.appendChild(infoText);

        infoText.innerHTML = infoHTML;

        var pgLink = document.getElementById('pgLink');
        pgLink.setAttribute('aria-label', Language.findOutMore);
        pgLink.style.outline = 'none';

        infoText.style.display ='inline-block';
        infoLinkContainer.style.textAlign = 'center';

        var els=guidanceInfo.getElementsByTagName('p');
        if (els) {
            for (var i=0;i<els.length;i++) {
                els[i].style.color='#868686';
                els[i].style.fontSize='13px';
            }
        }

        var link = document.getElementById('pgLink');
        var allowClick = false;
        setTimeout(function() {
                       allowClick = true;
                   },500);
        link.onclick=function() {
            return allowClick;
        };
        addToKeyboardTrap( link, true);

        //Footer buttons
        var turnOnClick = function() {
            if (allowClick) {
                parentalGuidance.player.dispatch({type:'setGuidanceSkipped', skipped:true});
                showPinSetup(parentalGuidance);
            }
        };

        var playClick = function() {
            if (allowClick) {
                parentalGuidance.player.dispatch({type:'setGuidanceSkipped', skipped:true});
                parentalGuidance.close(true);
            }
        };

        var buttonOne = {id : "pgTurnOn", text : Language.newPgTurnOn, clickFunction : turnOnClick};
        var buttonTwo = {id : "toolTipPlay", text : Language[txtId2], clickFunction : playClick};

        //If setting up PIN via padlock do not display play button
        renderFooter(parentalGuidance, buttonOne, _lockClicked ? null : buttonTwo);
        addOnOverListener(parentalGuidance, 'pgLink');
    }


    function renderPINEntry(container) {
        var pinContainer = document.createElement('div');
        pinContainer.id = 'pinEntry';
        pinContainer.style.width = '100%';
        pinContainer.style.height = '40px';
        pinContainer.style.marginBottom = '20px';
        container.appendChild(pinContainer);

        var pinEntryInput = document.createElement('input');
        var pis=pinEntryInput.style;
        pinEntryInput.setAttribute('maxlength',4);
        pis.letterSpacing = '5px';
        pis.display = 'block';
        pis.margin = "0 auto";
        pis.height = '100%';
        pis.width = '60%';
        pis.padding = '0px';
        pis.resize = 'none';
        pis.color = '#868686';
        pis.fontSize = '30px';
        pis.textAlign = 'center';
        pinEntryInput.setAttribute('type','password');
        pinEntryInput.pattern="[0-9]*";
        pinContainer.appendChild(pinEntryInput);
        return pinEntryInput;
    }


    function addTextFieldKeyListener(element, callback,parentalGuidance) {
        var allowKeys = false;
        var keyHandler = function(e) {
            e = e || window.event;
            var keyCode = e.keyCode || e.which;
            if (keyCode === 13 && allowKeys) {
                parentalGuidance.player.trackAction(element.id, 'key_press');
                setTimeout(callback, 300);
            }
        };
        setTimeout(function() {
                       allowKeys = true;
                   },400);
        element.addEventListener('keyup', keyHandler);
    }


    function showPinSetup (parentalGuidance) {
        clearNode(body);
        clearKeyboardTrap();

         updateHeaderTitle('newPgTurnOnParentalGuidancePINsection');

        var activatePINContainer = document.createElement('div');
        activatePINContainer.id = 'activatePIN';
         activatePINContainer.style.marginTop = '35px';
        activatePINContainer.style.fontSize = '14px';
        activatePINContainer.style.color = '#ffffff';
        body.appendChild(activatePINContainer);

        var activatePIN = document.createElement('span');
        activatePIN.innerHTML = Language.newPgEnterPIN;
        activatePIN.style.fontSize = '14px';
        activatePIN.style.color = '#ffffff';
        activatePINContainer.appendChild(activatePIN);

        var activatePINInfo = document.createElement('div');
        activatePINInfo.innerHTML = '<span style="color:#b2b7c4;">' + Language.newPgActivateInfo + '</span>';
        activatePINInfo.style.marginTop = '10px';
        activatePINInfo.style.marginBottom = '24px';
        activatePINInfo.style.fontSize = '14px';
        activatePINInfo.style.color = '#868686';
        body.appendChild(activatePINInfo);

        pinEntry = renderPINEntry(body);
        pinEntry.setAttribute('aria-label', Language.pgAriaPINEntryDescription + '.' + Language.pgAriaPINPrompt);
        addToKeyboardTrap( pinEntry, true);

        var activateClick = function() {
            if ( (/^\d{4}$/).test(pinEntry.value)) {
                var pinValue = pinEntry.value;
                parentalGuidance.player.dispatch({type:'setPIN', PIN:pinValue});
                parentalGuidance.close(!_lockClicked);
            } else {
                pinEntry.value = "";
                renderError(activatePINInfo, Language.newPgPINvalidationError, false, parentalGuidance);
                pinEntry.focus();
            }
        };

        var txtId = getIntentText(parentalGuidance._intent, "pgActivate");
        addTextFieldKeyListener(pinEntry, activateClick,parentalGuidance);

        renderFooter(parentalGuidance, {id : 'pgActivate', text : Language[txtId], clickFunction : activateClick});
    }

    function renderPasswordReset(parentalGuidance, container, text) {
        var passwordResetContainer = document.createElement('div');
        passwordResetContainer.style.marginBottom = '25px';
        passwordResetContainer.style.width = '100%';
        passwordResetContainer.style.height = '15px';
        container.appendChild(passwordResetContainer);

        var passwordReset = document.createElement('a');
        passwordReset.setAttribute('target', '_blank');
        passwordReset.setAttribute('href', '//www.bbc.co.uk/iplayer/guidance');
        passwordReset.id = 'manageLock';
        passwordReset.innerHTML = text;
        passwordReset.style.color = '#ffffff';
        passwordReset.style.textDecoration = 'none';
        passwordReset.style.fontSize = '12px';
        passwordResetContainer.appendChild(passwordReset);

        addOnOverListener(parentalGuidance, 'manageLock');

        return passwordReset;
    }

    function enterPin(parentalGuidance) {
        clearNode(body);
        clearKeyboardTrap();

        updateHeaderTitle('newPgTurnOnParentalGuidanceInsertPIN');

        //PIN entry header
        var container = document.createElement('div');
        var headerContainer = document.createElement('div');
        var header = document.createElement('span');
        var info = document.createElement('div');
        info.id = 'needPINinfo';
        container.id = 'enterPIN';
        header.innerHTML = Language.newPgEnterPINprompt;
        container.style.marginTop = container.style.paddingBottom = '16px';
        container.style.width = '100%';
        container.style.position = 'relative';
        container.style.fontSize = header.style.fontSize = '14px';
        header.style.color = '#ffffff';
        container.style.marginTop = '5px';
        body.appendChild(container);
        container.appendChild(headerContainer);        
        headerContainer.appendChild(header);

        container.appendChild(info);
        info.innerHTML = Language.newPgEnterPINinfo;
        info.style.color = "rgb(134, 134, 134)";
        info.style.marginTop = "15px";

        //PIN Entry
        pinEntry = renderPINEntry(body);
        pinEntry.setAttribute('aria-label', Language.pgAriaPINEntryDescription + '.' + Language.newPgEnterPINprompt);
        addToKeyboardTrap( pinEntry, true);

        //Password reset
        var passwordReset = renderPasswordReset(parentalGuidance, body, Language.newPgManageYourPIN);
        addToKeyboardTrap( passwordReset );
        passwordReset.onclick=function() {
            return allowClick;
        };

        var allowClick = false;
        setTimeout(function() {
                       allowClick=true;
                   },500);

        var playClick = function() {
            if (allowClick) {
                var pinValue = pinEntry.value;

                if (parentalGuidance.isUnder16) {
                    parentalGuidance.player.dispatch({type:'setUnder16Permission', hasPermission:true});
                }

                parentalGuidance.player.dispatch({type:'verify', verifyPIN:pinValue, lockClicked:_lockClicked});
            }
        };

        addTextFieldKeyListener(pinEntry, playClick, parentalGuidance);

        var txtId = getIntentText(parentalGuidance._intent, "pgUnlock");
        renderFooter(parentalGuidance, {id : 'pgTurnOff', text : Language[txtId], clickFunction : playClick});
    }


    var handler;
    function orientHandler() {
        clearTimeout(handler);
        handler = setTimeout(resizeHandler,100);
    }


    function getIntentText(intent, lockOne) {
        if (_lockClicked) {
            return lockOne;
        }
        if (intent=="download") {
            return "pgDownload";
        } else {
            if (intent=="play") {
                return "toolTipPlay";
            }
        }
        return intent;
    }

    function resizeHandler() {
        if (background) {
            var bs=background.style;
            bs.left = bs.top = "-500px";
            bs.height = bs.width = "5000px";
        }
        if (popup) {
            var w = Math.floor(window.innerWidth/2 - popup.offsetWidth/2);
            popup.style.left=w+"px";
            var delta = (window.innerHeight - popup.offsetHeight);
            if (window.innerHeight >= popup.offsetHeight) {
                var t= Math.floor(delta/2);
            } else {
                t = 2;
            }
            popup.style.marginTop = popup.style.marginLeft = "0px";
            popup.style.top = t+"px";
        }
    }

    ParentalGuidance.prototype = {

        showInPlayerGuidance : function (data, guidanceContainer) {

            var parentalGuidance = this;

            if (data) {
                _lockClicked = data.lockClicked;
                parentalGuidance._intent = data.intent || 'play';
            }

            var guidance = parentalGuidance.player.config.guidance;

            //If the user has previously declared they are over 16 but not set a PIN
            var ageConfirmed = guidance.guidanceSkipped;

            // only re-show if required.
            if ( renderGuidance(parentalGuidance, guidanceContainer) ) {
                if (guidance.hasGuidancePIN && guidance.isGuidanceLocked && !guidance.under16permissionConfirmed) {
                    enterPin(parentalGuidance);
                } else if ( (_lockClicked && ageConfirmed) || parentalGuidance.isOver16 ) {
                    showParentalGuidanceInformation(parentalGuidance);
                } else {
                    showAgeConfirmation(parentalGuidance,data.guidance);
                }

                window.addEventListener('resize', resizeHandler);
                window.addEventListener('orientationchange', orientHandler);
            }

        },
        guidanceLock: function() {
            var parentalGuidance = this;
            parentalGuidance.player.dispatch({type:'guidanceLocked', locked:true});
        },
        verified : function(data) {
            var parentalGuidance = this;
            if (data.isCorrect) {
                parentalGuidance.close(!_lockClicked);
            } else {
                pinEntry.value = "";
                renderError(header, Language.newPgIncorrectPIN, false, parentalGuidance);
                pinEntry.focus();
            }
        },
        close : function(playAfter,suppressEvent) {
            var parentalGuidance = this;

            parentalGuidance.nowShowing = false;

            if (background) {
                background.parentNode.removeChild(background);
                background = undefined;
            }

            if (popup) {
                popup.parentNode.removeChild(popup);
                popup = undefined;
            }


            if (!suppressEvent) {
                var success=false;
                if (parentalGuidance.player.guidanceOk) {
                    success = true;
                    if (playAfter) {
                        parentalGuidance.player.startPlayback();
                    }
                }
                parentalGuidance.player.delayedDispatch({type:"guidanceClosed", success:success});
            }
            window.removeEventListener('resize', resizeHandler);
            window.removeEventListener('orientationchange', orientHandler);
        }
    };

    return ParentalGuidance;

})();
var ToggleButton = (function() {

    function createDomNodes(self, label, id, className) {

        var toggleNode = self._toggleNode = document.createElement('div');
        if(id) {
            toggleNode.id = id;
        }
        toggleNode.className = className ? 'p_toggle ' + className : 'p_toggle';
        toggleNode.setAttribute('role', 'checkbox');
        toggleNode.setAttribute('aria-checked', 'false');
        toggleNode.setAttribute('aria-label', label);
        toggleNode.tabIndex = 0;

        var toggleText = self._toggleText = document.createElement('div');
        toggleText.className = 'p_toggleText';
        toggleText.textContent = 'OFF';

        var toggleSlot = document.createElement('div');
        toggleSlot.className = 'p_toggleSlot';

        var toggleSlider = document.createElement('div');
        toggleSlider.className = 'p_toggleSlider';

        var tick = document.createElement('div');
        tick.className = 'p_tick';
        toggleSlider.appendChild(tick);

        toggleSlot.appendChild(toggleSlider);
        toggleNode.appendChild(toggleText);
        toggleNode.appendChild(toggleSlot);

        addEventListeners(self, toggleNode);

        return toggleNode;

    }

    function addEventListeners(self, toggleNode) {

        toggleNode.addEventListener('click', function() {
            if(!self.disabled) {
                self.flip('click');
            }
        });

        toggleNode.addEventListener('keyup', function(e) {
            if(!self.disabled) {
                var keyCode = e.keyCode;

                if (keyCode == 32 || keyCode == 13) {
                    self.flip('keyup');
                }
            }
        });
    }

    function fireChangeListeners(self, status) {

        for(var i=0; i < self.changeListeners.length; i++) {
            self.changeListeners[i](status);
        }

    }


    var ToggleButton = function(ui, label, id, className, statsLabels) {

        this.ui = ui;
        if (statsLabels) {
            this.statsLabels = statsLabels;            
        }
        this.changeListeners = [];
        this.disabled = false;
        this._on = false;
        createDomNodes(this, label, id, className);

    };


    ToggleButton.prototype = {

        getDomNodes: function() {
            return [this._toggleNode];
        },

        flip: function(eventType) {

            if(this._toggleNode.getAttribute('aria-checked') == 'true') {
                fireChangeListeners(this, 'turningOff');
                if (this.statsLabels) {
                    this.ui.player.trackAction(this.statsLabels.off,eventType);
                }
            } else {
                fireChangeListeners(this, 'turningOn');
                if (this.statsLabels) {
                    this.ui.player.trackAction(this.statsLabels.on,eventType);
                }
            }

        },

        setOn: function(label) {
            this._toggleNode.setAttribute('aria-checked', 'true');
            Utils.className(this._toggleNode, 'p_toggleOn');
            //this._toggleNode.classList.add('p_toggleOn');
            this._toggleText.textContent = Language.on;
            this._on = true;

            if (label) {
                this._toggleNode.setAttribute('aria-label', label);
            }

        },

        setOff: function(label) {
            this._toggleNode.setAttribute('aria-checked', 'false');
            Utils.className(this._toggleNode, '', 'p_toggleOn');
            //this._toggleNode.classList.remove('p_toggleOn');
            this._toggleText.textContent = Language.off;
            this._on = false;

            if (label) {
                this._toggleNode.setAttribute('aria-label', label);
            }

        },

        disable: function() {
            this.disabled = true;
        },

        enable: function() {
            this.disabled = false;
        },

        attachChangeListener: function(f) {
            this.changeListeners.push(f);
        },

        updateLanguage: function(label) {
            this._toggleNode.setAttribute('aria-label', label);
            if(this._on) {
                this._toggleText.textContent = Language.on;
            } else {
                this._toggleText.textContent = Language.off;
            }

        }

    };


    return ToggleButton;

})();/**
 * Subtitle settings panel
 */

var SubtitleSettingsPanel = (function() {

    var fontSizes = [
        'useSmallestFontSize:0.5',
        'useSmallFontSize:0.6',
        'useMediumFontSize:0.67',
        'useLargeFontSize:0.82',
        'useLargestFontSize:1'
    ];

    function createSubsSettingsContainer(self) {

        var settingsContainer = document.createElement('div');
        settingsContainer.id = 'p_subtitleSettingsContainer';
        settingsContainer.className =  'p_dontCloseSettingsPanel';

        Utils.multiAddEventListener(settingsContainer, 'focusout blur', function(e) {

            var relatedTarget = e.relatedTarget;
            if((relatedTarget !== null) && !settingsContainer.contains(relatedTarget) && Utils.hasClass(document.body, 'nonPointerFocus')) {
                self.closePanel();
            }
            self.hasFocus=false;
        }, true);

        Utils.multiAddEventListener(settingsContainer, 'focusin focus',function() {
                                        self.hasFocus=true;
                                    },true);

        var mask = document.createElement('div');
        mask.className = 'p_subtitleSettingsMask';
        settingsContainer.appendChild(mask);

        var settingsBox = document.createElement('div');
        settingsBox.className = 'p_subtitleSettingsBox';
        settingsContainer.appendChild(settingsBox);

        var subsToggleLabel = self.subsToggleLabel = document.createElement('div');
        subsToggleLabel.className = 'p_subsToggleLabel';
        subsToggleLabel.textContent = self.strings.type;
        settingsBox.appendChild(subsToggleLabel);

        var subtitleToggle = self.subtitleToggle = new ToggleButton(null, self.strings.type, null, 'p_subsToggle');
        subtitleToggle.disable();
        subtitleToggle.attachChangeListener(function(status) {
            if(status == 'turningOff') {
                self.ui.player.Subtitles.off();
                self.ui.player.trackAction('subtitles_off', 'subtitles_toggle');
                setTimeout(function() {
                    self.ui.subtitlesButton.focus();
                    self.closePanel();
                }, 500);
            } else {
                self.ui.player.Subtitles.on();
                self.ui.player.trackAction('subtitles_on', 'subtitles_toggle');
            }
        });

        appendChildren(settingsBox, subtitleToggle.getDomNodes());

        var triangle = document.createElement('div');
        triangle.className = 'p_downArrow';
        settingsContainer.appendChild(triangle);

        var sizingButtonsContainer = document.createElement('div');
        sizingButtonsContainer.className = 'p_sizingButtonsContainer';
        settingsBox.appendChild(sizingButtonsContainer);

        for (var i=0; i < fontSizes.length; i++) {
            var fontSize = fontSizes[i].split(':');
            fontSize[1] = +fontSize[1];
            var button = createSizeButton(self, fontSize[0], fontSize[1]);
            self.sizeButtons.push(button);
            sizingButtonsContainer.appendChild(button);
        }

        var sizeIndicator = self.sizeIndicator = document.createElement('div');
        sizeIndicator.id = 'p_subtitleSizeIndicator';

        settingsBox.appendChild(sizeIndicator);

        return settingsContainer;

    }

    function createSizeButton(self, sizeName, sizePercent) {

        var button = document.createElement('button');
        button.id = 'p_subtitleSizeButton_' + sizeName;
        button.className = 'p_subtitleSizeButton p_button font-family-sans';
        button.disabled = true;
        button.setAttribute('aria-pressed', 'false');
        button.setAttribute('data-sizeName', sizeName);

        button.setAttribute('aria-label', self.strings[sizeName]);
        button.setAttribute('data-size', sizePercent);

        var buttonInner = document.createElement('div');
        buttonInner.textContent = self.strings.aa;
        button.appendChild(buttonInner);

        function updateSize() {
            self.setSize(sizePercent);
            clearTimeout(self.ui.idleTimeoutInterval);

            var playerWidth = Utils.getOffset(self.ui.player.mediaContainer, 'width');
            var playerHeight = Utils.getOffset(self.ui.player.mediaContainer, 'height');

            clearTimeout(self.recordSizeTimeout);
            self.recordSizeTimeout = setTimeout(function() {
                self.ui.player.trackAction('user_selected_sub_size', sizePercent, {'player_width':playerWidth, 'player_height': playerHeight});
            }, 10000);

        }

        button.addEventListener('click', updateSize);

        return button;

    }

    function getToggleSubtitles(self, ui) {

        return Utils.getActionFn(function(actionType, event) {

            if(self.subtitleSettingsPanelShowing) {
                self.closePanel();
            } else {
                self.showPanel();
                if(!ui.player.Subtitles.showingSubs) {

                    // This is here to prevent toggle animation stutter
                    setTimeout(function() {
                        self.indicateSubsOn();
                    }, 100);

                    setTimeout(function() {
                        ui.player.Subtitles.on();
                        ui.player.trackAction('subtitles_on', 'control_bar_button');
                    }, 300);

                    setTimeout(function() {
                        self.subtitleToggle.enable();
                    }, 1000);

                }
                ui.resetIdleTimeout(event);
            }


        });
    }

    function setButtonText(self, text) {

        self.openCloseButton.title = text;
        self.openCloseButton.setAttribute('aria-label', text);

        var hiddenElement = self.openCloseButton.getElementsByClassName('p_hiddenElement')[0];
        hiddenElement.innerHTML = text;

    }

    function updateButtonText(self) {

        if(self.subtitleSettingsPanelShowing) {
            setButtonText(self, self.strings.closePanel);
        } else if(self.ui.player.Subtitles.showingSubs) {
            setButtonText(self, self.strings.openPanel);
        } else {
            setButtonText(self, self.strings.openPanelAndOn);
        }

    }

    /*
     * Constructor for SubtitleSettingsPanel class
     */
    var SubtitleSettingsPanel = function(ui, getButton) {

        this.ui = ui;
        this.subtitlesConfig = ui.config.subtitles;
        this.closedCaptions = this.subtitlesConfig.kind && this.subtitlesConfig.kind === "closedCaptions";
        this.setLanguageStrings();

        this.openCloseButton = getButton("p_subtitleButton p_dontCloseSettingsPanel", getToggleSubtitles(this, ui), this.strings.openPanelAndOn, this.strings.openPanelAndOn, ui, true, 'accessibility');

        this.sizeButtons = [];
        this.subtitleSettingsContainer = createSubsSettingsContainer(this);

        if(this.subtitlesConfig.defaultOn) {
            this.indicateSubsOn();
            this.subtitleToggle.enable();
        }
    };

    SubtitleSettingsPanel.prototype = {

        getOpenCloseButton: function() {
            return this.openCloseButton;
        },

        getSubsSettingsContainer: function() {
            return this.subtitleSettingsContainer;
        },

        showPanel: function() {
            if(!this.subtitleSettingsPanelShowing) {
                this.ui.closeSettingsPanels();
                this.subtitleSettingsContainer.style.display = 'block';
                this.subtitleSettingsPanelShowing = true;
                Utils.className(this.openCloseButton, 'p_settingsPanelOpen');
                setButtonText(this, this.strings.closePanel);
                this.ui.player.Subtitles.updatePositions();
                Utils.className(document.body, 'controlsPanelOpen', '');
            }
        },

        closePanel: function() {
            if(this.subtitleSettingsPanelShowing) {
                this.subtitleSettingsContainer.style.display = 'none';
                this.subtitleSettingsPanelShowing = false;
                Utils.className(this.openCloseButton, '', 'p_settingsPanelOpen');
                if (this.ui.player.Subtitles.showingSubs) {
                    setButtonText(this, this.strings.openPanel);
                } else {
                    setButtonText(this, this.strings.openPanelAndOn);
                }
                this.ui.player.Subtitles.updatePositions();
                Utils.className(document.body, '', 'controlsPanelOpen');
            }
            this.hasFocus=false;
        },

        getPanelTop: function() {
            return Utils.getOffset(this.subtitleSettingsContainer, 'top');
        },

        isPanelOpen: function() {
            return this.subtitleSettingsPanelShowing;
        },

        indicateSubsOn: function() {

            Utils.className(this.openCloseButton, 'p_controlBarButton_on');

            if(!this.subtitleSettingsPanelShowing) {
                setButtonText(this, this.strings.openPanel);
            }

            this.subtitleToggle.setOn();

            for (var i=0; i < this.sizeButtons.length; i++) {
                this.sizeButtons[i].disabled = false;
            }

            Utils.className(this.subtitleSettingsContainer, 'p_subsOn');


        },

        indicateSubsOff: function() {

            Utils.className(this.openCloseButton, '', 'p_controlBarButton_on');

            if(!this.subtitleSettingsPanelShowing) {
                setButtonText(this, this.strings.openPanelAndOn);
            }

            this.subtitleToggle.disable();
            this.subtitleToggle.setOff();

            for (var i=0; i < this.sizeButtons.length; i++) {
                this.sizeButtons[i].disabled = true;
            }

            Utils.className(this.subtitleSettingsContainer, '', 'p_subsOn');

        },

        indicateSize: function(size) {

            var found=found;
            for (var i=0; i < this.sizeButtons.length; i++) {
                this.sizeButtons[i].setAttribute('aria-pressed', 'false');

                if(size == this.sizeButtons[i].getAttribute('data-size')) {
                    var distanceFromLeft  = 5 + (i * 45);
                    this.sizeIndicator.style.left = distanceFromLeft + 'px';
                    this.sizeButtons[i].setAttribute('aria-pressed', 'true');
                    found=true;
                }
            }
            this.sizeIndicator.style.display = found ? 'block' : 'none';

        },

        setSize: function(size) {
            this.ui.updateConfig({
                subtitles: {
                    sizeAdjustment: size
                }
            });
            this.indicateSize(size);
            this.ui.player.Subtitles.persistSizeAdjustment(size);
        },

        updateLanguage: function() {

            this.setLanguageStrings();
            updateButtonText(this);
            this.subsToggleLabel.textContent = this.strings.type;
            this.subtitleToggle.updateLanguage(this.strings.type);

            for (var i=0; i < this.sizeButtons.length; i++) {
                var sizeName = this.sizeButtons[i].getAttribute('data-sizeName');
                this.sizeButtons[i].setAttribute('aria-label', this.strings[sizeName]);
            }
        },

        setLanguageStrings: function() {

            this.strings = {
                openPanelAndOn: this.closedCaptions ? Language.openClosedCaptionsMenuAndTurnOnCC : Language.openSubtitlesMenuAndTurnOnSubs,
                openPanel: this.closedCaptions ? Language.openClosedCaptionsMenu : Language.openSubtitlesMenu,
                closePanel: this.closedCaptions ? Language.closeClosedCaptionsMenu : Language.closeSubtitlesMenu,
                type: this.closedCaptions ? Language.closedCaptions : Language.subtitles,
                off: Language.off,
                on: Language.on,
                useFontSize: Language.useFontSize,
                useSmallestFontSize: Language.useSmallestFontSize,
                useSmallFontSize: Language.useSmallFontSize,
                useMediumFontSize: Language.useMediumFontSize,
                useLargeFontSize: Language.useLargeFontSize,
                useLargestFontSize: Language.useLargestFontSize,
                aa: Language.aa
            };

        }

    };

    return SubtitleSettingsPanel;

})();
/**
 * Playback settings panel
 */

var PlaybackSettingsPanel = (function() {

    function addToKeyboardLoop(playbackPanel,element,qualityRow,forward,backward) {

        element.onkeydown = function(e) {

            function focusOnQualityRow(e){
                e.preventDefault();
                playbackPanel.resetMainPage();
                playbackPanel.showPanel();
                qualityRow.focus();
            }

            var keyCode = e.keyCode || e.which;
            if (keyCode != 9 && keyCode != 13) {
                return;
            }

            var isTabbing = (keyCode === 9);
            var goingBackFromLowRow = (e.shiftKey !== true && forward);
            var goingForwardFromHighRow = (e.shiftKey === true && backward);

            if ( isTabbing && (goingBackFromLowRow || goingForwardFromHighRow) ){
                focusOnQualityRow(e);
            }
                
        };

    }


    function isTabbing(e) { 
        return (e.type === 'keyup' || e.type === 'keydown') && e.keyCode !== 32 && e.keyCode !== 13;
    }


    function setCookie(value){

        var settingsCookie = Utils.getCookie('ckps_smpSettings');
        var settings = {};

        if(settingsCookie) {

            try {
                settings = JSON.parse(settingsCookie);

                if(!settings) {
                    settings = {
                        quality: value
                    };
                } else {
                    settings.quality = value;
                }

            } catch(error) {

                settings = {
                    quality: value
                };
            }

        } else {

            settings = {
                quality: value
            };

        }

        Utils.setCookie('ckps_smpSettings', JSON.stringify(settings));
    }


    function updateAccessibilityLabels(preference,qualityRow,qualityPanelLowRow,qualityPanelMediumRow,qualityPanelHighRow) {

        if (preference === 'low') {
            // quality panel
            qualityPanelLowRow.setAttribute('aria-label', Language.qualitySettingLowSelected);
            qualityPanelMediumRow.setAttribute('aria-label', Language.qualitySettingMediumSelect);
            qualityPanelHighRow.setAttribute('aria-label', Language.qualitySettingHighSelect);

            // main panel
            qualityRow.setAttribute('aria-label', Language.qualitySettingOpenLowSelected);
        }

        if (preference === 'medium') {
            // quality panel
            qualityPanelMediumRow.setAttribute('aria-label', Language.qualitySettingMediumSelected);
            qualityPanelLowRow.setAttribute('aria-label', Language.qualitySettingLowSelect);
            qualityPanelHighRow.setAttribute('aria-label', Language.qualitySettingHighSelect);

            // main panel
            qualityRow.setAttribute('aria-label', Language.qualitySettingOpenMediumSelected);
        }

        if (preference === 'high') {
            // quality panel
            qualityPanelHighRow.setAttribute('aria-label', Language.qualitySettingHighSelected);
            qualityPanelLowRow.setAttribute('aria-label', Language.qualitySettingLowSelect);
            qualityPanelMediumRow.setAttribute('aria-label', Language.qualitySettingMediumSelect);

            // main panel
            qualityRow.setAttribute('aria-label', Language.qualitySettingOpenHighSelected);
        }

    }


    function updateVisualChanges(quality,qualityPanelLowRow,qualityPanelMediumRow,qualityPanelHighRow,qualitySubtitle){

        if (quality =='low'){
            Utils.className(qualityPanelLowRow, "p_qualitySettingOn","");
            Utils.className(qualityPanelMediumRow, "","p_qualitySettingOn");
            Utils.className(qualityPanelHighRow, "","p_qualitySettingOn");
            qualitySubtitle.textContent = Language.qualityPanelLowRowHeading;
        }

        if (quality =='medium'){
            Utils.className(qualityPanelMediumRow, "p_qualitySettingOn","");
            Utils.className(qualityPanelLowRow, "","p_qualitySettingOn");
            Utils.className(qualityPanelHighRow, "","p_qualitySettingOn");
            qualitySubtitle.textContent = Language.qualityPanelMediumRowHeading;
        }

        if (quality =='high'){
            Utils.className(qualityPanelHighRow, "p_qualitySettingOn","");
            Utils.className(qualityPanelLowRow, "","p_qualitySettingOn");
            Utils.className(qualityPanelMediumRow, "","p_qualitySettingOn");
            qualitySubtitle.textContent = Language.qualityPanelHighRowHeading;       
        }

    }


    function sendStats(self){

        var info = {
            continuousPlay_new : self.newContinuousPlayStatus ? 'on' : 'off',
            continuousPlay_previous : self.previousContinuousPlayStatus ? 'on' : 'off',
            quality_new : self.selectedQuality,
            quality_previous : self.previousQuality
        };

        if (!self.ui.config.playbackSettingsPanel.qualitySetting) {
            delete info.quality_new;
            delete info.quality_previous; 
        }

        if (!self.ui.config.playbackSettingsPanel.continuousPlaySetting) {
            delete info.continuousPlay_new;
            delete info.continuousPlay_previous; 
        }

        self.ui.player.trackAction('playback_settings_info', 'playback_settings_closed', info);

    }


    function setQuality(self,qualityString,player,qualityRow,qualityPanelLowRow,qualityPanelMediumRow,qualityPanelHighRow,qualitySubtitle,highlightMenuColour,storeCookie){

        updateVisualChanges(qualityString,qualityPanelLowRow,qualityPanelMediumRow,qualityPanelHighRow,qualitySubtitle);
        updateAccessibilityLabels(qualityString,qualityRow,qualityPanelLowRow,qualityPanelMediumRow,qualityPanelHighRow);

        if (storeCookie && self){
            setCookie(qualityString);
            player.quality = new Quality(qualityString);
            self.selectedQuality = qualityString;
        }

    }


    function checkInitialConfigAndUpdateStatusAndLabels(player,qualityRow,qualityPanelLowRow,qualityPanelMediumRow,qualityPanelHighRow,qualitySubtitle,highlightMenuColour){
        
        if (player.config && player.config.quality) {

            if (player.config.quality === 'low') {
                setQuality(null,'low',player,qualityRow,qualityPanelLowRow,qualityPanelMediumRow,qualityPanelHighRow,qualitySubtitle,highlightMenuColour);
            }

            if (player.config.quality === 'medium') {
                setQuality(null,'medium',player,qualityRow,qualityPanelLowRow,qualityPanelMediumRow,qualityPanelHighRow,qualitySubtitle,highlightMenuColour);
            }

            if (player.config.quality === 'high' || player.config.quality === 'hd' ) {
                setQuality(null,'high',player,qualityRow,qualityPanelLowRow,qualityPanelMediumRow,qualityPanelHighRow,qualitySubtitle,highlightMenuColour);
            }

        }
    }


    function createPlaybackSettingsContainer(self) {

        var player = self.player;

        var settingsContainer = self.settingsContainer = document.createElement('div');
        settingsContainer.id = 'p_playbackSettingsContainer';
        settingsContainer.className =  'p_dontCloseSettingsPanel';

        Utils.multiAddEventListener(settingsContainer, 'focusout blur', function(e) {
            var relatedTarget = e.relatedTarget;
            if((relatedTarget !== null) && !settingsContainer.contains(relatedTarget) && Utils.hasClass(document.body, 'nonPointerFocus')) {
                self.closePanel();
            }
            self.hasFocus=false;
        }, true);

        Utils.multiAddEventListener(settingsContainer, 'focusin focus',function() {
                                        self.hasFocus=true;
                                    },true);


        // MAIN PANEL AND HEADER
        var mask = document.createElement('div');
        mask.id = 'p_playbackSettingsMask';
        settingsContainer.appendChild(mask);

        var settingsBox = self.settingsBox = document.createElement('div');
        settingsBox.id = 'p_playbackSettingsBox';
        settingsContainer.appendChild(settingsBox);

        var heading = self.settingsHeading = document.createElement('div');
        heading.id = 'p_playbackSettingsHeading';
        heading.textContent = Language.playbackSettingsHeading;
        settingsBox.appendChild(heading);

        var panel1 = document.createElement('div');
        panel1.id = 'p_panel1';
        settingsBox.appendChild(panel1);

        // --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---


        // AUTOPLAY ROW, MAIN PANEL
        var autoplayRow = self.autoplayRow = document.createElement('div');
        autoplayRow.id = 'p_autoplayRow';
        autoplayRow.className = 'p_settingsRow';
        panel1.appendChild(autoplayRow);

        if(self.ui.config.playbackSettingsPanel.continuousPlaySetting) {
            autoplayRow.style.display = 'block';
        }

        var autoplayText = document.createElement('div');
        autoplayText.id = 'p_autoplayText';
        autoplayText.className = 'p_settingsTextBox';
        autoplayRow.appendChild(autoplayText);

        var autoplayTitle = self.autoplaySettingHeading = document.createElement('div');
        autoplayTitle.id = 'p_autoplayTitle';
        autoplayTitle.className = 'p_settingsTitle';
        autoplayTitle.textContent = Language.autoplaySettingHeading;
        autoplayText.appendChild(autoplayTitle);

        var autoplaySubtitle = self.autoplaySettingSubheading = document.createElement('div');
        autoplaySubtitle.id = 'p_autoplaySubtitle';
        autoplaySubtitle.className = 'p_settingsSubtitle';
        autoplaySubtitle.textContent = Language.autoplaySettingSubheading;
        autoplayText.appendChild(autoplaySubtitle);

        var statsLabels = {
            on: 'playback_settings_continuous_play_toggle_on',
            off: 'playback_settings_continuous_play_toggle_off'
        };

        var autoplayToggle = self.autoplayToggle = new ToggleButton(self.ui, Language.autoplaySettingGenericLabel, 'p_autoplayToggle', null, statsLabels);

        if(self.ui.player.config.continuousPlay) {
            autoplayToggle.setOn();
        }

        autoplayToggle.attachChangeListener(function(status) {
            if(status == 'turningOff') {
                self.previousContinuousPlayStatus = true; 
                self.newContinuousPlayStatus = false; 
                self.ui.player.dispatch({type:'continuousPlayToggleSwitched', status: false});
                self.ui.player.updateConfig({'continuousPlay': false});
            } else {
                self.previousContinuousPlayStatus = false; 
                self.newContinuousPlayStatus = true; 
                self.ui.player.dispatch({type:'continuousPlayToggleSwitched', status: true});
                self.ui.player.updateConfig({'continuousPlay': true});
            }
        });

        appendChildren(autoplayRow, autoplayToggle.getDomNodes());

        // --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---


        // QUALITY ROW, MAIN PANEL

        var qualityRow = self.qualityRow = document.createElement('div');
        qualityRow.id = 'p_qualityRow';
        qualityRow.className = 'p_settingsRow';
        panel1.appendChild(qualityRow);

        qualityRow.setAttribute('aria-label', Language.qualitySettingOpenHighSelected);
        qualityRow.tabIndex = '';

        if(self.ui.config.playbackSettingsPanel.qualitySetting) {
            qualityRow.style.display = 'block';
        }

        var qualityText = document.createElement('div');
        qualityText.id = 'p_qualityText';
        qualityText.className = 'p_settingsTextBox';
        qualityRow.appendChild(qualityText);

        var qualityTitle = self.qualitySettingHeading = document.createElement('div');
        var qualityTitleText = self.qualitySettingHeadingText = document.createElement('span');
        qualityTitle.id = 'p_qualityTitle';
        qualityTitle.className = 'p_settingsTitle';
        qualityTitleText.textContent = Language.qualitySettingHeading;
        qualityTitle.appendChild(qualityTitleText);
        qualityText.appendChild(qualityTitle);

        var qualitySubtitle = self.qualitySettingSubheading = document.createElement('div');
        qualitySubtitle.id = 'p_qualitySubtitle';
        qualitySubtitle.className = 'p_settingsSubtitle';
        qualitySubtitle.textContent = Language.qualityPanelHighRowHeading;
        qualityText.appendChild(qualitySubtitle);
        var qualitySubtitleUnavailable = self.qualitySettingUnavailableSubheading = document.createElement('div');
        qualitySubtitleUnavailable.id = 'p_qualitySubtitleUnavailable';
        qualitySubtitleUnavailable.className = 'p_settingsSubtitleUnavailable';
        qualitySubtitleUnavailable.textContent = Language.qualitySettingOpenUnavailable;
        qualityText.appendChild(qualitySubtitleUnavailable);


        // html-css chevron
        var chevronPlaceholder = self.chevronPlaceholder = document.createElement('div');
        chevronPlaceholder.id = 'p_chevronPlaceholder';
        chevronPlaceholder.tabIndex = '-1';

        var chevronBorder = document.createElement('div');
        chevronBorder.className = 'p_chevronBorder';
        chevronPlaceholder.appendChild(chevronBorder);

        var chevronInside = document.createElement('div');
        chevronInside.className = 'p_chevronInside';
        chevronBorder.appendChild(chevronInside);

        qualityTitle.appendChild(chevronPlaceholder);


        Utils.multiAddEventListener(qualityRow, 'click keyup', function(e){

            var fromKeyboard = e.type === 'keyup' || (e.screenX === 0 && e.screenY === 0);

            if (isTabbing(e)){
                return;
            }
            self.showingQualityPage = true;
            self.switchPageSetting(fromKeyboard);
            self.ui.player.trackAction('playback_settings_open_quality_option',e.type);

        },true);

        // --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---


        // SECOND PAGE, QUALITY PANEL

        // LIST GROUP WRAP
        var qualityListWrap = self.qualityListWrap = document.createElement('ul');
        qualityListWrap.id = 'p_qualityListWrap';
        qualityListWrap.setAttribute('aria-label', Language.qualitySettingInfo);
        panel1.appendChild(qualityListWrap);

        // Low setting
        var qualityPanelLowRow = self.qualityPanelLowRow = document.createElement('li');
        qualityPanelLowRow.id = 'p_qualityPanelFirstRow';
        qualityPanelLowRow.className = 'p_qualityPanelRow';
        qualityListWrap.appendChild(qualityPanelLowRow);

        var qualityPanelLowRowHeading = self.qualityPanelLowRowHeading = document.createElement('div');
        var qualityPanelLowRowHeadingText = self.qualityPanelLowRowHeadingText = document.createElement('span');
        qualityPanelLowRowHeading.id = 'p_qualityPanelLowRowHeading';
        qualityPanelLowRowHeading.className = 'p_qualityPanelRowHeading';
        qualityPanelLowRowHeadingText.textContent = Language.qualityPanelLowRowHeading;

        qualityPanelLowRow.setAttribute('aria-label', Language.qualitySettingLowSelect);
        qualityPanelLowRow.tabIndex = '';

        qualityPanelLowRowHeading.appendChild(qualityPanelLowRowHeadingText);
        qualityPanelLowRow.appendChild(qualityPanelLowRowHeading);

        var lowRowTick = document.createElement('div');
        lowRowTick.className = 'p_qualityTick';
        qualityPanelLowRowHeading.appendChild(lowRowTick);

        // Medium setting
        var qualityPanelMediumRow = self.qualityPanelMediumRow = document.createElement('li');
        qualityPanelMediumRow.id = 'p_qualityPanelMediumRow';
        qualityPanelMediumRow.className = 'p_qualityPanelRow';
        qualityListWrap.appendChild(qualityPanelMediumRow);

        var qualityPanelMediumRowHeading = self.qualityPanelMediumRowHeading = document.createElement('div');
        var qualityPanelMediumRowHeadingText = self.qualityPanelMediumRowHeadingText = document.createElement('span');
        qualityPanelMediumRowHeading.id = 'p_qualityPanelMediumRowHeading';
        qualityPanelMediumRowHeading.className = 'p_qualityPanelRowHeading';
        qualityPanelMediumRowHeadingText.textContent = Language.qualityPanelMediumRowHeading;

        qualityPanelMediumRow.setAttribute('aria-label', Language.qualitySettingMediumSelect);
        qualityPanelMediumRow.tabIndex = '';

        qualityPanelMediumRowHeading.appendChild(qualityPanelMediumRowHeadingText);
        qualityPanelMediumRow.appendChild(qualityPanelMediumRowHeading);

        var mediumRowTick = document.createElement('div');
        mediumRowTick.className = 'p_qualityTick';
        qualityPanelMediumRowHeading.appendChild(mediumRowTick);

        // Highest available setting
        var qualityPanelHighRow = self.qualityPanelHighRow = document.createElement('li');
        qualityPanelHighRow.id = 'p_qualityPanelHighRow';
        qualityPanelHighRow.className = 'p_qualityPanelRow p_qualitySettingOn';
        qualityListWrap.appendChild(qualityPanelHighRow);


        var qualityPanelHighRowHeading = self.qualityPanelHighRowHeading = document.createElement('div');
        var qualityPanelHighRowHeadingText = self.qualityPanelHighRowHeadingText = document.createElement('span');
        qualityPanelHighRowHeading.id = 'p_qualityPanelHighRowHeading';
        qualityPanelHighRowHeading.className = 'p_qualityPanelRowHeading';
        qualityPanelHighRowHeadingText.textContent = Language.qualityPanelHighRowHeading;

        qualityPanelHighRowHeading.appendChild(qualityPanelHighRowHeadingText);
        qualityPanelHighRow.appendChild(qualityPanelHighRowHeading);

        var qualityPanelHighRowSubtitle = self.qualityPanelHighRowSettingSubheading = document.createElement('div');
        var qualityPanelHighRowSubtitleText = self.qualityPanelHighRowSubtitleText = document.createElement('span');
        qualityPanelHighRowSubtitle.setAttribute('aria-hidden', 'true');
        qualityPanelHighRowSubtitle.id = 'p_qualityPanelHighRowSubtitle';
        qualityPanelHighRowSubtitle.className = 'p_qualityPanelRowSubtitle';
        qualityPanelHighRowSubtitleText.textContent = Language.qualityPanelHighRowSubtitle;

        // high by default
        qualityPanelHighRow.setAttribute('aria-label', Language.qualitySettingOpenHighSelected);
        qualityPanelHighRow.tabIndex = '';
        qualityPanelHighRowSubtitle.appendChild(qualityPanelHighRowSubtitleText);
        qualityPanelHighRow.appendChild(qualityPanelHighRowSubtitle);

        var highlightMenuColour = self.ui.config.playbackSettingsPanel.highlightMenuColour ? self.ui.config.playbackSettingsPanel.highlightMenuColour : null;


        var highRowTick = document.createElement('div');
        highRowTick.className = 'p_qualityTick';
        qualityPanelHighRowHeading.appendChild(highRowTick);

        // --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---


        var triangle = document.createElement('div');
        triangle.className = 'p_downArrow';
        settingsContainer.appendChild(triangle);

        addQualityRowsListeners(self,player,qualityRow,qualityPanelLowRow,qualityPanelMediumRow,qualityPanelHighRow,qualitySubtitle,highlightMenuColour);
        checkInitialConfigAndUpdateStatusAndLabels(player,qualityRow,qualityPanelLowRow,qualityPanelMediumRow,qualityPanelHighRow,qualitySubtitle,highlightMenuColour);

        addToKeyboardLoop(self,qualityPanelHighRow,qualityRow,true);
        addToKeyboardLoop(self,qualityPanelLowRow,qualityRow,null,true);


        return settingsContainer;

    }

    function addQualityRowsListeners(self,player,qualityRow,qualityPanelLowRow,qualityPanelMediumRow,qualityPanelHighRow,qualitySubtitle,highlightMenuColour){

        
        Utils.multiAddEventListener(qualityPanelLowRow, 'click keyup', function(e) {

            if (isTabbing(e)){
                return;
            }
            setQuality(self,'low',player,qualityRow,qualityPanelLowRow,qualityPanelMediumRow,qualityPanelHighRow,qualitySubtitle,highlightMenuColour,true);
            self.ui.player.trackAction('playback_settings_low_option',e.type);

        },true);

        Utils.multiAddEventListener(qualityPanelMediumRow, 'click keyup', function(e) {

            if (isTabbing(e)){
                return;
            }
            setQuality(self,'medium',player,qualityRow,qualityPanelLowRow,qualityPanelMediumRow,qualityPanelHighRow,qualitySubtitle,highlightMenuColour,true);
            self.ui.player.trackAction('playback_settings_medium_option',e.type);

        }, true);

        Utils.multiAddEventListener(qualityPanelHighRow, 'click keyup', function(e) {

            if (isTabbing(e)){
                return;
            }
            setQuality(self,'high',player,qualityRow,qualityPanelLowRow,qualityPanelMediumRow,qualityPanelHighRow,qualitySubtitle,highlightMenuColour,true);
            self.ui.player.trackAction('playback_settings_high_option',e.type);

        },true );


        if (highlightMenuColour) {

            // main panel quality link
            Utils.multiAddEventListener(qualityRow, 'focusin mouseover keyup', function() {
                qualityRow.style.color = highlightMenuColour;

                var chevron = qualityRow.getElementsByClassName('p_chevronBorder')[0];
                chevron.style.borderColor = 'transparent transparent transparent '+ highlightMenuColour ;
            }, true);

            Utils.multiAddEventListener(qualityRow, 'focusout mouseout', function() {
                qualityRow.style.color = '#FFF';

                var chevron = qualityRow.getElementsByClassName('p_chevronBorder')[0];
                chevron.style.borderColor = 'transparent transparent transparent white';
            }, true);
            // ---- --- --- --- ---


            Utils.multiAddEventListener(qualityPanelLowRow, 'focusin mouseover', function() {

                qualityPanelLowRow.style.color = highlightMenuColour;

                var tick = qualityPanelLowRow.getElementsByClassName('p_qualityTick')[0];
                tick.style.borderColor = highlightMenuColour;

            }, true);

            Utils.multiAddEventListener(qualityPanelLowRow, 'focusout mouseout', function() {
                qualityPanelLowRow.style.color = '#FFF';

                var tick = qualityPanelLowRow.getElementsByClassName('p_qualityTick')[0];
                tick.style.borderColor = 'white';
            }, true);


            
            Utils.multiAddEventListener(qualityPanelMediumRow, 'focusin mouseover', function() {
                qualityPanelMediumRow.style.color = highlightMenuColour;

                var tick = qualityPanelMediumRow.getElementsByClassName('p_qualityTick')[0];
                tick.style.borderColor = highlightMenuColour;
            }, true);

            Utils.multiAddEventListener(qualityPanelMediumRow, 'focusout mouseout', function() {
                qualityPanelMediumRow.style.color = '#FFF';

                var tick = qualityPanelMediumRow.getElementsByClassName('p_qualityTick')[0];
                tick.style.borderColor = 'white';
            }, true);



            Utils.multiAddEventListener(qualityPanelHighRow, 'focusin mouseover', function() {
                qualityPanelHighRow.style.color = highlightMenuColour;

                var tick = qualityPanelHighRow.getElementsByClassName('p_qualityTick')[0];
                tick.style.borderColor = highlightMenuColour;
            }, true);

            Utils.multiAddEventListener(qualityPanelHighRow, 'focusout mouseout', function() {
                qualityPanelHighRow.style.color = '#FFF';

                var tick = qualityPanelHighRow.getElementsByClassName('p_qualityTick')[0];
                tick.style.borderColor = 'white';
            }, true);

        }
    }


    function getShowHidePanelFunction(self, ui) {

        return Utils.getActionFn(function(actionType, event) {

            if(self.playbackSettingsPanelShowing) {
                self.closePanel();
                self.ui.player.trackAction('playback_settings_closed',actionType);
            } else {
                self.showPanel();
                self.previousQuality = self.selectedQuality;
                self.ui.player.trackAction('playback_settings_show',actionType);
                ui.resetIdleTimeout(event);
            }

        });

    }

    function setButtonText(self, text) {

        self.openCloseButton.title = text;
        self.openCloseButton.setAttribute('aria-label', text);

        var hiddenElement = self.openCloseButton.getElementsByClassName('p_hiddenElement')[0];
        hiddenElement.innerHTML = text;

    }

    var PlaybackSettingsPanel = function(ui, getButton) {

        this.ui = ui;
        this.playbackSettingsPanelShowing = false;
        this.showingQualityPage = false;
        this.player = ui.player;

        this.selectedQuality = (ui.player.config.quality === 'hd') ? 'high' : ui.player.config.quality;
        this.previousQuality = (ui.player.config.quality === 'hd') ? 'high' : ui.player.config.quality;
        this.previousContinuousPlayStatus = ui.player.config.continuousPlay; 
        this.newContinuousPlayStatus = ui.player.config.continuousPlay;
        
        this.openCloseButton = getButton("p_playbackSettingsButton p_dontCloseSettingsPanel", getShowHidePanelFunction(this, ui), Language.openPlaybackSettingsMenuNew, Language.openPlaybackSettingsMenuNew, ui, false, 'playback-settings');

        this.playbackSettingsContainer = createPlaybackSettingsContainer(this);

    };

    PlaybackSettingsPanel.prototype = {

        getOpenCloseButton: function() {
            return this.openCloseButton;
        },

        getPanel: function() {
            return this.playbackSettingsContainer;
        },

        isPanelOpen: function() {
            return this.playbackSettingsPanelShowing;
        },

        showPanel: function() {
            if(!this.playbackSettingsPanelShowing) {
                this.ui.closeSettingsPanels();
                this.settingsContainer.style.display = 'block';
                Utils.className(this.openCloseButton, 'p_settingsPanelOpen');
                this.playbackSettingsPanelShowing = true;
                setButtonText(this, Language.closePlaybackSettingsMenu);
                this.ui.player.Subtitles.updatePositions();
                Utils.className(document.body, 'controlsPanelOpen', '');
                this.ui.player.dispatch({type:'controlsPanelOpened'});
            }
        },

        closePanel: function() {

            this.resetMainPage();

            if(this.playbackSettingsPanelShowing) {
                this.settingsContainer.style.display = 'none';
                Utils.className(this.openCloseButton, '', 'p_settingsPanelOpen');
                this.playbackSettingsPanelShowing = false;
                setButtonText(this, Language.openPlaybackSettingsMenuNew);
                this.ui.player.Subtitles.updatePositions();
                Utils.className(document.body, '', 'controlsPanelOpen');
                
                sendStats(this);
            }

            this.hasFocus=false;
            Utils.className(this.settingsContainer, "","p_qualityPageOpen");
        },

        getPanelTop: function() {
            return Utils.getOffset(this.settingsBox, 'top');
        },

        setAutoplay: function(set) {
            if (set) {
                this.autoplayToggle.setOn();
            } else {
                this.autoplayToggle.setOff();
            }
        },
        showOrHideContinuousPlaySetting:function(show) {
            this.autoplayRow.style.display = show ? 'block' : 'none';
        },

        updateLanguage: function() {

            this.settingsHeading.textContent = Language.playbackSettingsHeading;
            this.autoplaySettingHeading.textContent = Language.autoplaySettingHeading;
            this.autoplaySettingSubheading.textContent = Language.autoplaySettingSubheading;
            this.autoplayToggle.updateLanguage(Language.autoplaySettingHeading);

            this.qualitySettingHeadingText.textContent = Language.qualitySettingHeading;

            if (this.selectedQuality === 'high') {
                this.qualityRow.setAttribute('aria-label', Language.qualitySettingOpenHighSelected);
                this.qualitySettingSubheading.textContent = Language.qualityPanelHighRowHeading;
            } else if (this.selectedQuality === 'medium') {
                this.qualityRow.setAttribute('aria-label', Language.qualitySettingOpenMediumSelected);
                this.qualitySettingSubheading.textContent = Language.qualityPanelMediumRowHeading;
            } else if (this.selectedQuality === 'low') {
                this.qualityRow.setAttribute('aria-label', Language.qualitySettingOpenLowSelected);
                this.qualitySettingSubheading.textContent = Language.qualityPanelLowRowHeading;
            }

            this.qualityPanelLowRowHeadingText.textContent = Language.qualityPanelLowRowHeading;
            this.qualityPanelMediumRowHeadingText.textContent = Language.qualityPanelMediumRowHeading;
            this.qualityPanelHighRowHeadingText.textContent = Language.qualityPanelHighRowHeading;
            this.qualityPanelHighRowSubtitleText.textContent = Language.qualityPanelHighRowSubtitle;
            this.qualitySettingUnavailableSubheading.textContent = Language.qualitySettingOpenUnavailable;
    

            if(this.isPanelOpen()) {
                setButtonText(this, Language.closePlaybackSettingsMenu);
            } else {
                setButtonText(this, Language.openPlaybackSettingsMenuNew);
            }

        },

        resetMainPage : function(){

            this.showingQualityPage = false;
            this.settingsHeading.textContent = Language.playbackSettingsHeading;

            this.qualityListWrap.style.display = 'none';

            if (this.ui.config.playbackSettingsPanel.continuousPlaySetting) {
                this.autoplayRow.style.display = 'block';
            }
            if (this.ui.config.playbackSettingsPanel.qualitySetting) {
                this.qualityRow.style.display = 'block';
            }

            Utils.className(this.settingsContainer, "","p_qualityPageOpen");

        },

        switchPageSetting: function(fromKeyboard){

            clearTimeout(this.ui.idleTimeoutInterval);

            if (this.showingQualityPage) {
                this.autoplayRow.style.display = 'none';
                this.qualityRow.style.display = 'none';
            }

            this.settingsHeading.textContent = Language.qualitySettingHeading;
            this.qualityListWrap.style.display = 'block';

            Utils.className(this.settingsContainer, "p_qualityPageOpen","");

            if (fromKeyboard) {
                this.qualityPanelLowRow.focus();
            }

        },

        checkQualityAvailability: function(castConnected,castDisconnected){

            var player  = this.ui.player;
            var isPlayingDash = player.isPlayingDash;
            var isPlayingFlash = player.isPlayingFlash;
            var isAudio = player.isAudio;

            if ( (isPlayingDash || isPlayingFlash) && !isAudio && (!castConnected || castDisconnected) ) {

                Utils.className(this.qualityRow, "","p_qualitySettingUnavailable");
                this.qualityRow.setAttribute('aria-hidden', 'false');
                this.qualityRow.tabIndex = '';
            } else {
                Utils.className(this.qualityRow, "p_qualitySettingUnavailable","");
                this.qualityRow.setAttribute('aria-hidden', 'true');
                this.qualityRow.tabIndex = '-1';
            }
        }
    };

    return PlaybackSettingsPanel;

})();var ErrorDialog = (function() {

    function colourOnHover(stylesheet, classnames, colour, foreColour) {
        Utils.deleteCssRules(stylesheet,classnames);
        for (var i=0;i<classnames.length;i++) {
            var classname = classnames[i];
            stylesheet.insertRule(".p_buttonHover." + classname + ", .focusEnabled ." + classname + ":focus { background-color: " + colour + "; color: "+foreColour+" }",0);
        }
    }

    function addHoverListeners(button) {
        // SMPHTML-1170: Replace css hover with class to overcome
        // inconsistent touch device behaviour
        button.addEventListener("mouseover", function() {
            Utils.className(button,"p_buttonHover");
        });
        button.addEventListener("mouseout", function() {
            Utils.className(button,"","p_buttonHover");
        });
        // Disable background color transition on touch
        button.addEventListener("touchstart", function() {
            Utils.className(button,"p_buttonHover p_buttonTouch");
        },{passive:true} );
        button.addEventListener("touchend", function() {
            Utils.className(button,"","p_buttonHover p_buttonTouch");
        });
    }

    function getErrorDialog(ui, code) {
        // XXX should probably be more complicated
        return function(event) {
            var forEmbedded = (code == SMPError.EMBED_NOT_ALLOWED);
            var action = forEmbedded ? 'embed_error_navigate' : 'error';
            var type = Utils.getActionType(event);

            if (!forEmbedded) {
                // reload playlist
                var options={playlistObject: ui.player.playlist, startTime: ui.player.timeHelper.time, autoplay:true };
                if (code==SMPError.CANNOT_MAINTAIN_LOCK) {
                    options.maintainTheLock = false;
                }
                var md=ui.markerData;
                var wd=ui.player.webcastData;
                ui.player.api.loadPlaylist2( options );
                ui.player.api.setData({name:"SMP.markers",data:md});
                ui.player.api.setData({name:"SMP.webcastData",data:wd});
                // XXX need to bring all the setData things in too.
            }
            ui.player.trackAction(action, type);
        };
    }

    var errorDialog = function(ui) {

        this.ui = ui;
        this.player = ui.player;

    };

    errorDialog.prototype = {

        shouldShowSmallErrorVersion: function() {

            if(this.ui.config.skin == 'audio' || (this.ui.config.skin == 'classic' && this.ui.miniModeEnabled)) {
                return true;
            } else {
                return false;
            }

        },

        hideErrorDialog : function() {
            var self = this;
            if (self.error) {

                // XXX this probably needs to be more efficient check
                // on if it should be block or not.
                // if (self.ui.enabled && ui.controls) {
                //     ui.controls.style.display="block";
                // }

                self.player.dispatch({type:"beforeErrorHide"}); //TODO show controls

                self.error.className = "p_none";
                self.error = null;
                if (self.errorWrapper) {
                    self.errorWrapper.parentNode.removeChild(self.errorWrapper);
                }
                Utils.className(document.body, '', 'errorShowing');
            }
        },

        createErrorDialog : function(code) {
            var self = this;
            if (!self.error) {

                var showSmallVersion = self.shouldShowSmallErrorVersion();

                if(showSmallVersion) {
                    Utils.className(document.body, 'p_smallErrorVersion');
                } else {
                    Utils.className(document.body, '', 'p_smallErrorVersion');
                }

                var errorContainer = createElement("div","p_errorDialog");
                var div = createElement("div","p_errorBackground");
                errorContainer.appendChild(div);

                self.alertImageContainer = Utils.generateSVG(50.3,44,"alert","p_alertIcon");
                Utils.className(self.alertImageContainer, (showSmallVersion ? " alertIconHolder showSmallVersion" : " alertIconHolder"));

                self.errorMessageContainer = createElement("div","","<span class='p_errorPrimary'></span>");
                self.errorMessageContainer.setAttribute("role","alert");

                if (!showSmallVersion) {
                    div.appendChild(self.alertImageContainer);
                    div.appendChild(self.errorMessageContainer);
                }

                self.updateErrorDialog();

                var link = document.createElement("a");
                var refreshLink = document.createElement("a");
                if (code == SMPError.EMBED_NOT_ALLOWED) {
                    link.textContent = Language.viewThisContentOnTheBBC;
                    link.href = self.ui.player.playlist.alternateHref;
                    link.target = "new_page";
                } else {
                    link.textContent = Language.tryAgain;
                }

                var refreshImageContainer = Utils.generateSVG(34,34.5,"refresh","p_refreshIcon");
                refreshLink.appendChild(refreshImageContainer);

                addHoverListeners(link);
                addHoverListeners(refreshLink);

                var errorEvent = getErrorDialog(self.ui,code);
                Utils.multiAddEventListener(link,"touchend click mouseup",errorEvent);
                Utils.multiAddEventListener(refreshLink, "touchend click mouseup", errorEvent);

                div.appendChild(link);
                self.errorLink = link;

                //in order for this div to occupy all the space
                //between the floating alertIcon div and the errorLink
                //div add it after
                if (showSmallVersion){
                    div.appendChild(refreshLink);
                    div.appendChild(self.alertImageContainer);
                    div.appendChild(self.errorMessageContainer);
                }

                self.errorRefreshLink = refreshLink;

                self.errorHelpText = createElement("span","p_errorSecondary p_none");
                div.appendChild(self.errorHelpText);

                self.errorWrapper = createElement("div","p_errorWrapper");
                self.errorWrapper.appendChild(errorContainer);
                self.ui.container.appendChild(self.errorWrapper);
                self.error = errorContainer;
            }
        },
        drawErrorDialog : function(event) {
            var self = this;
            self.player.dispatch({type:"notPlayingState"});
            self.player.inErrorState = true;

            if(self.ui.enabled && self.ui.config.errorDialog.enabled) {

                var secondaryText = '';
                if (event.secondaryText && event.secondaryText !== "" && !event.recoverable) {
                    secondaryText = event.secondaryText;
                }

                self.drawError(event.description, event.secondaryText, event.recoverable, event.code);

                var audibleAlert = event.description + ' ' + secondaryText;
                ScreenReader.alert(audibleAlert);
                // If there's an error...
            }
        },
        drawError : function(primaryText, secondaryText, showRefreshLink, code) {
            var self = this;

            self.player.dispatch({type:"beforeErrorDisplay"});

            self.createErrorDialog(code);

            //Clear fallback stuff if it exists.
            var oldText = self.errorMessageContainer.getElementsByClassName("p_fallbackText");
            if (oldText.length > 0) {
                oldText[0].parentNode.removeChild(oldText[0]);
            }

            var oldButton = self.errorMessageContainer.getElementsByClassName("p_fallbackButton");
            if (oldButton.length > 0) {
                oldButton[0].parentNode.removeChild(oldButton[0]);
            }

            self.errorMessageContainer.firstChild.textContent = primaryText;
            self.error.className = "p_errorDialog";
            self.errorLink.className = showRefreshLink ? "p_errorDialog_a" : "p_none";
            self.errorRefreshLink.className = showRefreshLink ? "p_errorRefreshDialog_a" : "p_none";

            if (secondaryText) {
                self.errorHelpText.textContent = secondaryText;
                Utils.className(self.errorHelpText, '', 'p_none');
            } else {
                Utils.className(self.errorHelpText, '');
            }

            Utils.className(document.body, 'errorShowing');

        },
        updateErrorDialog: function() {
            var self = this;
            colourOnHover(self.ui.stylesheet, ["p_fallbackButton","p_errorDialog_a","p_errorRefreshDialog_a"], self.ui.config.colour, self.ui.config.foreColour);
        },
        flashFallbackDialog : function(error, useMediaPlayerApp, actionFunc) {
            var self = this;
            self.player.inErrorState = true;
            self.player.dispatch({type:"notPlayingState"});

            if(self.ui.enabled && self.ui.config.errorDialog.enabled) {
                //Check the size of the player. If it's smaller than
                //231px(the smallest error dialog we can draw), send
                //it to bump.

                var width = Utils.getOffset(self.ui.player.mediaContainer, 'width');
                if (width < 231) {// ||.height < )??
                    self.drawError("","",false,false);
                    //dispatch event for bump to handle.
                    self.player.dispatch({type:"flashFallbackGoToBump"});
                } else { //Draw dialog natively.
                    if (useMediaPlayerApp) {
                        self.drawError(error.description, "", false, false);
                        Utils.className(self.error, "p_fallbackDialog");

                        //Append fallback button.
                        var fallbackButton = document.createElement("div");
                        fallbackButton.className = "p_fallbackButton";
                        fallbackButton.textContent = Language.useMediaPlayerApp;
                        Utils.multiAddEventListener(fallbackButton, "touchend click mouseup", function (event) {
                            self.player.trackAction(Utils.getActionType(event), 'use_media_player_app');
                            actionFunc();
                        });
                        self.errorMessageContainer.appendChild(fallbackButton);

                    } else {
                        self.drawError(error.description, "", false, false);
                        Utils.className(self.error, "p_fallbackDialog");

                        var enableText = document.createElement("span");
                        Utils.className(enableText, "p_fallbackText");
                        var text = Language.enableFlash;
                        if(self.shouldShowSmallErrorVersion()) { //Append to the existing paragraph
                            text = " "+(width < 320 ? Language.enableFlashShort : text);
                            self.errorMessageContainer.firstChild.appendChild(enableText);
                        } else { //Make a new paragraph
                            Utils.className(enableText, "p_errorSecondary");
                            self.errorMessageContainer.appendChild(enableText);
                        }

                        var getFlashHref = "https://get.adobe.com/flashplayer";
                        enableText.innerHTML = text.replace("{link}", "<a href='" + getFlashHref + "' target='getFlash'>" + Language.downloadFlashLink + "</a>");
                        var downloadLink = enableText.getElementsByTagName('a')[0];
                        if (downloadLink) {
                            Utils.multiAddEventListener(downloadLink, "touchend click mouseup",
                                function (event) {
                                    self.player.trackAction(Utils.getActionType(event), 'download_flash_player');
                                });
                        }
                    }
                }
            }
        },

        getEventCallbacks: function () {

            var self = this;

            return {

                playing: function() {

                    self.hideErrorDialog();

                },

                playerDisconnected: function() {

                    self.hideErrorDialog();

                },

                playlistLoading: function() {

                    self.hideErrorDialog();

                },

                playlistLoaded: function() {

                    self.hideErrorDialog();

                },

                error: function(event) {
                    // Note hide buffer must come before drawing an error
                    // because of Aria alert messaging, we should possibly
                    // reconsider this if the ScreenReader object could be better.
                    switch(event.code) {
                        case SMPError.FLASH_NOT_CREATED:
                        case SMPError.FLASH_NOT_INITIALISED:
                        case SMPError.FLASH_NOT_INSTALLED:
                            self.flashFallbackDialog(event, false, null);
                            break;
                        case SMPError.CANT_PLAY_IN_ANDROID_BROWSER:
                            self.flashFallbackDialog(event, true, function() {
                                if (DEBUG_FULL) {
                                    console.log('falling back to bump');
                                }
                                self.player.playInBump();
                            });
                            break;
                        default:
                            if (!event.nonPlayer && event.severity==CRITICAL){
                                self.drawErrorDialog(event);
                            }
                            break;
                    }
                }

            };
        }

    };

    return errorDialog;

})();var ProgressBar = (function() {

    var TIP_TRIANGLE_CENTRE = 6;

    function getSeekBarPadding(self) {

        var padding = getComputedStyle(self.seekBar).getPropertyValue('left');

        return parseInt(padding,10);

    }
    function sendSeekStats(self, actionType, position) {
        clearTimeout(self.seekTrackTimer);
        self.seekTrackTimer = setTimeout(function() {
                self.player.trackAction('seek_bar', actionType, {'seek_time' :  position, 'before_seek_time':self.startingTime});
                self.startingTime=-1;
        },STATS_TRACK_DELAY);
    }

    function getSeekTranslation(time,duration) {
        return Language.audioToolTipSeekBarPrefix+" "+time+" "+Language.audioToolTipSeekBarSuffix+" "+duration;
    }

    function getOnSeekThumbKeyDown(self) {

        var seekbarUpdateProgress = function(percent) {
            self.player.isSeeking = true;
            self.updateProgressBar(percent, true);
            self.ui.updateTimeDisplay(self.ui.player.timeHelper.percentToTime(percent));
        };

        return function(event) {

            if (!self.seekDone) {
                self.seekDone = function() {
                    self.player.isSeeking = false;
                };
            }
            if (!self.player.isSeeking) {
                self.seekToPos = self.player.timeHelper.timeToPercent(self.player.time);
            }

            var code = event.keyCode;
            if (code == KEY_DOWN_ARROW || code == KEY_LEFT_ARROW) {
                self.seekToPos = Math.max(0,self.seekToPos-0.01);
                seekbarUpdateProgress(self.seekToPos);
                stopIt(event);
            }

            if (code == KEY_UP_ARROW || code == KEY_RIGHT_ARROW) {
                self.seekToPos = Math.min(self.seekToPos+0.01, self.player.timeHelper.getLatestAllowableSeekPercent());
                seekbarUpdateProgress(self.seekToPos);
                stopIt(event);
            }

            if (code == KEY_HOME || code == KEY_END) {
                self.seekToPos = (code == KEY_HOME ? self.player.timeHelper.earliestSeek : self.player.timeHelper.latestAllowableSeekTime);
                stopIt(event);
            }

            if(code == KEY_SPACE) {
                self.ui.togglePlay('shortcut_key_press');
                stopIt(event);
            }
        };
    }

    function getOnSeekThumbKeyUp(self) {
        return function(event) {
            var time = NaN;
            var prefix = "";
            var code = event.keyCode;
            if (code == KEY_DOWN_ARROW || code == KEY_LEFT_ARROW ||code == KEY_UP_ARROW || code == KEY_RIGHT_ARROW || code == KEY_HOME || code == KEY_END) {
                time = self.player.timeHelper.percentToTime(self.seekToPos);
                stopIt(event);
            }
            if (code == KEY_HOME || code == KEY_END) {
                prefix = "shortcut_";
            }

            if (!isNaN(time)) {
                if (self.seekDone) {
                    self.seekDone();
                }
                self.player.time = time;
                var displayFraction = self.player.timeHelper.timeToPercent(time);
                self.updateProgressBar(displayFraction, true);
                sendSeekStats(self, prefix+'key_press', time);
            }

            self.seekThumb.setAttribute("aria-valuetext",getSeekTranslation(self.player.timeHelper.timeToString(self.player.time), self.player.timeHelper.getDurationOrEndString()));
        };
    }

    function getOnSeekThumbFocusIn(self) {
        return function(event) {
            if (event.keyCode == 9) {
                var percent = self.player.timeHelper.timeToPercent(self.player.time);
                self.drawTip(percent);
                self.seekThumbHasFocus = true;
            }
        };
    }

    function getOnSeekThumbFocusOut(self) {
        return function() {
            self.hideTip();
            if (self.seekDone) {
                self.seekDone();
            }
            self.seekThumbHasFocus = false;
        };
    }

    function animationClear(self) {
        Utils.className(self.progressBar,"","p_progressBarAnimate");
        Utils.className(self.seekThumb,"","p_seekThumbAnimate");
        animationSetState(self,null);
        Utils.applyVendorStyles([self.progressBar,self.seekThumb], "transform", null);
        if (self.progressBar) {
            self.progressBar.style.width = null;
            self.progressBar.animation.cssApplied = false;
            self.progressBar.animation.paused = false;
            self.progressBar.animation.animating = false;
        }
    }

    function animationGetPosition(self) {
        var arrStr = getComputedStyle(self.progressBar).getPropertyValue('transform')+"";
        return parseFloat(arrStr.split(',')[0].split('(')[1]);
    }

    function animationSetState(self, state) {
        Utils.applyVendorStyles([self.progressBar,self.seekThumb], "animationPlayState", state);
    }

    function getPercentAlongScrubBar(self, x) {

        var maxPos = self.seekBar.clientWidth;
        var newPos = x - Utils.getOffset(self.seekBar);
        var percent = Math.max(0,Math.min(newPos,maxPos)) / maxPos;
        var latestAllowablePercent = self.player.timeHelper.getLatestAllowableSeekPercent();

        if (percent > latestAllowablePercent) {
            percent = latestAllowablePercent;
        }

        return percent;

    }

    function seekStart(self) {

        var doc = window.document;
        var touchMoved = false;
        var seekTime = 0;
        var xDown;

        function removeAll() {
            // XXX these need to be removed whenever isSeeking is
            // set to false.
            if (seekMove) {
                doc.removeEventListener('mousemove', seekMove, true);
                doc.removeEventListener('touchmove', seekMove, true);
                doc.removeEventListener('pointermove', seekMove, true);
            }
            if (seekEnd) {
                doc.removeEventListener('mouseup', seekEnd, true);
                doc.removeEventListener('touchend', seekEnd, true);
                doc.removeEventListener('pointerup', seekEnd, true);
            }
        }

        function seekMove(event) {

            var newX = (event.type.substr(0,5) == 'touch') ? event.targetTouches[0].clientX : event.clientX;

            var percent = getPercentAlongScrubBar(self, newX);
            seekTime = self.player.timeHelper.percentToTime(percent);

            if (Math.abs(xDown - newX) > 2) {
                self.updateProgressBar(percent, true);
                self.ui.updateTimeDisplay(seekTime);
                touchMoved = true;
            }
        }

        function seekEnd(event) {
            var seekBarAction = 'click';
            var actuallySeek = true;
            if (touchMoved) {
                seekBarAction = 'drag';
            } else {
                var x = (event.type.substr(0,5) == 'touch') ? event.changedTouches[0].clientX : event.clientX;
                var percent = getPercentAlongScrubBar(self, x);
                seekTime = self.player.timeHelper.percentToTime(percent);
            }

            if (seekTime == self.player.timeHelper.time) {
                actuallySeek = false;
            }
            if (actuallySeek) {
                self.player.time = seekTime;
                sendSeekStats(self, seekBarAction, Math.floor(seekTime));
            }

            var hideTip = event.type == "touchend" || (event.type == "pointerup" && event.pointerType != 'mouse') || !self.seekBarHolder.contains(event.target) || Device.ios;

            //ui.updateDisplayedProgress(seekTime, !hideTip);
            var displayFraction = self.player.timeHelper.timeToPercent(seekTime);
            self.updateProgressBar(displayFraction, !hideTip);
            //TODO Fire event for updateDisplayedProgress?

            if (hideTip) {
                self.hideTip();
            }

            self.seekDone();

            // if the media has finished allow user to seek back
            // and continue play
            if (self.player.paused && self.player.mediaEnded) {
                self.player.mediaEnded = false;
                self.player.requestGuidanceAndPlay();
            }

        }

        self.seekDone = function() {
            removeAll();
            self.player.isSeeking = false;
        };

        return function(event) {

            xDown = (event.type.substr(0,5) == 'touch') ? event.targetTouches[0].clientX : event.clientX;

            var duration = self.player.timeHelper.duration;

            if (duration < 1 || self.ui.container.className == "controlsFadedOut") { //TODO Where to get this from
                // if there's no duration there's no seeking.
                // if the controls are faded out you can't click on the seekbar to seek
                return;
            }

            self.startingTime=self.player.time;
            self.player.isSeeking = true;
            touchMoved = false;
            //ui.markersUI.markerMouseOut(ui.markersUI.currentlyOver); //TODO Fire event?
            removeAll();

            if (event.type == "mousedown") {
                doc.addEventListener('mousemove', seekMove, true);
                doc.addEventListener('mouseup', seekEnd, true);
            } else if (event.type == "pointerdown") {
                doc.addEventListener('pointermove', seekMove, true);
                doc.addEventListener('pointerup', seekEnd, true);
            } else {
                doc.addEventListener('touchmove', seekMove, true);
                doc.addEventListener('touchend', seekEnd, true);
            }

        };
    }

    function seekOver(self) {

        var first = true;
        var timeoutInterval = null;

        return function(event) {

            if (self.player.isSeeking) {
                return;
            }

            clearTimeout(timeoutInterval);
            timeoutInterval = setTimeout(function() {
                first = true;
            }, 500);

            if (first) {
                first = false;
                return;
            }

            var duration = self.player.timeHelper.duration;
            if (duration < 1 || isNaN(duration)) {
                self.hideTip();
                return;
            }

            var percent = getPercentAlongScrubBar(self, event.clientX);

            self.drawTip(percent);
            self.seekOver = true;
        };
    }

    function seekOut(self) {
        return function() {

            if (!self.player.isSeeking) {
                self.hideTip();
            }

            self.seekOver = false;
        };
    }

    function applyConfigSettings(self) {

        Utils.deleteCssRules(self.ui.stylesheet, [".p_progressBar", ".audioUI .p_seekThumb", ".audioUI .p_seekThumbHalo", ".classicUI .focusEnabled .p_seekThumb:focus", ".classicUI .focusEnabled .p_seekThumb:focus > .p_seekThumbLine"]);
        self.ui.stylesheet.insertRule(".p_progressBar { background: " + (self.ui.config.controls.seekbarBackground ? self.ui.config.controls.seekbarBackground : self.ui.config.colour)+"; }", 0);
        self.ui.stylesheet.insertRule(".audioUI .p_seekThumb { background-color: " + self.ui.config.colour + "; }",0);
        self.ui.stylesheet.insertRule(".audioUI .p_seekThumbHalo { background-color: " + self.ui.config.colour + "; }",0);
        self.ui.stylesheet.insertRule(".classicUI .focusEnabled .p_seekThumb:focus { background-color: " + self.ui.config.colour + "; }",0);
        self.ui.stylesheet.insertRule(".classicUI .focusEnabled .p_seekThumb:focus > .p_seekThumbLine { background-color: " + self.ui.config.foreColour + "; }",0);

    }

    var progressBar = function(ui) {

        this.player = ui.player;
        this.ui = ui;
        this.seekThumbHasFocus = false;
        this.seekTrackTimer = -1;
        applyConfigSettings(this);
        this.drawDesktopUI();

    };

    progressBar.prototype = {

        getSeekBarOffsetWidth: function() {

            return this.seekBar.offsetWidth;

        },

        drawDesktopUI: function() {

            var seekBarHolder = this.seekBarHolder = createElement('div','p_playerSeekBarHolder');
            var seekBar = this.seekBar = createElement('div','p_bar p_seekBar');
            seekBarHolder.appendChild(seekBar);
            var seekBarPositionLine = this.seekBarPositionLine = createElement('div','p_seekBarPositionLine');
            seekBar.appendChild(seekBarPositionLine);
            var progressBar = this.progressBar = createElement('div','p_bar p_progressBar');

            progressBar.animation = {
                cssApplied : false,
                paused : false,
                animating : false,
                supported : Device.scrubAnimation && Utils.checkCssSupport(seekBarHolder,"transform"), //TODO Check this works
                supportsCompensation : Device.animationCompensationSupported
            };

            var progressBarAvailable = this.progressBarAvailable = createElement('div','p_bar p_progressBar p_progressBarAvailable');
            seekBarHolder.appendChild(progressBarAvailable);
            seekBarHolder.appendChild(progressBar);

            var seekHelpText = this.seekHelpText = document.createElement('div');
            seekHelpText.id = 'p_seekHelpText';
            seekHelpText.style.display = 'none';
            seekHelpText.textContent = Language.seekBarDescription;
            seekBar.appendChild(seekHelpText);

            //var seekThumb = this.seekThumb = getButton("p_seekThumb",null,"Seek bar","Seek bar",ui);
            var seekThumb = this.seekThumb = createElement('button', 'p_button p_seekThumb');
            seekThumb.title = Language.seekBarName;
            seekThumb.setAttribute('aria-label', Language.seekBarName);
            seekThumb.style.display = "none";
            seekThumb.setAttribute('role', 'slider');
            seekThumb.setAttribute("aria-control","video");
            seekThumb.setAttribute("aria-valuemin","0");
            seekThumb.setAttribute("aria-valuemax","100");
            seekThumb.setAttribute("aria-valuetext",getSeekTranslation("00:00","00:00"));
            seekThumb.setAttribute('aria-describedby', seekHelpText.id);

            var seekThumbLine = createElement('div','p_seekThumbLine');
            seekThumb.appendChild(seekThumbLine);

            var seekThumbHalo = this.seekThumbHalo = createElement('div','p_seekThumbHalo');
            seekThumb.appendChild(seekThumbHalo);

            seekBarHolder.appendChild(seekThumb);

            var tip = this.tip = createElement('div','p_timeTip','<span class="p_timeTipText"></span>');
            tip.setAttribute("aria-hidden", "true");
            var tipTriangle = this.tipTriangle = createElement('div','p_timeTipTriangle');
            tip.appendChild(tipTriangle);

            this.thumbnailDiv = createElement('div', 'p_thumbnail');

            // Add Event Listeners

            seekThumb.addEventListener('keydown', getOnSeekThumbKeyDown(this));
            seekThumb.addEventListener('keyup', getOnSeekThumbKeyUp(this));
            Utils.multiAddEventListener(seekThumb,'keyup', getOnSeekThumbFocusIn(this));
            Utils.multiAddEventListener(seekThumb,'blur focusout', getOnSeekThumbFocusOut(this));

            Utils.downAction(this.seekBarHolder, seekStart(this), true);
            Utils.hoverMoveAction(this.seekBarHolder, seekOver(this), true);
            Utils.hoverLeaveAction(this.seekBarHolder, seekOut(this), false);

            return seekBarHolder;

        },

        getDomNodes: function() {
            return [this.seekBarHolder,this.thumbnailDiv,this.tip];
        },

        updateProgressBar: function(progressFraction, addTip) {

            var self = this;

            if (self.seekBar.clientWidth<50) {
                return;
            }

            var timeHelper = self.player.timeHelper;
            if (timeHelper.duration && !isNaN(progressFraction)) {
                self.seekThumb.style.display = "block";
            } else {
                progressFraction = 0;
                self.seekThumb.style.display = "none";
            }

            // XXX too many closures in a function that is called,
            // very very regularly, should update this so the
            // functions are not recreated.

            var setPosition = function(progress) {

                if (animateProgressBar) {
                    if (isNaN(progress)) {
                        progress = animationGetPosition(self);
                        if (progress === 1) { //On Safari, a paused animation returns 1 (end). This is not cool.
                            progress = progressFraction;
                        }
                    }

                    // XXX do we actually need all of these reset,
                    // it's close to animationClear but not the same??
                    Utils.className(self.progressBar,"","p_progressBarAnimate");
                    Utils.className(self.seekThumb,"","p_seekThumbAnimate");
                    animationSetState(self,null);
                    Utils.applyVendorStyles([self.progressBar,self.seekThumb], "transform", null);
                    self.progressBar.style.right = "";
                    self.seekThumb.style.right = seekBarPadding + "px";
                    self.progressBar.style.width = seekBarWidth + "px";
                    Utils.applyVendorStyles([self.progressBar], "transform", "scale(" + progress + ", 1)");
                    Utils.applyVendorStyles([self.seekThumb], "transform", "translate(" + (-Math.round((seekBarWidth * (1-progress)) - (self.seekThumb.offsetWidth/2))) + "px, 0px)");
                    self.progressBar.animation.cssApplied = true;
                } else {
                    progress = isNaN(progress) ? progressFraction : progress;
                    var right = Math.round(seekBarWidth * (1 - progress)) + seekBarPadding;
                    self.progressBar.style.right = right + "px";
                    self.seekThumb.style.right = Math.round(right - (self.seekThumb.offsetWidth/2))  + "px";
                }
            };

            var animationStart = function(from) {

                setPosition(from);
                var durationSecs =  (1/playbackRate) * timeHelper.duration * (1 - progressFraction)+"s";
                Utils.applyVendorStyles([self.progressBar,self.seekThumb], "animationDuration", durationSecs);

                Utils.className(self.progressBar,"p_progressBarAnimate");
                Utils.className(self.seekThumb,"p_seekThumbAnimate");
                self.progressBar.animation.animating = true;
            };

            var animationPause = function(progress) {
                setPosition(progress);
                animationSetState(self,"paused");
                self.progressBar.animation.paused = true;
            };
            var animationResume = function(progress) {
                animationStart(progress);
                animationSetState(self,"running");
                self.progressBar.animation.paused = false;
            };

            var seekBarPadding = getSeekBarPadding(self);
            var seekBarWidth = self.seekBar.clientWidth;
            var playbackRate = (self.player.mediaPlayer.playbackRate===undefined) ? 1 : self.player.mediaPlayer.playbackRate;

            var updateTarget = self.progressBar.animation.target===undefined || self.progressBar.animation.target != seekBarPadding;
            var updateWidth = self.progressBar.animation.width===undefined || (self.progressBar.animation.animating && self.progressBar.animation.width != seekBarWidth);
            var animateProgressBar = !self.player.isLive && !self.player.isSeeking && self.progressBar.animation.supported && !self.ui.UIinfoObject.markersBarVisible && (seekBarWidth/timeHelper.duration)>1; //TODO UIinfoObject?

            if (!animateProgressBar) {
                if (self.progressBar.animation.cssApplied) {
                    animationClear(self);
                }
                setPosition(progressFraction);
            } else {
                if (self.player.playingState=="playing" && !self.player.waiting && playbackRate>0 && progressFraction<1 && (self.player.mediaPlayer.readyState===undefined || self.player.mediaPlayer.readyState>2) ) {
                    if (updateTarget || updateWidth) {
                        setPosition(progressFraction);
                        self.progressBar.animation.target = seekBarPadding;
                        self.progressBar.animation.width = seekBarWidth;
                    } else if (self.progressBar.animation.paused) {
                        animationResume();
                    } else if (!self.progressBar.animation.animating) {
                        animationStart(progressFraction);
                    } else {
                        var actual = animationGetPosition(self) || 0;
                        var delta = Math.abs((progressFraction-actual)* timeHelper.duration);
                        if ( delta>0.5 && !self.progressBar.animation.supportsCompensation) {
                            if (DEBUG_FULL) { console.log("no compensation delta is:"+delta); }
                            // Browser can't handle animation pauses, so failover to old method if animation is out by >0.5s
                            self.progressBar.animation.supported = false;
                            animateProgressBar = false;
                            animationClear(self);
                            setPosition(actual);
                        } else if (delta>0.25 && self.progressBar.animation.supportsCompensation) {
                            // Compensate for error/drift mid-animation
                            animationPause();
                            animationResume();
                        }
                    }
                } else if (self.progressBar.animation.animating && !self.player.isSeeking && progressFraction>0 && progressFraction<1) {
                    animationPause();
                } else {
                    animationClear(self);
                    setPosition(progressFraction);
                }
            }

            var availablePercent  = self.player.timeHelper.getLatestAllowableSeekPercent();

            if (availablePercent < 1) {
                // SMPHTML-1188
                Utils.setOrUnsetClassOnlyAfterCheck(self.ui.container,'seekingBarNotFullyAvailable',true,null);

                if (availablePercent>progressFraction) {
                    var availableRight = Math.round(seekBarWidth * (1 - availablePercent)) + seekBarPadding;
                    self.progressBarAvailable.style.right = availableRight + "px";
                }
            } else {
                Utils.setOrUnsetClassOnlyAfterCheck(self.ui.container,'seekingBarNotFullyAvailable',null,true); 
            }


            //Don't update aria values when focused as it spams the
            //screen reader
            if (!self.seekThumbHasFocus) {
                var time = timeHelper.percentToTimeString(progressFraction);
                self.seekThumb.setAttribute("aria-valuetext",getSeekTranslation(time, self.player.timeHelper.getDurationOrEndString()));
            }

            var s = Math.floor(timeHelper.time);
            if (addTip && (!animateProgressBar || !self.seekThumbHasFocus || self.progressBar.animation.thumbnail!=s) ) {
                self.drawTip(progressFraction);
                self.progressBar.animation.thumbnail = s;
            }

        },

        hideTip: function() {
            this.tip.style.opacity = "0";
            this.seekBarPositionLine.style.display = "none";
            Utils.className(this.seekThumbHalo, '', 'p_showing');
            this.hideThumbnail();
        },

        drawTip: function(progressFraction) {

            var self = this;

            var latestAllowablePercent = self.player.timeHelper.getLatestAllowableSeekPercent();

            if (progressFraction > latestAllowablePercent) {
                progressFraction = latestAllowablePercent;
            }

            var controlsWidth = self.seekBarHolder.clientWidth;

            var position = Math.floor(self.seekBar.clientWidth * progressFraction);

            // tip is bound to the controlbar - there's 16px padding
            // between this and the seek bar that needs to be accounted for
            self.tip.firstChild.textContent = self.player.timeHelper.percentToTimeString(progressFraction,true);
            self.tip.style.opacity = 1;

            var tipWidth = Utils.getOffset(self.tip, 'width');
            var tipLeft = position - Math.floor(tipWidth/2) + getSeekBarPadding(self);

            // by default, place the triangle at the centre of the tooltip
            var tipTriangleLeft = Math.floor(tipWidth/2) - TIP_TRIANGLE_CENTRE;

            // if end of the tooltip is off the end of the control
            // bar, fix that, adjusting triangle too in full screen,
            // the control bar isn't the end of the stage, so don't
            // worry
            if (!self.player.isFullScreen) {
                if (tipLeft < 0) {
                    tipTriangleLeft += tipLeft;
                    tipLeft = 0;
                } else {
                    if (tipLeft + tipWidth > controlsWidth) {
                        tipTriangleLeft += (tipLeft + tipWidth) - controlsWidth;
                        tipLeft = controlsWidth - tipWidth;
                    }
                }
            }

            // actually set the positions
            self.tip.style.left = tipLeft + "px";
            self.tipTriangle.style.left = tipTriangleLeft + "px";

            // As per UX Requirements, draw line on seekbar, appears when tip is drawn;
            self.seekBarPositionLine.style.display = "block";
            self.seekBarPositionLine.style.left = position + "px";

            Utils.className(self.seekThumbHalo, 'p_showing');

            self.drawThumbnail(progressFraction);
        },

        drawThumbnail : function(percent) {

            var self = this;
            var width;
            var height;
            var player = self.player;

            if ( self.ui.config.thumbnail.enabled && player.thumbScrub.loaded ) {

                var controlsWidth = self.seekBarHolder.clientWidth;
                var videoWidth = self.ui.container.clientWidth; 
                var position = Math.floor(self.seekBar.clientWidth * percent);

                if (videoWidth < 400) {
                    self.hideThumbnail();
                    return;
                } else if (videoWidth < 800) {
                    width = 128;
                    height = 72;
                } else if (videoWidth < 1009) {
                    width = 192;
                    height = 108;
                } else {
                    width = 224;
                    height = 126;
                }

                var outerWidth = width + 2;

                var hasSmallScreen = ( videoWidth < (controlsWidth + outerWidth) );
                var thumbnailDivLeft = position - Math.floor(outerWidth/2) + getSeekBarPadding(self);

                var time = self.player.timeHelper.percentToTime(percent);
                var data = self.player.thumbScrub.getThumbnailData(time, width, height);
                if (!data) {
                    self.hideThumbnail();
                    return;
                }

                if ( !self.player.isFullScreen || hasSmallScreen )  {
                    thumbnailDivLeft = Utils.clamp(thumbnailDivLeft,0,controlsWidth - outerWidth);
                }

                var style = self.thumbnailDiv.style;
                var newdata = width+"x"+height+data.storyBoardUrl;
                if (newdata!=self.thumbnailData) {
                    self.thumbnailData = newdata;
                    style.width = width + "px";
                    style.height = height + "px";
                    style.backgroundImage = "url(" + data.storyBoardUrl + ")";
                }
                style.left = thumbnailDivLeft + "px";
                style.backgroundPosition = data.x + "px " + data.y + "px";
                style.visibility = "visible";
                style.opacity = 1;
            }
        },

        hideThumbnail : function() {
            this.thumbnailDiv.style.visibility = "hidden";
            this.thumbnailDiv.style.opacity = 0;
        },

        hide: function() {
            Utils.className(this.seekBarHolder, 'hidden');
            this.seekBarHolder.setAttribute('aria-hidden', 'true');
            this.seekThumb.disabled = true;
        },

        show: function() {
            Utils.className(this.seekBarHolder, '', 'hidden');
            this.seekBarHolder.setAttribute('aria-hidden', 'false');
            this.seekThumb.disabled = false;
        },

        isVisible: function() {
            return !Utils.hasClass(this.seekBarHolder,'hidden');
        },

        getEventCallbacks: function () {

            var self = this;

            function updateProgBar() {
                self.updateProgressBar(self.player.timeHelper.percent);
            }
            function seekdone() {
                animationClear(self);
                if (self.seekDone) {
                    self.seekDone();
                }
            }

            return {
                tryingToPlay:updateProgBar,

                play:updateProgBar,
                playing:updateProgBar,
                pause:updateProgBar,
                waiting:updateProgBar,
                error:updateProgBar,
                playlistEnded:updateProgBar,
                fixSize:updateProgBar,

                playerDisconnected:seekdone,
                playlistStopped:seekdone,
                ended:seekdone,

                mediaItemChanged: function() {
                    seekdone();
                    self.hideThumbnail();
                },

                seeked: function() {
                    if(!self.player.isSeeking ) {
                        animationClear(self);
                        self.updateProgressBar(self.player.timeHelper.percent, self.seekThumbHasFocus && !self.seekOver);
                    }
                },

                seeking: function() {
                    animationSetState(self,"paused");
                },

                showCta: function() {
                    animationClear(self);
                },

                playlistLoading: function() {
                    self.updateProgressBar(0);
                    if (self.seekDone) {
                        self.seekDone();
                    }
                },

                timeupdate: function() {
                    if(!self.player.isSeeking && self.ui.areControlsVisible()) {
                        self.updateProgressBar(self.player.timeHelper.percent, self.seekThumbHasFocus && !self.seekOver);
                    }

                },
                languageUpdated:function() {
                    if (self.seekHelpText) {
                        self.seekHelpText.textContent = Language.seekBarDescription;
                    }
                },
                uiConfigUpdated: function() {
                    applyConfigSettings(self);
                }

            };
        }

    };

    return progressBar;

})();
var BaseBuffer = (function() {

    var BUFFER_SHOW_DELAY = 750;

    function showBuffer(self) {
        clearTimeout(self.showBufferTimer);
        self.player.dispatch({type:"showBuffer"});
        self.visiblyShowBuffer();
        this.showing = true;
        if(!self.player.isSeeking) {
            ScreenReader.buffering();
        }
    }

    function resetCurrentStateForFullscreenChange(self) {
        if (self.ui.enabled) {
            if (self.showing) {
                self.startBufferTimer();
            } else {
                self.hideBuffer();
            }
        }
    }

    function BaseBuffer(ui) {

        this.ui = ui;
        this.player = ui.player;
        this.config = ui.config;
        this.showing = false;

    }

    BaseBuffer.prototype = {

        getEventCallbacks: function () {

            var self = this;

            return {
                ccConnect: function() {
                    self.startBufferTimer();
                },

                ccBuffering: function() {
                    self.startBufferTimer();
                },

                playingState: function() {
                    self.hideBuffer();
                },

                playing: function() {
                    self.hideBuffer();
                },

                tryingToPlay: function() {
                    self.startBufferTimer();
                },

                play: function() {
                    self.startBufferTimer();
                },

                pause: function() {
                    if(!self.player.Chromecast.isAttemptingToCast && !self.player.Chromecast.isConnecting) {
                        self.hideBuffer();
                    }
                },

                notPlayingState: function() {
                    self.hideBuffer();
                },

                losingControl: function() {
                    self.hideBuffer();
                },

                waiting : function() {
                    if(self.player.playingState=="playing") {
                        self.startBufferTimer();
                        self.player.qos.buffering();
                    }
                },

                seeking: function() {
                    self.startBufferTimer();
                },

                seeked: function() {
                    if (!self.player.Chromecast.isCasting) {
                        self.hideBuffer();
                    }
                },

                playlistStopped: function() {
                    self.hideBuffer();
                },

                playlistLoading: function() {
                    self.startBufferTimer();
                },
                fullscreenExit:function() {
                    resetCurrentStateForFullscreenChange(self);
                },
                playlistLoaded: function() {
                    if(self.player.autoPlayNextItem) {
                        self.startBufferTimer();
                    } else {
                        self.hideBuffer();
                    }
                }
            };
        },

        startBufferTimer: function() {

            if(this.config.buffer.enabled) {
                clearTimeout(this.showBufferTimer);
                this.showBufferTimer = setTimeout(showBuffer, BUFFER_SHOW_DELAY, this);
            }
        },

        hideBuffer: function(force) {

            clearTimeout(this.showBufferTimer);
            if(!this.config.buffer.forceShow || force) {
                this.visiblyHideBuffer();
                this.player.dispatch({type:"bufferHidden"});
                this.showing = false;
                ScreenReader.buffering(true);
            }
            this.player.qos.endBuffering();
        },

        updateConfig: function(config) {

            var previousForceShow = this.config.buffer.forceShow;
            this.config = config;
            this.applyConfig();

            if(this.config.buffer.forceShow != previousForceShow) {
                if (this.config.buffer.forceShow) {
                    this.startBufferTimer();
                } else {
                    this.hideBuffer();
                }
            }

            // if it was enabled and now is not
            if (!this.config.buffer.enabled) {
                this.hideBuffer(true);
            }

        },

        resizeFixEnd: function() {
            resetCurrentStateForFullscreenChange(this);
        },

        applyConfig: function() {

        }

    };

    return BaseBuffer;

})();var Spinner = (function() {

    function drawBufferSpinner(self) {

        var buffer = self.buffer = createElement('div','p_spinner');
        var canvas = document.createElement('canvas');
        buffer.spinner = new Sonic(canvas);
        buffer.appendChild(canvas);
        buffer.style.display = "none";
    }

    var spinner = function(ui) {

        BaseBuffer.call(this, ui);

        drawBufferSpinner(this);
        this.applyConfig();

    };

    spinner.prototype = Utils.object(BaseBuffer.prototype);

    spinner.prototype.getDomNodes = function() {
      return [this.buffer];
    };

    spinner.prototype.visiblyShowBuffer = function() {

        if(this.ui.enabled) {
            this.buffer.style.display = "block";
        }

    };

    spinner.prototype.visiblyHideBuffer = function() {

        this.buffer.style.display = "none";

    };

    spinner.prototype.applyConfig = function() {

        var self = this;

        var buffer = self.buffer;

        var spinner = buffer.spinner;
        spinner.width = self.config.buffer.width;
        spinner.colour = self.config.colour;
        spinner.thickness = self.config.buffer.thickness;
        spinner.colourArray = (self.config.buffer.colours ? (self.config.buffer.colours+'').split(',') : null);
        spinner.draw();

        var cnvs = buffer.style;
        var padding = buffer.spinner.padding;
        var w = (self.config.buffer.width+padding);
        cnvs.width = cnvs.height = w+"px";
        cnvs.marginTop = cnvs.marginLeft = -(w / 2) + "px";
        cnvs.top = self.config.buffer.top;
        cnvs.left = self.config.buffer.left;

    };

    return spinner;

})();

var AudioSpinner = (function() {

    function drawBufferSpinner(self) {

        var R = 33.5;
        var r = 30.5;
        var steps = 256;
        var dang = Math.PI*2/steps;
        var opacity = 1;
        var dopacity = opacity/(steps - 1);
        var prevpts = [[34, 34 - R], [34, 34 - r]];

        var curpts;
        var ang;
        var path;

        var group = Utils.createSVGElement('g', {});
        group.setAttribute('class', 'p_fadingRing');

        for (var i = 1; i <= steps; i++) {
            path = Utils.createSVGElement('path', {});
            ang = i * dang;
            curpts = [[34 - R * Math.sin(ang), 34 - R * Math.cos(ang)], [34 - r * Math.sin(ang), 34 - r * Math.cos(ang)]];
            path.setAttribute("d", "M " + prevpts[0] + " A " + R + " " + R + ", 0, 0, 1, " + curpts[0] + " L " + curpts[1] + " A " + r + " " + r + ", 0, 0, 0, " + prevpts[1]);
            path.setAttribute("fill", "rgba(255,255,255," + opacity + ")");
            prevpts = curpts;
            opacity -= dopacity;
            group.appendChild(path);
        }

        self.angle = 0;
        self.buffer = group;
        self.buffer.style.opacity = 0;

    }

    function animationStep(self) {

        var previousTimestamp;

        function step(timestamp) {
            if(!previousTimestamp) {
                previousTimestamp = timestamp;
            }

            var increment = (timestamp - previousTimestamp) / self.animationDuration * 360;
            self.angle = (self.angle + increment) % 360;

            self.buffer.setAttribute('transform', 'rotate(' + self.angle + ',34,34)');

            previousTimestamp = timestamp;

            self.animationID = requestAnimationFrame(step);

        }

        return step;

    }

    var AudioSpinner = function(ui) {

        BaseBuffer.call(this, ui);
        drawBufferSpinner(this);
        ui.player.pushMediaEventFunctions(this.getEventCallbacks());
        this.animationDuration = 1000;

    };

    AudioSpinner.prototype = Utils.object(BaseBuffer.prototype);

    AudioSpinner.prototype.getDomNodes = function() {
        return [this.buffer];
    };

    AudioSpinner.prototype.visiblyShowBuffer = function() {
        this.buffer.style.opacity = 1;

        if(this.animationID) {
            cancelAnimationFrame(this.animationID);
        }
        this.animationID = requestAnimationFrame(animationStep(this));

    };

    AudioSpinner.prototype.visiblyHideBuffer = function() {
        this.buffer.style.opacity = 0;

        if(this.animationID) {
            cancelAnimationFrame(this.animationID);
        }

    };

    AudioSpinner.prototype.applyConfig = function() {
    };

    return AudioSpinner;

})();var VolumeControl = (function() {

    /** Volume Constants **/
    var MAX_VOLUME = 11;
    var VOLUME_BAR_WIDTH = 9;
    var VOLUME_SLIDER_PADDING_LEFT = 6;
    var VOLUME_CONTROLS_WIDTH = 220;

    var defaultLabels = {includeVolume:true};

    function mouseClickOnVolumeButton(self) {
        return function(event) {
            self.player.muted = !self.player.muted;
            var action = self.player.mediaPlayer.muted ? 'mute' : 'unmute';
            self.player.trackAction(action, Utils.getActionType(event),defaultLabels);
        };
    }

    function getCloseVolumeControls(self) {
        return function() {
            self.closeVolumeControls();
        };
    }

    function getPointerOutVolume(self) {
        return function(event) {
            // a pointerout event is dispatched after a pointerup
            // event on devices where hover is not supported, so to
            // prevent the controls hiding immediately after a pointer
            // user lifts a finger, we need this check
            if (event.pointerType == 'mouse') {
                var x = event.clientX;
                var y = event.clientY;

                // pointerout event fired when pointer leaves child
                // divs so we add this check
                if (!self.volumeControls.contains(document.elementFromPoint(x,y))) {
                    self.closeVolumeControls();
                } else {
                    self.openVolumeControls(event);
                }
            }
        };
    }

    function getOpenVolumeControls(self, doNotDismiss) {
        return function(event) {
            self.openVolumeControls(event, doNotDismiss);
        };
    }

    function volumeFromPosition(self, event) {
        var xPos = (event.changedTouches ? event.changedTouches[0].clientX : event.clientX);
        var sliderWidth = VOLUME_BAR_WIDTH * MAX_VOLUME;
        var offset = Utils.getOffset(self.sliderContainer) + VOLUME_SLIDER_PADDING_LEFT;
        var value = Math.max(0, Math.min(xPos-offset, sliderWidth) / sliderWidth);

        // Each bar represents the halfway point between the previous volume and the displayed volume, hence if the user has
        // selected a volume < 0.5 they are to the left of the first volume bar and we assume this is a slide to mute action
        return (value < (0.5 / MAX_VOLUME) ? 0 : value);
    }

    function volumeControlsKeyDown(self) {
        return function(event) {
            var code = event.keyCode;
            var volumeChange;
            var volume = Math.round(self.player.mediaPlayer.volume * MAX_VOLUME);

            self.openVolumeControls(event, true);
            if (code == KEY_DOWN_ARROW || code == KEY_LEFT_ARROW) {
                if (volume > 1) {
                    if (self.player.mediaPlayer.muted) {
                        self.player.muted = false;
                    } else {
                        volume = Math.max(0, volume-1);
                        volumeChange = true;
                    }
                } else {
                    self.player.muted = true;
                }
                stopIt(event);
            }
            if (code == KEY_UP_ARROW || code == KEY_RIGHT_ARROW) {
                if (self.player.mediaPlayer.muted) {
                    self.player.muted = false;
                } else {
                    volume = Math.min(MAX_VOLUME, volume + 1);
                    volumeChange = true;
                }
                stopIt(event);
            }
            if (code == KEY_SPACE || code == KEY_ENTER) {
                self.player.muted = !self.player.muted;
                stopIt(event);
            }
            if (volumeChange) {
                self.player.volume = (volume / MAX_VOLUME);
            }
        };
    }

    function volumeControlsKeyUp(self) {
        return function(event) {
            var code = event.keyCode;
            if (code == KEY_DOWN_ARROW || code == KEY_LEFT_ARROW || code == KEY_UP_ARROW || code == KEY_RIGHT_ARROW || code == KEY_SPACE || code == KEY_ENTER) {
                clearTimeout(self.volumeTrackTimer);
                self.volumeTrackTimer = setTimeout(function() {
                    sendVolumeSliderStats(self.player, 'key_press');
                },STATS_TRACK_DELAY);
            }
        };
    }

    function sendVolumeSliderStats(player, actionType) {
        var type = player.muted ? "mute" : "volume_slider";
        player.trackAction(type, actionType, {'volume' :  player.volume,includeVolume:true});
    }

    function volumeOver(self) {
        return function(event) {
            var vol = volumeFromPosition(self, event);
            updateVolumeDisplay(self, vol);
        };
    }

    function moveEventOutsideElement(event,element) {
        var x, y;
        if (!element) {
            return false;
        }
        if (event.type == 'touchmove') {
            x = event.changedTouches[0].pageX;
            y = event.changedTouches[0].pageY;
        } else {
            x = event.pageX;
            y = event.pageY;
        }

        return !element.contains(document.elementFromPoint(x - window.pageXOffset,y - window.pageYOffset));
    }

    function volumePointerStart(self) {
        return function() {
            var doc = window.document;

            var removeListeners = function() {
                doc.removeEventListener('pointermove', volumeButtonMove);
                doc.removeEventListener('pointerup', volumeButtonUp);
            };

            var volumeButtonMove = function(event) {
                if (moveEventOutsideElement(event, self.volumeButton)) {
                    removeListeners();
                }
            };

            var volumeButtonUp = function (event) {
                removeListeners();
                self.volumeButton.focus();
                if (event.pointerType == 'mouse' || self.controlsOpenComplete) {
                    self.player.muted = !self.player.muted;
                    self.player.trackAction(self.player.mediaPlayer.muted ? 'mute' : 'unmute', 'click',defaultLabels);
                }
            };

            doc.addEventListener('pointermove', volumeButtonMove);
            doc.addEventListener('pointerup', volumeButtonUp);
        };
    }

    function volumeStart(self) {
        return function(event) {
            var doc = window.document;
            var sliderMove = false;

            function removeListeners() {
                if (volumeMove) {
                    doc.removeEventListener('mousemove', volumeMove);
                    doc.removeEventListener('touchmove', volumeMove);
                    doc.removeEventListener('pointermove', volumeMove);
                }
                if (volumeEnd) {
                    doc.removeEventListener('mouseup', volumeEnd);
                    doc.removeEventListener('touchend', volumeEnd);
                    doc.removeEventListener('pointerup', volumeEnd);
                }
            }

            function volumeMove(event) {
                clearTimeout(self.volumeControlsTimer);
                sliderMove = true;

                self.player.volume = volumeFromPosition(self, event);

                if (moveEventOutsideElement(event, self.volumeControls)) {
                    removeListeners();
                    self.volumeControlsTimer = setTimeout(getCloseVolumeControls(self), 100);
                }
            }

            function volumeEnd(event) {
                self.player.volume = volumeFromPosition(self, event);
                if (DEBUG_FULL) {
                    console.log( "volumeEnd:"+volumeFromPosition(self, event) );
                }
                sendVolumeSliderStats(self.player,(sliderMove ? 'drag' : 'click'));

                removeListeners();
                clearTimeout(self.volumeControlsTimer);
                self.volumeControlsTimer = setTimeout(getCloseVolumeControls(self), self.ui.config.controls.volumeDismissTime);
            }

            if (event.type == 'mousedown') {
                doc.addEventListener('mousemove', volumeMove);
                doc.addEventListener('mouseup', volumeEnd);
            } else if (event.type == 'pointerdown') {
                doc.addEventListener('pointermove', volumeMove);
                doc.addEventListener('pointerup', volumeEnd);
            } else if (event.type == 'touchstart') {
                doc.addEventListener('touchmove', volumeMove);
                doc.addEventListener('touchend', volumeEnd);
            }

            self.player.volume = volumeFromPosition(self, event);
        };
    }

    function getToggleMute(player) {
        return Utils.getActionFn(function(actionType) {
            player.muted = !player.muted;
            var action = player.mediaPlayer.muted ? 'mute' : 'unmute';
            player.trackAction(action, actionType,defaultLabels);
        });
    }

    function getControlsOpenComplete(self) {
        return function() {
            self.controlsOpenComplete = self.volumeControlsOpen;
        };
    }

    function createDomNodes(self) {

        self.volumeControls = createElement('div','p_closed p_volumeControls');
        self.volumeControls.addEventListener('transitionend', getControlsOpenComplete(self));

        //self.volumeButton = getButton("p_volumeButton",getToggleMute(ui),Language.toolTipMute,Language.toolTipMute,ui,false,'audio');

        var button = createElement('button','p_button','<span class="p_hiddenElement" aria-hidden="true"></span>',Language.toolTipMute);

        button.addEventListener("mouseover", function() {
            Utils.className(button,"p_buttonHover");
        });
        button.addEventListener("mouseout", function() {
            Utils.className(button,"","p_buttonHover");
        });
        // Disable background color transition on touch
        button.addEventListener("touchstart", function() {
            Utils.className(button,"p_buttonHover p_buttonTouch");
        },{passive:true} );
        button.addEventListener("touchend", function() {
            Utils.className(button,"","p_buttonHover p_buttonTouch");
        });

        if(self.ui.config.controls.muteButtonOnly) {
            Utils.multiAddEventListener(button, "touchend click mouseup", getToggleMute(self.player));
        }

        button.setAttribute("role","button");
        button.setAttribute('aria-live','polite');
        button.setAttribute('aria-label', Language.toolTipMute);
        button.className = 'p_button p_controlBarButton p_volumeButton';
        button.title = Language.toolTipMute;

        button.addEventListener("focusin", self.ui.showControlBar);

        if(self.ui.config.useHighResIcons) {
            updateExistingSvg(button, 'audio');
        }

        var hiddenElement = button.getElementsByClassName('p_hiddenElement')[0];
        if (hiddenElement) {
            // XXX are we sure innerHTML is safe/needed here?
            hiddenElement.innerHTML = Language.toolTipMute;
        }

        self.volumeButton = button;


        if(!self.ui.config.controls.muteButtonOnly) {

            Utils.multiAddEventListener(self.volumeButton,'focus focusin', getOpenVolumeControls(self,true));
            self.volumeButton.addEventListener('blur', getCloseVolumeControls(self));
            self.volumeButton.addEventListener('keydown', volumeControlsKeyDown(self));
            self.volumeButton.addEventListener('keyup', volumeControlsKeyUp(self));

            self.volumeButton.addEventListener('click', function(event) {
                // if the user hasn't tabbed to give the
                // button focus, we want to set an
                // inactivity timeout
                if (!Utils.isKeyboardClick(event)) {
                    clearTimeout(self.volumeControlsTimer);
                    self.volumeControlsTimer = setTimeout(getCloseVolumeControls(self), self.ui.config.controls.volumeDismissTime);
                }
            });

            // preventDefault on pointerdown/pointerup
            // does not prevent click events so as a
            // workaround, if pointer events are
            // supported, we simulate clicks with a
            // pointerdown/up action. Will come back to
            // this later and come up with a more unified
            // solution that works for all event types
            if (window.PointerEvent) {
                self.volumeButton.addEventListener('pointerdown', volumePointerStart(self));
                self.volumeControls.addEventListener('pointerout', getPointerOutVolume(self));
            } else {
                // prevent default on show volume controls
                // will prevent a click event being fired
                // on touch
                self.volumeButton.addEventListener('click', mouseClickOnVolumeButton(self));
                self.volumeControls.addEventListener('mouseout', getCloseVolumeControls(self));
                self.volumeButton.addEventListener('touchstart', getOpenVolumeControls(self));
            }

            self.volumeControls.addEventListener('mousemove', getOpenVolumeControls(self, true));

            self.sliderContainer = createElement('div','p_sliderContainer');
            self.sliderContainer.tabIndex = '-1';
            self.volumeControls.appendChild(self.sliderContainer);

            // XXX inline function??
            //
            // add listener for both focusin and focus so
            // this works on browsers that only support
            // one of these events
            Utils.multiAddEventListener(self.sliderContainer,'focus focusin',function () {
                self.volumeButton.focus();
            });


            self.sliderContainer.addEventListener('mouseover', volumeOver(self));
            var volStart = volumeStart(self);
            if (window.PointerEvent) {
                self.sliderContainer.addEventListener('pointerdown', volStart);
            } else {
                Utils.multiAddEventListener(self.sliderContainer,"mousedown touchstart", volStart);
            }

            self.sliderControls = createElement('div','p_sliderControls');
            self.sliderContainer.appendChild(self.sliderControls);

            for (var index = 0; index < MAX_VOLUME; index++) {
                var volumeDivHolder = createElement('div', 'p_volumeBarHolder');
                var volumeDiv = createElement('div','p_volumeBar');
                volumeDivHolder.style.left = (VOLUME_SLIDER_PADDING_LEFT) + (index * VOLUME_BAR_WIDTH) + Math.ceil(VOLUME_BAR_WIDTH / 2) + 'px';
                volumeDivHolder.appendChild(volumeDiv);
                self.sliderControls.appendChild(volumeDivHolder);
            }
            self.volumeLevelIndicator = createElement('div','p_volumeLevel');
            self.volumeLevelIndicator.setAttribute("aria-hidden", "true");
            self.sliderControls.appendChild(self.volumeLevelIndicator);

            var helpText = document.createElement('div');
            helpText.id = 'p_volumeHelpText';
            // XXX are we sure innerHTML is safe/needed here?
            helpText.innerHTML = Language.volumeControlDescription;
            helpText.style.display = 'none';
            self.sliderContainer.appendChild(helpText);
            self.volumeButton.setAttribute('aria-describedby', helpText.id);
            self.volumeButton.setAttribute("aria-valuemin","0");
            self.volumeButton.setAttribute("aria-valuemax", MAX_VOLUME);
            self.volumeButton.setAttribute('role','slider');
            updateVolumeDisplay(self);
        }
        updateMuteButton(self);
        self.volumeControls.appendChild(self.volumeButton);

    }

    function updateVolumeDisplay(self, vol) {

        if(self.sliderContainer) {
            if (typeof vol !== 'undefined') {
                vol = Math.min(MAX_VOLUME, Math.ceil(MAX_VOLUME * vol));
            } else {
                vol = self.player.muted ? 0 : Math.ceil(self.player.volume * MAX_VOLUME);
            }

            var sliderDivs = self.sliderControls.childNodes;
            if (vol>sliderDivs.length-1) {
                vol = sliderDivs.length-1;
            }
            for (var i=sliderDivs.length-2;i>=vol;i--) {
                sliderDivs[i].childNodes[0].className = "p_volumeBar p_afterVolume";
            }
            if (i>=0) {
                sliderDivs[i].childNodes[0].className = "p_volumeBar p_selectedVolume";
            }
            for (--i;i>=0;i--) {
                sliderDivs[i].childNodes[0].className = "p_volumeBar p_beforeVolume";
            }

            self.volumeLevelIndicator.textContent = vol;
            if (vol > 0) {
                self.volumeButton.setAttribute("aria-valuetext", Language.get("audioToolTipVolume"+vol));
            } else {
                self.volumeButton.setAttribute("aria-valuetext", Language.get("audioToolTipVolumeMuted"));
            }
            self.volumeButton.setAttribute("aria-valuenow", vol);
        }
    }

    function applyConfigSettings(self) {

        Utils.deleteCssRules(self.ui.stylesheet, [".audioUI.nonPointerFocus.svg .p_volumeButton:focus .p_svg, .audioUI.svg .p_volumeButton.p_buttonHover .p_svg, .audioUI.svg .p_volumeControls.p_open .p_svg", "p_beforeVolume", ".p_sliderControls:hover .p_selectedVolume", "p_sliderContainer"]);
        self.ui.stylesheet.insertRule(".audioUI.nonPointerFocus.svg .p_volumeButton:focus .p_svg, .audioUI.svg .p_volumeButton.p_buttonHover .p_svg, .audioUI.svg .p_volumeControls.p_open .p_svg { fill: " + self.ui.config.colour + ";}", self.ui.stylesheet.cssRules.length);
        self.ui.stylesheet.insertRule(".p_beforeVolume { background-color: " + self.ui.config.colour + " !important; }", 0);
        self.ui.stylesheet.insertRule(".p_sliderControls:hover .p_selectedVolume { background-color: " + self.ui.config.foreColour + " !important; }", 0);
        self.ui.stylesheet.insertRule(".p_sliderContainer { display: "+Utils.noneOrBlock(!self.ui.config.controls.muteButtonOnly)+"; }",0);
        //self.ui.stylesheet.insertRule(".p_volumeControls { display: "+Utils.noneOrBlock(self.ui.config.controls.volumeSlider)+"; }",0);

        if(self.ui.config.controls.volumeSlider) {
            self.restore();
        } else {
            self.remove();
        }

    }

    function updateMuteButton(self) {

        var muted = self.player.muted;
        var className = muted ? "p_volumeButton mute" : "p_volumeButton audio";
        var title = muted ? Language.toolTipUnmute : Language.toolTipMute;
        var icon = muted ? "mute" : "audio";

        if (Utils.hasClass(self.volumeButton, "p_buttonHover")) {
            className = className + " p_buttonHover";
        }

        if (Utils.hasClass(self.volumeButton, "p_buttonTouch")) {
            className = className + " p_buttonTouch";
        }

        self.volumeButton.setAttribute('aria-label', title);
        self.volumeButton.className = 'p_button p_controlBarButton ' + className;
        self.volumeButton.title = title;
        if(self.ui.config.useHighResIcons) {
            updateExistingSvg(self.volumeButton,icon);
        }
        var hiddenElement = self.volumeButton.getElementsByClassName('p_hiddenElement')[0];
        if (hiddenElement) {
            // XXX are we sure innerHTML is safe/needed here?
            hiddenElement.innerHTML = title;
        }

    }


    var VolumeControl = function(ui) {

        this.ui = ui;

        if(ui.type == 'audio') {
            VOLUME_SLIDER_PADDING_LEFT = 0;
        }

        this.player = ui.player;
        this.volumeControlsTimer =- 1;
        this.volumeTrackTimer =- 1;
        this.volumeControlsOpen = false;
        createDomNodes(this);
        applyConfigSettings(this);
    };

    VolumeControl.prototype = {

        show: function() {
            Utils.className(this.volumeControls, '', 'hidden');

            if(!Utils.hasClass(this.volumeControls, 'removed')) {
                this.volumeControls.setAttribute('aria-hidden', 'false');
                this.volumeButton.disabled = false;
            }
        },

        hide: function() {
            Utils.className(this.volumeControls, 'hidden');
            this.volumeControls.setAttribute('aria-hidden', 'true');
            this.volumeButton.disabled = true;
        },

        remove: function() {
            Utils.className(this.volumeControls, 'removed');
            this.volumeControls.setAttribute('aria-hidden', 'true');
            this.volumeButton.disabled = true;
        },

        restore: function() {

            Utils.className(this.volumeControls, '', 'removed');

            if(!Utils.hasClass(this.volumeControls, 'hidden')) {
                this.volumeControls.setAttribute('aria-hidden', 'false');
                this.volumeButton.disabled = false;
            }

        },

        getDomNodes: function() {
            return [this.volumeControls];
        },

        openVolumeControls: function(event, doNotDismiss) {
            clearTimeout(this.volumeControlsTimer);
            if(!this.volumeControlsOpen) {
                this.player.dispatch({type:"volumeOpening"});
                this.volumeControlsOpen = true;
                Utils.className(this.volumeControls, 'p_open', 'p_closed');
            } else {
                if (event.type == 'touchstart') {
                    // touch event with controls already open, so mute
                    // toggle requested
                    this.player.muted = !this.player.muted;
                }
            }

            if (!doNotDismiss) {
                this.volumeControlsTimer = setTimeout(getCloseVolumeControls(this), this.ui.config.controls.volumeDismissTime);
            }
        },

        closeVolumeControls: function() {
            clearTimeout(this.volumeControlsTimer);
            if (this.volumeControlsOpen) {
                this.volumeControlsOpen = false;
                this.controlsOpenComplete = false;

                Utils.className(this.volumeControls, 'p_closed', 'p_open');

                updateVolumeDisplay(this);

                this.player.dispatch({type:"volumeClosed"});
            }
        },

        getRight: function() {
            return Utils.getOffset(this.volumeControls) + VOLUME_CONTROLS_WIDTH;
        },

        isOpen: function() {
            return this.volumeControlsOpen;
        },


        getEventCallbacks: function () {
            var self = this;
            return {
                volumechange : function() {
                    if (DEBUG_FULL) {  console.log("volumeChange"); }
                    updateVolumeDisplay(self);
                    updateMuteButton(self);

                },
                languageUpdated: function() {
                    updateMuteButton(self);
                },
                uiConfigUpdated: function() {
                    applyConfigSettings(self);
                }
            };
        }
    };

    return VolumeControl;


})();
var AudioButton = (function() {

    function hovering() {

        if(!Device.ios) { // iOS Bug Fix - Touch edge of element, element gets mouse but not touch events
            Utils.className(this.button, 'hovering');
        }

    }

    function removeHovering() {

        Utils.className(this.button, '', 'hovering');

    }

    function pressed() {

        Utils.className(this.button, 'pressed');

    }

    function released() {

        Utils.className(this.button, '', 'pressed');

    }

    function createButton(self) {

        var button = self.button = document.createElement('button');

        var buttonInner = self.buttonInner = document.createElement('div');
        buttonInner.className = 'p_audioButton_buttonInner';

        button.appendChild(buttonInner);

        var boundPressed = pressed.bind(self);
        var boundReleased = released.bind(self);

        button.className = 'audioButton';

        Utils.hoverMoveAction(button, hovering.bind(self));
        Utils.hoverLeaveAction(button, removeHovering.bind(self));
        Utils.downAction(button, boundPressed);
        //Utils.upAction(button, boundReleased);

        Utils.upAction(document, boundReleased, true);

        Utils.multiAddEventListener(button, 'focus focusin', Utils.getActionFn(function() {
            Utils.className(button, 'focused');
        }));

        Utils.multiAddEventListener(button, 'blur focusout', Utils.getActionFn(function() {
            Utils.className(button, '', 'focused');
        }));

        button.addEventListener('keydown', function(e) {

            if(e.keyCode == KEY_ENTER || e.keyCode == KEY_SPACE) {
                boundPressed();
            }

        });

        button.addEventListener('keyup', function() {

            boundReleased();

        });

    }

    function AudioButton() {
        createButton(this);
    }

    AudioButton.prototype = {

        getDomNodes: function() {
            return this.button;
        },

        show: function() {
            Utils.className(this.button, '', 'hidden');
            if(!Utils.hasClass(this.button, 'removed')) {

                this.button.setAttribute('aria-hidden', 'false');

                if(!Utils.hasClass(this.button, 'disabled')) {
                    this.button.disabled = false;
                }
            }
        },

        hide: function() {
            Utils.className(this.button, 'hidden');
            this.button.setAttribute('aria-hidden', 'true');
            this.button.disabled = true;

            released.bind(this)();
            removeHovering.bind(this)();
        },

        remove: function() {
            Utils.className(this.button, 'removed');
            this.button.setAttribute('aria-hidden', 'true');
            this.button.disabled = true;

            released.bind(this)();
            removeHovering.bind(this)();
        },

        restore: function() {
            Utils.className(this.button, '', 'removed');

            if(!Utils.hasClass(this.button, 'hidden')) {
                this.button.setAttribute('aria-hidden', 'false');

                if(!Utils.hasClass(this.button, 'disabled')) {
                    this.button.disabled = false;
                }
            }

        },

        setActionFunction: function(f) {
            Utils.multiAddEventListener(this.button, 'mouseup touchend click', Utils.getActionFn(f, false, true));
        },

        disable: function() {
            Utils.className(this.button, 'disabled');
            this.button.disabled = true;

            released.bind(this)();
            removeHovering.bind(this)();
        },

        enable: function() {
            Utils.className(this.button, '', 'disabled');
            // XXX Why can't a button be disabled and hidden, then we
            // could not update the class unless disabled had changed?
            // A hidden or removed button is always disabled
            if(!Utils.hasClass(this.button, 'hidden') && !Utils.hasClass(this.button, 'removed')) {
                this.button.disabled = false;
            }
        }

    };

    return AudioButton;

})();var AudioPlayButton = (function() {

    function configureButton(self) {

        self.button.id = 'p_audioui_playpause';
        self.button.setAttribute('aria-label', Language.toolTipPlay);

        var svg = Utils.createSVGElement('svg', {
            width: 68,
            height: 68,
            viewbox: "0 0 68 68"
        });

        var surroundingCircle = self.surroundingCircle = Utils.createSVGElement('circle', {
            id: "p_audioui_playpause_circle",
            cx: 34,
            cy: 34,
            r: 32
        });

        var highlightCircle = self.highlightCircle = Utils.createSVGElement('circle', {
            id: "p_audioui_playpause_highlightCircle",
            cx: 34,
            cy: 34,
            r: 34
        });

        var playIcon = self.playIcon = Utils.createSVGElement('polygon', {
            id: "p_audioui_playpause_playIcon",
            points: "27 46 46 34 27 22"
        });

        var pauseIcon = self.pauseIcon = Utils.createSVGElement('g', {
            id: "p_audioui_playpause_pauseIcon"
        });

        var pauseBar = Utils.createSVGElement('rect', {
            x: 26,
            y: 24,
            width: 6,
            height: 20
        });

        var pauseBar2 = Utils.createSVGElement('rect', {
            x: 36,
            y: 24,
            width: 6,
            height: 20
        });

        pauseIcon.appendChild(pauseBar);
        pauseIcon.appendChild(pauseBar2);

        svg.appendChild(surroundingCircle);
        svg.appendChild(highlightCircle);
        svg.appendChild(self.spinner.getDomNodes()[0]);
        svg.appendChild(playIcon);
        svg.appendChild(pauseIcon);



        self.buttonInner.appendChild(svg);

    }

    function applyConfigSettings(self) {
        Utils.deleteCssRules(self.ui.stylesheet, ["#p_audioui_playpause_highlightCircle"]);

        self.ui.stylesheet.insertRule("#p_audioui_playpause_highlightCircle { fill: " + self.ui.config.colour + "; }", self.ui.stylesheet.cssRules.length);
    }

    function AudioPlayButton(ui) {

        this.ui = ui;
        this.state = 'play';
        AudioButton.call(this);

        this.spinner = new AudioSpinner(ui);

        configureButton(this);
        applyConfigSettings(this);
    }

    AudioPlayButton.prototype = Utils.object(AudioButton.prototype);

    AudioPlayButton.prototype.getEventCallbacks = function () {

        var self = this;

        return {

            notPlayingState: function() {
                self.state = 'play';
                self.playIcon.style.opacity = 1;
                self.pauseIcon.style.opacity = 0;
                self.button.setAttribute('aria-label', Language.toolTipPlay);
            },

            playingState: function() {
                self.state = 'pause';
                self.playIcon.style.opacity = 0;
                self.pauseIcon.style.opacity = 1;
                self.button.setAttribute('aria-label', Language.toolTipPause);
            },

            uiConfigUpdated: function() {
                applyConfigSettings(self);
            },

            showBuffer: function() {
                self.surroundingCircle.style.opacity = 0;
            },

            bufferHidden: function() {
                self.surroundingCircle.style.opacity = 1;
            },

            languageUpdated: function() {
                if(self.state == 'play') {
                    self.button.setAttribute('aria-label', Language.toolTipPlay);
                } else {
                    self.button.setAttribute('aria-label', Language.toolTipPause);
                }
            }

        };
    };

    return AudioPlayButton;

})();var BackIntervalButton = (function() {

    function setAriaLabel(self) {
        self.button.setAttribute('aria-label', Language.skipBack.replace('{seconds}', self.ui.player.config.skipInterval));
    }

    function configureButton(self) {
        self.button.id = 'p_audioui_backInterval';
        Utils.className(self.button, 'p_audioui_intervalButton');
        setAriaLabel(self);

        var svg = Utils.createSVGElement('svg', {
            width: 48,
            height: 48,
            viewbox: '0 0 48 48'
        });

        var backArrow = Utils.createSVGElement('path', {
            id: 'p_audioui_backInterval_backArrow',
            'class': 'p_audioui_intervalArrow',
            d: 'M23.9785895,8.59327393 C23.926122,8.59327393 23.8224363,8.59327393 23.8224363,8.59327393 L22.3845769,8.5920247 L25.6962756,5.28657205 L23.9298697,3.52391381 L17.3039737,10.1348191 L23.9298697,16.7457244 L25.6962756,14.9830662 L22.4158075,11.7088442 L23.8224363,11.7113426 C23.8224363,11.7113426 23.926122,11.7100934 23.9785895,11.7100934 C31.9124254,11.7100934 38.3446914,18.1286179 38.3446914,26.0462138 C38.3446914,33.9638098 31.9124254,40.3823343 23.9785895,40.3823343 C16.0435044,40.3823343 9.61248769,33.9638098 9.61248769,26.0462138 C9.61248769,26.0299739 9.61498614,26.0149832 9.61498614,25.9987433 L6.49192052,25.9987433 C6.49192052,26.0149832 6.48942206,26.0299739 6.48942206,26.0462138 C6.48942206,35.6852436 14.3195722,43.4991538 23.9785895,43.4991538 C33.6376069,43.4991538 41.467757,35.6852436 41.467757,26.0462138 C41.467757,16.4071841 33.6376069,8.59327393 23.9785895,8.59327393'
        });

        var numberholder = document.createElement('div');
        numberholder.className = 'p_audioui_intervalNumber';

        var sign = document.createElement('span');
        sign.className = 'p_audioui_intervalNumber_sign';
        sign.textContent = '-';

        var intervalNumber = self.intervalNumber = document.createElement('span');
        intervalNumber.className = 'p_audioui_intervalNumber_number';
        intervalNumber.textContent = self.ui.player.config.skipInterval;

        numberholder.appendChild(sign);
        numberholder.appendChild(intervalNumber);

        svg.appendChild(backArrow);
        self.buttonInner.appendChild(svg);
        self.buttonInner.appendChild(numberholder);
    }

    function applyConfigSettings(self) {

        Utils.deleteCssRules(self.ui.stylesheet, ["#p_audioui_backInterval:not([disabled]).hovering, #p_audioui_backInterval:not([disabled]).pressed, .nonPointerFocus #p_audioui_backInterval:not([disabled]).focused"]);

        self.ui.stylesheet.insertRule("#p_audioui_backInterval:not([disabled]).hovering, #p_audioui_backInterval:not([disabled]).pressed, .nonPointerFocus #p_audioui_backInterval:not([disabled]).focused { color: " + self.ui.config.colour + "; fill: " + self.ui.config.colour + "; }", self.ui.stylesheet.cssRules.length);

    }

    function checkEnabled(self, e) {
        if((e._.timeHelper.time <= e._.timeHelper.earliestSeek) && (e._.playingState != 'playing')) {
            self.disable();
        } else {
            self.enable();
        }
    }

    function BackIntervalButton(ui) {

        this.ui = ui;
        AudioButton.call(this);
        configureButton(this);
        applyConfigSettings(this);
    }

    BackIntervalButton.prototype = Utils.object(AudioButton.prototype);

    BackIntervalButton.prototype.getEventCallbacks = function () {

        var self = this;

        return {

            uiConfigUpdated: function() {
                applyConfigSettings(self);
            },

            seeked: function(e) {
                checkEnabled(self,e);
            },

            timeupdate: function(e) {
                checkEnabled(self,e);
            },

            playing: function(e) {
                checkEnabled(self, e);
            },

            languageUpdated: function() {
                setAriaLabel(self);
            },

            configUpdated: function() {
                setAriaLabel(self);
                self.intervalNumber.textContent = self.ui.player.config.skipInterval;
            }

        };
    };

    return BackIntervalButton;

})();var ForwardIntervalButton = (function() {

    function setAriaLabel(self) {
        self.button.setAttribute('aria-label', Language.skipForward.replace('{seconds}', self.ui.player.config.skipInterval));
    }

    function configureButton(self) {
        self.button.id = 'p_audioui_forwardInterval';
        Utils.className(self.button, 'p_audioui_intervalButton');
        setAriaLabel(self);

        var svg = Utils.createSVGElement('svg', {
            width: 48,
            height: 48,
            viewbox: '0 0 48 48'
        });

        var forwardArrow = Utils.createSVGElement('path', {
            id: 'p_audioui_forwardInterval_forwardArrow',
            'class': 'p_audioui_intervalArrow',
            d: 'M23.9911839,8.58201848 C24.043535,8.58201848 24.1469905,8.58201848 24.1469905,8.58201848 L25.5816575,8.58077203 L22.2773116,5.28265844 L24.0397956,3.52391381 L30.6509802,10.120141 L28.8872498,11.8801321 L24.0397956,16.7176146 L22.2773116,14.9576235 L25.5504962,11.6919177 L24.1469905,11.6931642 C24.1469905,11.6931642 24.043535,11.6919177 23.9911839,11.6919177 C16.0749635,11.6919177 9.656979,18.0961912 9.656979,25.9962078 C9.656979,33.8962244 16.073717,40.3004979 23.9911839,40.3004979 C31.9074044,40.3004979 38.3253889,33.8962244 38.3253889,25.9962078 C38.3253889,25.9800039 38.322896,25.9650465 38.322896,25.9488426 L41.4390275,25.9488426 C41.4390275,25.9650465 41.4415204,25.9800039 41.4415204,25.9962078 C41.4415204,35.6138361 33.6287555,43.4103971 23.9911839,43.4103971 C14.3536124,43.4103971 6.54084749,35.6138361 6.54084749,25.9962078 C6.54084749,16.3785795 14.3536124,8.58201848 23.9911839,8.58201848'
        });

        var numberholder = document.createElement('div');
        numberholder.className = 'p_audioui_intervalNumber';

        var sign = document.createElement('span');
        sign.className = 'p_audioui_intervalNumber_sign';
        sign.textContent = '+';

        var intervalNumber = self.intervalNumber = document.createElement('span');
        intervalNumber.className = 'p_audioui_intervalNumber_number';
        intervalNumber.textContent = self.ui.player.config.skipInterval;

        numberholder.appendChild(sign);
        numberholder.appendChild(intervalNumber);

        svg.appendChild(forwardArrow);
        self.buttonInner.appendChild(svg);
        self.buttonInner.appendChild(numberholder);
    }

    function applyConfigSettings(self) {

        Utils.deleteCssRules(self.ui.stylesheet, ["#p_audioui_forwardInterval:not([disabled]).hovering, #p_audioui_forwardInterval:not([disabled]).pressed, .nonPointerFocus #p_audioui_forwardInterval:not([disabled]).focused"]);

        self.ui.stylesheet.insertRule("#p_audioui_forwardInterval:not([disabled]).hovering, #p_audioui_forwardInterval:not([disabled]).pressed, .nonPointerFocus #p_audioui_forwardInterval:not([disabled]).focused { color: " + self.ui.config.colour + "; fill: " + self.ui.config.colour + "; }", self.ui.stylesheet.cssRules.length);

    }

    function checkEnabled(self, e) {

        if(e._.timeHelper.time - e._.timeHelper.latestSeek > -0.002) {
            self.disable();
        } else {
            self.enable();
        }

    }

    function ForwardIntervalButton(ui) {

        this.ui = ui;
        AudioButton.call(this);
        configureButton(this);
        applyConfigSettings(this);
    }

    ForwardIntervalButton.prototype = Utils.object(AudioButton.prototype);

    ForwardIntervalButton.prototype.getEventCallbacks = function () {

        var self = this;

        return {

            uiConfigUpdated: function() {
                applyConfigSettings(self);
            },

            seeked: function(e) {
                checkEnabled(self,e);
            },

            timeupdate: function(e) {
                checkEnabled(self,e);
            },

            playing: function(e) {
                checkEnabled(self,e);
            },

            languageUpdated: function() {
                setAriaLabel(self);
            },

            configUpdated: function() {
                setAriaLabel(self);
                self.intervalNumber.textContent = self.ui.player.config.skipInterval;
            }

        };
    };

    return ForwardIntervalButton;

})();var PreviousButton = (function() {

    function configureButton(self) {
        self.button.id = 'p_audioui_previousButton';
        Utils.className(self.button, 'p_audioui_playlistButton');
        self.button.setAttribute('aria-label', Language.previousItem);

        var svg = Utils.createSVGElement('svg', {
            width: 48,
            height: 48,
            viewbox: '0 0 48 48'
        });

        var chevron = Utils.createSVGElement('path', {
            id: 'p_audioui_previousButton_chevron',
            'class': 'p_audioui_playlistChevron',
            d: 'M16.9954676,31.996911 L16.9954676,16.0004999 L18.495178,16.0004999 L18.495178,31.996911 L16.9954676,31.996911 Z M18.495178,23.9984555 L30.9927648,16 L30.9927648,20.0792123 L24.3585458,23.9984555 L30.9927648,27.9181986 L30.9927648,31.996911 L18.495178,23.9984555 Z'
        });

        svg.appendChild(chevron);
        self.buttonInner.appendChild(svg);
    }

    function applyConfigSettings(self) {

        Utils.deleteCssRules(self.ui.stylesheet, ["#p_audioui_previousButton:not([disabled]).hovering, #p_audioui_previousButton:not([disabled]).pressed, .nonPointerFocus #p_audioui_previousButton:not([disabled]).focused"]);

        self.ui.stylesheet.insertRule("#p_audioui_previousButton:not([disabled]).hovering, #p_audioui_previousButton:not([disabled]).pressed, .nonPointerFocus #p_audioui_previousButton:not([disabled]).focused { fill: " + self.ui.config.colour + "; }", self.ui.stylesheet.cssRules.length);

    }

    function removeOrRestore(self, e) {

        if(e._.mediaItem && !e._.mediaItem.live && e._.ui.config.controls.includePreviousButton) {
            self.restore();
        } else {
            self.remove();
        }

    }

    function PreviousButton(ui) {

        this.ui = ui;
        AudioButton.call(this);
        configureButton(this);
        applyConfigSettings(this);
    }

    PreviousButton.prototype = Utils.object(AudioButton.prototype);

    PreviousButton.prototype.getEventCallbacks = function () {

        var self = this;

        return {

            uiConfigUpdated: function(e) {
                applyConfigSettings(self);
                removeOrRestore(self, e);
            },

            mediaItemChanged: function(e) {
                removeOrRestore(self, e);
            },

            languageUpdated: function() {
                self.button.setAttribute('aria-label', Language.previousItem);
            },

            seeked: function() {
                // if(e._.timeHelper.time === 0 && !e._.hasPrevious) {
                //     self.disable();
                // }
            },

            playing: function() {
                //self.enable();
            },

            timeupdate: function(e) {
                if((e._.timeHelper.time > 5) || e._.hasPrevious) {
                    self.enable();
                } else {
                    self.disable();
                }
            }

        };
    };

    return PreviousButton;

})();var NextButton = (function() {

    function configureButton(self) {
        self.button.id = 'p_audioui_nextButton';
        Utils.className(self.button, 'p_audioui_playlistButton');
        self.button.setAttribute('aria-label', Language.nextItem);

        var svg = Utils.createSVGElement('svg', {
            width: 48,
            height: 48,
            viewbox: '0 0 48 48'
        });

        var chevron = Utils.createSVGElement('path', {
            id: 'p_audioui_nextButton_chevron',
            'class': 'p_audioui_playlistChevron',
            d: 'M29.5034828,32 L29.5034828,16 L31.0034828,16 L31.0034828,32 L29.5034828,32 Z M17.0034828,20.0803 L17.0034828,16.0003 L29.5034828,23.9998 L17.0034828,31.9998 L17.0034828,27.9203 L23.6399828,23.9998 L17.0034828,20.0803 Z'
        });

        svg.appendChild(chevron);
        self.buttonInner.appendChild(svg);
    }

    function applyConfigSettings(self) {

        Utils.deleteCssRules(self.ui.stylesheet, ["#p_audioui_nextButton:not([disabled]).hovering, #p_audioui_nextButton:not([disabled]).pressed, .nonPointerFocus #p_audioui_nextButton:not([disabled]).focused"]);

        self.ui.stylesheet.insertRule("#p_audioui_nextButton:not([disabled]).hovering, #p_audioui_nextButton:not([disabled]).pressed, .nonPointerFocus #p_audioui_nextButton:not([disabled]).focused { fill: " + self.ui.config.colour + "; }", self.ui.stylesheet.cssRules.length);

    }

    function removeOrRestore(self, e) {

        if(e._.mediaItem && !e._.mediaItem.live && e._.ui.config.controls.includeNextButton) {
            self.restore();
        } else {
            self.remove();
        }

    }

    function NextButton(ui) {

        this.ui = ui;
        AudioButton.call(this);
        configureButton(this);
        applyConfigSettings(this);
    }

    NextButton.prototype = Utils.object(AudioButton.prototype);

    NextButton.prototype.getEventCallbacks = function () {

        var self = this;

        return {

            uiConfigUpdated: function(e) {
                applyConfigSettings(self);
                removeOrRestore(self, e);
            },

            mediaItemChanged: function(e) {
                removeOrRestore(self, e);

                if(e._.hasNext) {
                    self.enable();
                } else {
                    self.disable();
                }
            },

            languageUpdated: function() {
                self.button.setAttribute('aria-label', Language.nextItem);
            }

        };
    };

    return NextButton;

})();var BackToStartButton = (function() {

    function animate(self) {

        return function() {

            var previousTimestamp;

            function step(timestamp) {
                if(previousTimestamp === undefined) {
                    previousTimestamp = timestamp;
                    self.textholder.style.opacity = 0;
                }

                var increment = (timestamp - previousTimestamp) / self.animationDuration * 360;

                self.angle = self.angle - increment;

                if(self.angle < -360) {
                    self.angle = -360;
                }

                self.startArrow.setAttribute('transform', 'rotate(' + self.angle + ',26,26)');

                previousTimestamp = timestamp;

                if(self.angle > -360) {
                    self.animationID = requestAnimationFrame(step);
                } else {
                    self.angle = 0;
                    self.textholder.style.opacity = 1;
                }
            }

            if(self.animationID) {
                cancelAnimationFrame(self.animationID);
            }

            self.animationID = requestAnimationFrame(step);

        };


    }

    function configureButton(self) {
        self.button.id = 'p_audioui_backToStartButton';
        Utils.className(self.button, 'p_audioui_jumpButton');
        self.button.setAttribute('aria-label', Language.listenFromStart);

        self.setActionFunction(animate(self));

        var svg = Utils.createSVGElement('svg', {
            width: 48,
            height: 48,
            viewbox: '0 0 48 48'
        });

        var startArrow = self.startArrow = Utils.createSVGElement('g', {
            id: 'p_audioui_backToStartButton_arrow',
            'class': 'p_audioui_jumpButtonArrow'
        });

        var arrowHead = Utils.createSVGElement('polygon', {
            points: '20.185946 9.0716033 15.2310161 14.0162552 16.5522061 15.3346422 20.185946 18.9599727 21.5080704 17.6415858 17.8743305 14.0162552 21.5080704 10.3899903'
        });

        var arrowBody = Utils.createSVGElement('path', {
            d: 'M16.6028486,35.1420282 C18.9705259,37.5078367 22.2436014,38.9719843 25.8595883,38.9719843 C33.0840873,38.9719843 38.940678,33.1275403 38.940678,25.9198599 C38.940678,18.7112452 33.0840873,12.8677355 25.8595883,12.8677355 C25.820345,12.8677355 25.7427929,12.8677355 25.7427929,12.8677355 L24.666406,12.8668012 L27.1443382,10.3944752 L25.8231481,9.07608824 L20.8672839,14.0207401 L25.8231481,18.9644577 L27.1443382,17.6460707 L24.6906995,15.1980382 L25.7418585,15.1989726 C25.7418585,15.1989726 25.820345,15.1980382 25.8595883,15.1980382 C31.7937312,15.1980382 36.6047691,19.9978638 36.6047691,25.9198599 C36.6047691,31.8409217 31.7937312,36.6407473 25.8595883,36.6407473 C22.8864435,36.6407473 20.1954765,35.4363527 18.2501316,33.489139'
        });

        var textholder = self.textholder = document.createElement('div');
        textholder.id = 'p_audioui_backToStartButton_text';
        textholder.innerHTML = 'START';

        startArrow.appendChild(arrowBody);
        startArrow.appendChild(arrowHead);
        svg.appendChild(startArrow);
        self.buttonInner.appendChild(svg);
        self.buttonInner.appendChild(textholder);
    }

    function applyConfigSettings(self) {

        Utils.deleteCssRules(self.ui.stylesheet, ["#p_audioui_backToStartButton:not([disabled]).hovering, #p_audioui_backToStartButton:not([disabled]).pressed, .nonPointerFocus #p_audioui_backToStartButton:not([disabled]).focused"]);

        self.ui.stylesheet.insertRule("#p_audioui_backToStartButton:not([disabled]).hovering, #p_audioui_backToStartButton:not([disabled]).pressed, .nonPointerFocus #p_audioui_backToStartButton:not([disabled]).focused { color: " + self.ui.config.colour + "; fill: " + self.ui.config.colour + "; }", self.ui.stylesheet.cssRules.length);

    }

    function checkEnabled(self, e) {
        if((e._.timeHelper.time <= e._.timeHelper.earliestSeek) && (e._.playingState != 'playing')) {
            self.disable();
        } else {
            self.enable();
        }
    }

    function BackToStartButton(ui) {

        this.ui = ui;
        this.angle = 0;
        this.animationDuration = 600;
        AudioButton.call(this);
        configureButton(this);
        applyConfigSettings(this);
    }

    BackToStartButton.prototype = Utils.object(AudioButton.prototype);

    BackToStartButton.prototype.getEventCallbacks = function () {

        var self = this;

        return {

            uiConfigUpdated: function() {
                applyConfigSettings(self);
            },

            mediaItemChanged: function(e) {
                if(e._.mediaItem.live) {
                    self.restore();
                } else {
                    self.remove();
                }
            },

            seeked: function(e) {
                checkEnabled(self,e);
            },

            timeupdate: function(e) {
                checkEnabled(self,e);
            },

            playing: function(e) {
                checkEnabled(self,e);
            },

            languageUpdated: function() {
                self.button.setAttribute('aria-label', Language.listenFromStart);
            }

        };
    };

    return BackToStartButton;

})();var ToLiveButton = (function() {

    function animate(self) {

        return function() {

            var previousTimestamp;

            function step(timestamp) {
                if(previousTimestamp === undefined) {
                    previousTimestamp = timestamp;
                    self.textholder.style.opacity = 0;
                }

                var increment = (timestamp - previousTimestamp) / self.animationDuration * 360;

                self.angle = self.angle + increment;

                if(self.angle > 360) {
                    self.angle = 360;
                }

                self.startArrow.setAttribute('transform', 'rotate(' + self.angle + ',22,26)');

                previousTimestamp = timestamp;

                if(self.angle < 360) {
                    self.animationID = requestAnimationFrame(step);
                } else {
                    self.angle = 0;
                    self.textholder.style.opacity = 1;
                }
            }

            if(self.animationID) {
                cancelAnimationFrame(self.animationID);
            }

            self.animationID = requestAnimationFrame(step);

        };


    }

    function configureButton(self) {
        self.button.id = 'p_audioui_toLiveButton';
        Utils.className(self.button, 'p_audioui_jumpButton');
        self.button.setAttribute('aria-label', Language.goToLivePoint);

        self.setActionFunction(animate(self));

        var svg = Utils.createSVGElement('svg', {
            width: 48,
            height: 48,
            viewbox: '0 0 48 48'
        });

        var startArrow = self.startArrow = Utils.createSVGElement('g', {
            id: 'p_audioui_toLiveButton_arrow',
            'class': 'p_audioui_jumpButtonArrow'
        });

        var arrowHead = Utils.createSVGElement('polygon', {
            points: '31.413028 15.2730478 27.7728902 18.9047616 26.4493738 17.5840533 30.0895117 13.9523395 26.4493738 10.3196897 27.7728902 8.99898137 32.7374804 13.9523395'
        });

        var arrowBody = Utils.createSVGElement('path', {
            d: 'M31.3627644,35.1147477 C28.9909183,37.4847218 25.7120798,38.9514474 22.089726,38.9514474 C14.8525067,38.9514474 8.98560405,33.0976489 8.98560405,25.8763417 C8.98560405,18.6550345 14.8525067,12.801236 22.089726,12.801236 C22.1290384,12.801236 22.2067271,12.802172 22.2067271,12.802172 L23.2850092,12.8003 L20.8027141,10.3245569 L22.1262304,9.00384862 L27.0908206,13.9562707 L22.1262304,18.9096288 L20.8027141,17.5879845 L23.2606729,15.1356417 L22.2076631,15.1365777 C22.2076631,15.1365777 22.1290384,15.1356417 22.089726,15.1356417 C16.1451347,15.1356417 11.3256258,19.9439185 11.3256258,25.8763417 C11.3256258,31.8078289 16.1451347,36.6161057 22.089726,36.6161057 C25.0681058,36.6161057 27.7638109,35.4095904 29.712581,33.4589483'
        });

        var textholder = self.textholder = document.createElement('div');
        textholder.id = 'p_audioui_toLiveButton_text';
        textholder.innerHTML = 'LIVE';

        startArrow.appendChild(arrowBody);
        startArrow.appendChild(arrowHead);
        svg.appendChild(startArrow);
        self.buttonInner.appendChild(svg);
        self.buttonInner.appendChild(textholder);
    }

    function applyConfigSettings(self) {

        Utils.deleteCssRules(self.ui.stylesheet, ["#p_audioui_toLiveButton:not([disabled]).hovering, #p_audioui_toLiveButton:not([disabled]).pressed, .nonPointerFocus #p_audioui_toLiveButton:not([disabled]).focused"]);

        self.ui.stylesheet.insertRule("#p_audioui_toLiveButton:not([disabled]).hovering, #p_audioui_toLiveButton:not([disabled]).pressed, .nonPointerFocus #p_audioui_toLiveButton:not([disabled]).focused { color: " + self.ui.config.colour + "; fill: " + self.ui.config.colour + "; }", self.ui.stylesheet.cssRules.length);

    }

    function checkEnabled(self, e) {

        if(e._.timeHelper.time - e._.timeHelper.latestSeek > -0.002) {
            self.disable();
        } else {
            self.enable();
        }
    }

    function ToLiveButton(ui) {

        this.ui = ui;
        this.angle = 0;
        this.animationDuration = 600;
        AudioButton.call(this);
        configureButton(this);
        applyConfigSettings(this);
    }

    ToLiveButton.prototype = Utils.object(AudioButton.prototype);

    ToLiveButton.prototype.getEventCallbacks = function () {

        var self = this;

        return {

            uiConfigUpdated: function() {
                applyConfigSettings(self);
            },

            mediaItemChanged: function(e) {
                if(e._.mediaItem.live) {
                    self.restore();
                } else {
                    self.remove();
                }
            },

            seeked: function(e) {
                checkEnabled(self,e);
            },

            timeupdate: function(e) {
                checkEnabled(self,e);
            },

            playing: function(e) {
                checkEnabled(self,e);
            },

            languageUpdated: function() {
                self.button.setAttribute('aria-label', Language.goToLivePoint);
            }

        };
    };

    return ToLiveButton;

})();var PopOutPlayerButton = (function() {

    function configureButton(self) {
        self.button.id = 'p_audioui_popOutPlayerButton';

        var svg = Utils.createSVGElement('svg', {
            width: 20,
            height: 20,
            viewBox: '0 0 20 20'
        });

        var topBox = Utils.createSVGElement('path', {
            d: 'M17.5,2.5v8.75H8.75V2.5H17.5M20,0H6.25V13.75H20V0Z'
        });

        var backBox = Utils.createSVGElement('polygon', {
            points: '12.5 18.75 1.25 18.75 1.25 7.5 5 7.5 5 6.25 0 6.25 0 20 13.75 20 13.75 15 12.5 15 12.5 18.75'
        });

        svg.appendChild(backBox);
        svg.appendChild(topBox);

        var buttonText = self.buttonText = document.createElement('div');
        Utils.className(buttonText, 'p_audioui_popOutPlayerButton_text');
        buttonText.textContent = Language.popOutPlayer;

        self.buttonInner.appendChild(buttonText);
        self.buttonInner.appendChild(svg);

    }

    function applyConfigSettings(self) {

        Utils.deleteCssRules(self.ui.stylesheet, ["#p_audioui_popOutPlayerButton:not([disabled]).hovering, #p_audioui_popOutPlayerButton:not([disabled]).pressed, .nonPointerFocus #p_audioui_popOutPlayerButton:not([disabled]).focused"]);

        self.ui.stylesheet.insertRule("#p_audioui_popOutPlayerButton:not([disabled]).hovering, #p_audioui_popOutPlayerButton:not([disabled]).pressed, .nonPointerFocus #p_audioui_popOutPlayerButton:not([disabled]).focused { color: " + self.ui.config.colour + "; fill: " + self.ui.config.colour + "; }", self.ui.stylesheet.cssRules.length);

        if(self.ui.config.controls.popout) {
            self.restore();
        } else {
            self.remove();
        }

    }

    function PopOutPlayerButton(ui) {

        this.ui = ui;
        AudioButton.call(this);
        configureButton(this);
        applyConfigSettings(this);
    }

    PopOutPlayerButton.prototype = Utils.object(AudioButton.prototype);

    PopOutPlayerButton.prototype.getEventCallbacks = function () {

        var self = this;

        return {

            uiConfigUpdated: function() {
                applyConfigSettings(self);
            },

            languageUpdated: function() {
                self.buttonText.textContent = Language.popOutPlayer;
            }

        };

    };

    return PopOutPlayerButton;

})();var PlaybackSettingsButton = (function() {

    function configureButton(self) {
        self.button.id = 'p_audioui_playbackSettingsButton';

        self.button.setAttribute('aria-label', Language.openPlaybackSettingsMenu);

        var svg = Utils.createSVGElement('svg', {
            width: 48,
            height: 48,
            viewBox: '0 0 44 44'
        });

        var cog = Utils.createSVGElement('path', {
            d: 'M22.76522,23.847576 C21.7467559,24.2695688 20.5757973,23.785077 20.1528122,22.7645945 C19.7303271,21.744612 20.21531,20.575132 21.234774,20.1521393 C22.254238,19.7306465 23.4246967,20.2146382 23.8476818,21.2341207 C24.2706668,22.2546033 23.784184,23.4260832 22.76522,23.847576 M29.8439701,23.8605758 L28.0525333,23.1185885 C28.1885285,22.3896009 28.1955283,21.6326139 28.0560332,20.8801268 L29.8439701,20.1396395 C29.9724655,20.0861404 30.0339634,19.9376429 29.9809652,19.8096451 L29.1919931,17.9051777 C29.139495,17.7776799 28.9910002,17.715681 28.8630047,17.7691801 L27.0735679,18.5101674 C26.6400832,17.8791782 26.0996023,17.3481873 25.4891238,16.9286945 L26.2310976,15.1377251 C26.2840957,15.0092273 26.2225979,14.8607299 26.0941025,14.8077308 L24.1906696,14.0192443 C24.0626742,13.9657452 23.9146794,14.0277441 23.8611813,14.1562419 L23.1192075,15.9472113 C22.3902332,15.8122136 21.6327599,15.8047137 20.8807865,15.9442113 L20.1393127,14.1562419 C20.0863145,14.0277441 19.9378198,13.9657452 19.8093243,14.0192443 L17.9058915,14.8077308 C17.777396,14.8617299 17.7153982,15.0102273 17.7693963,15.1377251 L18.5098702,16.9271945 C17.8798924,17.3596871 17.3489112,17.9001778 16.929926,18.5106674 L15.1384892,17.7686801 C15.0104937,17.715681 14.861499,17.7776799 14.8090008,17.9051777 L14.0200287,19.8096451 C13.9670305,19.9376429 14.0280284,20.0861404 14.1570238,20.1396395 L15.9479606,20.8816268 C15.8129654,21.6091143 15.8049657,22.3666013 15.9444607,23.1190885 L14.1560239,23.8605758 C14.0275284,23.9135748 13.9655306,24.0620723 14.0195287,24.1905701 L14.8090008,26.0945375 C14.8619989,26.2225353 15.0104937,26.2845342 15.1384892,26.2315352 L16.927426,25.4900479 C17.3609107,26.121037 17.9008917,26.651528 18.5113701,27.0700208 L17.7698963,28.8619901 C17.7163982,28.9899879 17.777896,29.1384854 17.9063915,29.1919845 L19.8103243,29.980471 C19.9388197,30.03447 20.0868145,29.9724711 20.1398126,29.8439733 L20.8817865,28.052504 C21.6102607,28.1875017 22.367234,28.1955015 23.1207074,28.0555039 L23.8616813,29.8439733 C23.9151794,29.9724711 24.0636741,30.03347 24.1916696,29.980471 L26.0951024,29.1914845 C26.2235979,29.1384854 26.2850957,28.9899879 26.2320976,28.8619901 L25.4901238,27.0730207 C26.1216015,26.6395282 26.6515828,26.0995374 27.071068,25.4890479 L28.8625047,26.2310352 C28.9900002,26.2845342 29.139495,26.2225353 29.1919931,26.0945375 L29.9809652,24.1905701 C30.0339634,24.0620723 29.9724655,23.9130749 29.8439701,23.8605758'
        });

        svg.appendChild(cog);

        self.buttonInner.appendChild(svg);

    }

    function applyConfigSettings(self) {

        Utils.deleteCssRules(self.ui.stylesheet, ["#p_audioui_playbackSettingsButton:not([disabled]).hovering, #p_audioui_playbackSettingsButton:not([disabled]).pressed, .nonPointerFocus #p_audioui_playbackSettingsButton:not([disabled]).focused"]);

        self.ui.stylesheet.insertRule("#p_audioui_playbackSettingsButton:not([disabled]).hovering, #p_audioui_playbackSettingsButton:not([disabled]).pressed, .nonPointerFocus #p_audioui_playbackSettingsButton:not([disabled]).focused { fill: " + self.ui.config.colour + "; }", self.ui.stylesheet.cssRules.length);

        if(self.ui.config.playbackSettingsPanel && self.ui.config.playbackSettingsPanel.enabled) {
            self.restore();
        } else {
            self.remove();
        }

    }

    function PlaybackSettingsButton(ui) {

        this.ui = ui;
        AudioButton.call(this);
        configureButton(this);
        applyConfigSettings(this);
    }

    PlaybackSettingsButton.prototype = Utils.object(AudioButton.prototype);

    PlaybackSettingsButton.prototype.getEventCallbacks = function () {

        var self = this;

        return {

            uiConfigUpdated: function() {
                applyConfigSettings(self);
            },

            languageUpdated: function() {
                //TODO
            }

        };

    };

    return PlaybackSettingsButton;

})();var BaseUI = (function() {

    function processColour(str,invalid) {
        str=(str+"").replace("0x","#");
        if (!str.match(/^#[a-z0-9]{3,6}$/i) && str!="transparent") {
            if (DEBUG_FULL) {
                console.log("Error, encountered colour:"+str+", please ensure a valid colour is passed in.");
            }
            return invalid;
        }
        return str;
    }

    function getGettersAndSetters() {
        return {
            markerData: {
                get: function() {
                    return null;
                },
                set: function() {
                },
                configurable: true
            }
        };
    }

    function addNonPointerFocusListeners() {

        var pointerDown = false;
        var pointerTimeout;
        var windowFocusTimeout;
        var windowFocusing = false;

        if(!Utils.hasClass(document.body, 'nonPointerFocus')) {
            Utils.className(document.body, 'nonPointerFocus');
        }

        function setPointerDown() {

            clearTimeout(pointerTimeout);
            pointerDown = true;

            if(Utils.hasClass(document.body, 'nonPointerFocus')) {
                Utils.className(document.body, '', 'nonPointerFocus');
            }

            pointerTimeout = setTimeout(setPointerUp, 250);
        }

        function setPointerUp() {
            pointerDown = false;
        }

        if(window.PointerEvent) {
            document.addEventListener('pointerdown', setPointerDown, true);

        } else {
            document.addEventListener('touchstart', setPointerDown, true);
            document.addEventListener('mousedown', setPointerDown, true);
        }

        window.addEventListener('focus', function() {
            clearTimeout(windowFocusTimeout);
            windowFocusing = true;
            windowFocusTimeout = setTimeout(function() {
                windowFocusing = false;
            }, 250);
        });

        document.addEventListener('focus', function() {

            if(!pointerDown && !windowFocusing && !Utils.hasClass(document.body, 'nonPointerFocus')) {
                Utils.className(document.body, 'nonPointerFocus');
            }

        }, true);

    }

    function handlepageKeyPress(ui) {

        return function(e) {

            var guidancePopup = document.getElementById('guidancePopup');
            var focusOnGuidance = guidancePopup && guidancePopup.contains(document.activeElement);
            var focusOnPluginContainer = ui.pluginContainer.contains(document.activeElement);

            Utils.className(document.body,"focusEnabled");
            if ( !e.metaKey && !e.ctrlKey ) { // SMPHTML-1162

                if ((e.keyCode == KEY_SPACE && ui.config.controls.spaceControlsPlayback) || (e.keyCode === KEY_K && ui.config.controls.experimentalShortcuts)) {
                    if (e.target == document.body || Utils.hasClass(e.target, 'p_accessibleHitArea')) {
                        ui.togglePlay('shortcut_key_press');
                        stopIt(e);
                    }
                }

                if (!e.shiftKey && e.keyCode >= KEY_0 && e.keyCode <= KEY_9) {
                    if (ui.config.controls.experimentalShortcuts && !focusOnGuidance && !focusOnPluginContainer) {
                        if (ui.canDisplayRemoteInput()) {
                            ui.displayRemoteInput();

                            var number = (e.keyCode - KEY_0).toString();

                            ui.appendRemoteInputContent(number);
                        } else {
                            var tenth = e.keyCode - KEY_0;
                            ui.player.seekToPercent(tenth / 10);
                            ui.player.trackAction('seek_numberkey_' + tenth.toString(), 'shortcut_key_press');
                        }

                        stopIt(e);
                    }
                    // 888 easter egg doesn't rely on experimentalShortcuts feature flag
                    if (!ui.config.controls.experimentalShortcuts && e.keyCode === KEY_8 && ui.canDisplayRemoteInput()) {
                        ui.displayRemoteInput();

                        ui.appendRemoteInputContent('8');
                    }

                }

                if (e.keyCode == KEY_M) {
                    ui.player.trackAction(ui.player.mediaPlayer.muted ? 'unmute' : 'mute', 'shortcut_key_press');
                    ui.player.muted = !ui.player.muted;
                }

                if (e.keyCode === KEY_J) {
                    if (ui.config.controls.experimentalShortcuts) {
                        ui.player.trackAction('seekbackward', 'shortcut_key_press');
                        ui.player.seekBackward(ui.player.config.skipInterval);
                        stopIt(e);
                    }
                }

                if (e.keyCode === KEY_L) {
                    if (ui.config.controls.experimentalShortcuts) {
                        ui.player.trackAction('seekforward', 'shortcut_key_press');
                        ui.player.seekForward(ui.player.config.skipInterval);
                        stopIt(e);
                    }
                }

                if (e.code=="MediaPlayPause" || e.key=="MediaPlayPause") {
                    ui.togglePlay('shortcut_key_press');
                    stopIt(e);
                } else {
                    if (e.code=="MediaTrackNext" || e.key=="MediaTrackNext") {
                        ui.player.next();
                        stopIt(e);
                    } else {
                        if (e.code=="MediaTrackPrevious" || e.key=="MediaTrackPrevious") {
                            ui.player.previous();
                            stopIt(e);
                        }
                    }
                }
            }

        };
    }

    var BaseUI = function(player, defaultConfig, config) {

        var ui = this;
        ui.player = player;
        ui.container = null;
        ui.UIinfoObject = {};
        ui.enabled = true;

        ui.config = Utils.merge(defaultConfig, config);

        addNonPointerFocusListeners();

        Utils.className(document.body, 'font-family-sans');
        if (!ui.config.disableReithFonts) {
            //if device.supportsReithFonts
            Utils.loadFontFile(ui.player, 'ReithSans');
            if (ui.config.useFontSalt) {
                Utils.className(document.body, 'font-feature-salt');
            }
        }

        // XXX why is this toggle play different to the keyboard toggle play?
        ui.togglePlay = function(actionType) {
            if ((player.paused || player.ended) && (player.playingState === 'notplaying')) {
                player.requestGuidanceAndPlay();
                player.trackAction('play', actionType);
            } else {
                if (player.playingState === 'playing') {
                    player.pause();
                    player.trackAction('pause', actionType);
                }
            }
        };

        ui.config.colour = processColour(ui.config.colour, defaultConfig.colour);
        ui.config.foreColour = processColour(ui.config.foreColour, defaultConfig.foreColour);
        ui.config.alternateColour = processColour(ui.config.alternateColour, defaultConfig.colour);
        ui.config.alternateForeColour = processColour(ui.config.alternateForeColour, defaultConfig.foreColour);
        ui.config.miniMode.backgroundColour = processColour(ui.config.miniMode.backgroundColour,defaultConfig.miniMode.backgroundColour);
        ui.config.cta.backgroundColour = processColour(ui.config.cta.backgroundColour,defaultConfig.cta.backgroundColour);

        ui.config.useHighResIcons = (ui.config.useHighResIcons && !Device.disallowHighResIcons);

        if(ui.config.useHighResIcons) {
            Device.loadSVGForHighResIcon(ui);
        }

        Utils.defineProperties(ui, getGettersAndSetters(ui));

        document.addEventListener("keydown", handlepageKeyPress(ui));

    };

    BaseUI.prototype = {

        initialise: function() {

            var sheet = document.createElement("style");
            document.getElementsByTagName("head")[0].appendChild(sheet);
            this.stylesheet = sheet.sheet;

            if (Device.iPhoneIos10){
                Utils.className(document.body, "iPhoneIos10", "");
            }
            if (Device.iPhoneIos11orGreater){
                Utils.className(document.body, "iPhoneIos11orGreater", "");
            }

            if (this.config.useHighResIcons) {
                Utils.className(document.body,"svg");
            }

        },

        updateConfig: function(config) {

            this.config = Utils.merge(this.config,config);
            this.player.config.ui = this.config;

            var configAsString = JSON.stringify(this.config);
            if (configAsString == this.lastConfigUpdate) {
                // no changes, so do nothing, an optimisation, need to
                // consider if this is still worth the cost of the
                // stringify as subtitles are the biggest changes.
                return false;
            }
            this.lastConfigUpdate = configAsString;
            this.updateStyles();
            this.player.dispatch({type: "uiConfigUpdated"});
            return true;
        },

        timeUpdate: emptyFunction,

        updateStyles: emptyFunction,

        fadeInNewPosterImage: emptyFunction,

        slideInNewPosterImage: emptyFunction,

        zoomInPosterImage: emptyFunction,

        showPoster: emptyFunction,

        updatePoster: emptyFunction,

        hidePoster: emptyFunction,

        hideEffects: emptyFunction,

        updateLayout: emptyFunction,

        hideControlBar: emptyFunction,

        showControlBar: emptyFunction,

        updateDisplayedProgress: emptyFunction,

        displayCover: emptyFunction,

        checkIfCanDisplaySeekBar: emptyFunction,

        showCta: function() {
            this.inPrePlayState = true;
        },

        hideCta: function() {
            this.inPrePlayState = false;
        },

        hideAllControls: emptyFunction,

        dispatchUIInfo: emptyFunction,

        getBackgroundImageUrl: emptyFunction,

        resizeFixEnd: emptyFunction,
        resetGuidance: emptyFunction,
        updateTimeDisplay: emptyFunction,
        updateGuidance: emptyFunction,

        canDisplayRemoteInput: function() {
            return false;
        },

        displayRemoteInput: emptyFunction,
        appendRemoteInputContent: emptyFunction,
        getRemoteInputContent: emptyFunction,
        clearRemoteInput: emptyFunction,
        ensureRemoteInput: emptyFunction,

    };

    return BaseUI;

})();
var AudioTimeDisplays = (function() {

    function createTimeDisplays(self) {

        var leftTimeDisplay = self.leftTimeDisplay = document.createElement('div');
        leftTimeDisplay.id = 'p_audioui_leftTimeDisplay';
        hideElement(leftTimeDisplay);

        var rightTimeDisplay = self.rightTimeDisplay = document.createElement('div');
        rightTimeDisplay.id = 'p_audioui_rightTimeDisplay';
        hideElement(rightTimeDisplay);

        var liveIcon = self.liveIcon = Utils.createSVGElement('svg', {
            width: 12,
            height: 12
        });

        var liveIconRing = Utils.createSVGElement('path', {
            d: 'M5.96681502,10.3410568 C8.38342771,10.3410568 10.3424794,8.38388329 10.3424794,5.96958745 C10.3424794,3.5552916 8.38342771,1.59811812 5.96681502,1.59811812 C3.55020233,1.59811812 1.59115067,3.5552916 1.59115067,5.96958745 C1.59115067,8.38388329 3.55020233,10.3410568 5.96681502,10.3410568 Z M5.96681502,11.930682 C2.67143408,11.930682 0,9.26180906 0,5.96958745 C0,2.67736584 2.67143408,0.00849290887 5.96681502,0.00849290887 C9.26219596,0.00849290887 11.93363,2.67736584 11.93363,5.96958745 C11.93363,9.26180906 9.26219596,11.930682 5.96681502,11.930682 Z'
        });

        var liveIconCircle = Utils.createSVGElement('circle', {
            'class': 'p_audioui_liveIconCentre',
            cx: 6,
            cy: 6,
            r: 3
        });

        liveIcon.appendChild(liveIconCircle);
        liveIcon.appendChild(liveIconRing);

        liveIcon.style.display = 'none';

        var rightText = self.rightText = document.createElement('span');

        rightTimeDisplay.appendChild(rightText);
        rightTimeDisplay.appendChild(liveIcon);

    }

    function updateTimeDisplay(self) {

        // Right

        if(self.player.mediaItem && self.player.mediaItem.live) {

            if(self.player.timeHelper.latestSeek == self.player.timeHelper.time) {

                self.rightText.textContent = 'LIVE';

                self.liveIcon.style.display = 'block';
                showElement(self.rightTimeDisplay);

            } else if(self.player.timeHelper.time && self.player.timeHelper.latestSeek) {

                if(self.ui.config.timesRelativeToLive) {
                    self.rightText.textContent = self.player.timeHelper.secondsToHMS(self.player.timeHelper.time - self.player.timeHelper.latestSeek);
                } else {
                    self.rightText.textContent = self.player.timeHelper.getTimeString();
                }

                self.liveIcon.style.display = 'none';
                showElement(self.rightTimeDisplay);

            } else {

                hideElement(self.rightTimeDisplay);

            }

        } else if(self.player.mediaItem) {

            var duration = self.player.timeHelper.getDurationOrEndString();

            if(duration) {
                self.rightText.textContent = duration;
                self.liveIcon.style.display = 'none';
                showElement(self.rightTimeDisplay);
            } else {
                hideElement(self.rightTimeDisplay);
            }


        } else {
            hideElement(self.rightTimeDisplay);
        }

        // Left

        if(self.player.mediaItem && !self.player.mediaItem.live) {

            var timeStamp = self.player.timeHelper.getTimeString();

            if(timeStamp) {
                self.leftTimeDisplay.textContent = timeStamp;
                showElement(self.leftTimeDisplay);
            } else {
                hideElement(self.leftTimeDisplay);
            }


        } else {
            hideElement(self.leftTimeDisplay);
        }

    }

    function showElement(element) {
        if(element.style.opacity !== 1) {
            element.style.opacity = 1;
            element.setAttribute('aria-hidden', 'false');
        }
    }

    function hideElement(element) {
        if(element.style.opacity !== 0) {
            element.style.opacity = 0;
            element.setAttribute('aria-hidden', 'true');
        }
    }


    function AudioTimeDisplays(ui) {

        this.ui = ui;
        this.player = ui.player;
        createTimeDisplays(this);

    }

    AudioTimeDisplays.prototype = {

        getDomNodes: function() {
            return [this.leftTimeDisplay, this.rightTimeDisplay];
        },

        getEventCallbacks: function () {

            var self = this;

            return {

                timeupdate: function() {
                    updateTimeDisplay(self);
                },

                showCta: function() {
                    if(self.player.playlist && self.player.playlist.hasLive) {
                        self.setLive();
                    } else {
                        self.reset();
                    }
                }

            };
        },

        setLive: function() {
            this.rightText.textContent = 'LIVE';
            this.liveIcon.style.display = 'block';
            showElement(this.rightTimeDisplay);
            hideElement(this.leftTimeDisplay);
        },

        reset: function() {
            hideElement(this.rightTimeDisplay);
            hideElement(this.leftTimeDisplay);
        }

    };

    return AudioTimeDisplays;

})();var AudioCtaDuration = (function() {

    function AudioCtaDuration(ui) {

        this.ui = ui;

        var ctaDuration = this.component = document.createElement('div');
        ctaDuration.id = 'p_audioui_ctaDuration';

        ui.player.pushMediaEventFunctions(this.getEventCallbacks());
    }

    AudioCtaDuration.prototype = {

        show: function() {
            Utils.className(this.component, '', 'hidden');
            if(!Utils.hasClass(this.component, 'removed')) {
                this.component.setAttribute('aria-hidden', 'false');
            }
        },

        hide: function() {
            Utils.className(this.component, 'hidden');
            this.component.setAttribute('aria-hidden', 'true');
        },

        remove: function() {
            Utils.className(this.component, 'removed');
            this.component.setAttribute('aria-hidden', 'true');
        },

        restore: function() {
            Utils.className(this.component, '', 'removed');

            if(!Utils.hasClass(this.component, 'hidden')) {
                this.component.setAttribute('aria-hidden', 'false');
            }
        },

        getDomNodes: function() {
            return this.component;
        },

        getEventCallbacks: function () {

            var self = this;

            return {

                playlistLoaded: function(e) {

                    if(!e.playlist.hasLive && self.ui.config.cta.mode == "duration" && e.playlist.programmeDuration !== "") {

                        self.component.textContent = e.playlist.programmeDuration;

                        self.restore();
                    } else {
                        self.remove();
                    }
                }

            };
        }


    };

    return AudioCtaDuration;

})();/**
 * Default UI - adds display logic, creates DOM objects, etc
 *
 */


var UI = (function() {


var BUTTON_WIDTH1 = 45; // Current width of control bar buttons plus one pixel


function safeLower(str) {
  return (str+'').toLowerCase();
}

/** Poster Image Constants **/
var NO_POSTER = "-9999px 0px";
var POSTER_RESIZE_DELAY = 1000;

function isElementVisible(el) {
    return el && el.style.display === 'block';
}



function isHovering(ui) {
    if (ui.controls.parentElement) {
        var el=ui.controls.parentElement.querySelector(':hover');
        if (!el) {
            return false;
        }
        if (el==ui.controls) {
            return true;
        }
        var pc=document.getElementById('p_pluginContainer');
        if (pc==el) {
            var els=pc.querySelectorAll(':hover');
            if (els.length>0) {
                if (!Utils.hasClass(els[els.length-1],"notInteractiveContent")) {
                    return true;
                }
            }
        }
        return false;
    }
}

function testButtonCovered(element, always, width) {
    var covered = (always || (Utils.getOffset(element) - width) <= 0);
    Utils.setOrUnsetClass(element,'p_covered',covered);
    return covered;
}

function currentStateForFullscreenChange(ui) {
    ui.forcedInactive = true;
    if (Device.requiresFullscreenResizeDelay) {
        ui.hideControlBar();
    }
}

function checkPiPavailability(ui) {
    var oldCheck = ui.pIp.supported;
    var newCheck = ui.pIp.isSupported();

    if (oldCheck != newCheck) {
        ui.updateLayout();
    }
}

function checkButtonForBody(test,className) {
    if (test) {
        Utils.className(document.body,className);
        return 1;
    }
    Utils.className(document.body,'',className);
    return 0;
}

function zoomStyleFunction(ui,zoomTime,zoomScale) {
    ui.stylesheet.insertRule('.zoomEffectTransition {-webkit-transition-duration: ' + zoomTime + 's; -moz-transition-duration: ' + zoomTime + 's; transition-duration: ' + zoomTime + 's;}', 0);
    ui.stylesheet.insertRule('.zoomEffectScale {transform: scale(' + zoomScale + '); -webkit-transform: scale(' + zoomScale + '); -ms-transform: scale(' + zoomScale + '); -moz-transform: scale(' + zoomScale + ');}', 0);
}

var fadeTimeout;
function fadeStyleFunction(ui, fadeTime) {
    clearTimeout(fadeTimeout);
    fadeTimeout = setTimeout(function() {
        ui.stylesheet.insertRule('.fadeEffect {-webkit-transition: opacity ' + fadeTime + 's ease-out; -moz-transition: opacity ' + fadeTime + 's ease-out; transition: opacity ' + fadeTime + 's ease-out; opacity: 0;}', 0);
    },5);
}

var sliderTimeout;
function slideStyleFunction(ui,newImage) {
    clearTimeout(sliderTimeout);
    sliderTimeout = setTimeout(function() {
       Utils.className(newImage, 'p_onScreen', 'p_offScreenLeft p_offScreenRight');

   },5);
}







function showControlBarAfterFS(ui) {
    ui.showControlBar();
    ui.disallowFade = true;
    setTimeout(function allowFade() {
                   ui.disallowFade=false;
                   ui.isControlsInteraction = false;
                   ui.resetIdleTimeout({type:"mouse"});
               },250);
}





/**
 * UI_getCallbackObject Returns the allowed callbacks that can be made to the UI class from the player
 *
 */
function ui_getCallbackObject(ui) {

    function playing() {

        if (ui.player.isAudio || ui.player.isThreeSixty) {
            ui.showPoster();
            ui.pIp.exitPicInPic();
        } else {
            ui.hidePoster();
        }

        ui.hideCta();
        ui.dispatchUIInfo();
        ui.updateLayout();

        ui.playbackSettingsPanel.checkQualityAvailability();
    }

    function startingPlayback() {
        if (!ui.player.isAudio && !ui.config.poster.availableWhenSettingUp) {
            ui.hidePoster();
        }
        ui.hideCta();
        ui.updateLayout();
        if (!Device.iPhoneOutOfPagePlayback || ui.player.isAudio) {
            ui.showControlBar(true);
            if (ui.config.thumbnail.enabled) {
                ui.player.thumbScrub.extractManifestData();
            }
        }
    }

    function playlistLoaded(e) {

        ui.readyToPlay = true;

        var mediaState = ui.player.playlist.mediaType;
        ui.setCta(mediaState);
        ui.hitAreaUpdate();

        if (ui.player.autoPlayNextItem) {
            ui.guidancePopUp(e.fromQueue);
            if (mediaState=="audio" || ui.config.poster.availableWhenSettingUp) {
                ui.showPoster();
            }
            return;
        }
        ui.showPoster();
        ui.resetGuidance();

        ui.hideAllControls();
        // optimise against people calling .play() in playlistLoaded
        Utils.asyncDelay(function() {
            if (!ui.player.tryingToPlay) {
                ui.player.dispatch({type:"notPlayingState"});
                ui.showCta();
            }
        });

    }

    return {
        notPlayingState : function() {
            var playButtonType = 'play';
            if (ui.config.controls.iplayerPlay) {
                playButtonType = 'play-iplayer';
            }
            setButton(ui.playPauseButton,ui.playClassName, Language.toolTipPlay, Language.toolTipPlay, ui.config.useHighResIcons && playButtonType);
        },
        playingState : function() {
            // hmm the boolean && string is a bit icky, sort of
            // confusing maybe?
            setButton(ui.playPauseButton,"p_pauseButton", Language.toolTipPause, Language.toolTipPause,ui.config.useHighResIcons && 'pause');
        },
        blockUnwanted : true,
        tryingToPlay : startingPlayback,
        play : startingPlayback,
        losingControl : function() {
            ui.hideCta();
            ui.hidePoster();
            ui.hideControlBar(true);
        },
        mediaItemChanged : function() {
            updateMiniModeClasses(ui);
            ui.setCta(ui.player.mediaItem && ui.player.mediaItem.type);
            ui.timeUpdate();
            ui.pIp.isSupported();
            ui.checkIfCanDisplaySeekBar();
            ui.dispatchUIInfo();
        },
        playing : playing,
        pause : function() {
            ui.updateLayout();
            if (ui.config.poster.availableWhenPaused) {
                ui.showPoster();
                ui.player.hidePlayer();
            }
        },
        waiting : function() {
            if (ui.player.playingState=="playing") {
                ui.updateLayout();
            }
        },
        seeking : function() {
            ui.markersUI.resetProgress();
        },
        seeked : function() {
            if (!ui.player.isSeeking ) {
                this.timeupdate();
            }
        },
        playerDisconnected : function() {
            ui.hideAllControls();
            if (ui.active) {
                ui.showCta();
            }
            ui.showPoster();
        },
        playlistStopped: function() {
            ui.hideAllControls();
            ui.showCta();
            ui.showPoster();
            ui.player.hidePlayer();
        },
        canPauseChange: function() {
            ui.markersUI.testDrawMarkers(true);
        },
        ended : function() {
            ui.resetGuidance();
            ui.markersUI.resetProgress();
        },
        playlistEnded : function(e) {

            var queuedOptionsWithoutAutoplay = ui.player.playlist && !ui.player.playlist.queuedOptions || (ui.player.playlist && ui.player.playlist.queuedOptions && !ui.player.playlist.queuedOptions.autoplay);

            if (!e.willAutomaticPlayQueuedItem || queuedOptionsWithoutAutoplay) {

                ui.showPoster();
                if (ui.active) {
                    if (!ui.config.controls.availableOnMediaEnded && !ui.player.isFullScreen && !ui.player.mediaPlayer.webkitIsFullscreen){
                        ui.hideAllControls();
                        ui.showCta();
                    } else {
                        ui.showControlBar();
                    }
                }
                if (Device.iPhoneOutOfPagePlayback && ui.player.mediaPlayer.webkitExitFullscreen) {
                    ui.player.mediaPlayer.webkitExitFullscreen();
                }
            }
        },
        error : function(event) {
            if (event.code==SMPError.SUBS_FAILED) {
                ui.UIinfoObject.subtitles = false;
                ui.updateLayout();
            }
        },
        beforeErrorDisplay: function() {
            ui.resetGuidance();
            ui.hideCta();
            ui.hideAllControls(true);
            ui.showPoster();
            ui.player.minimise();
        },
        playlistLoading:function() {
            ui.readyToPlay = false;
            ui.hideCta();
            ui.updateTimeDisplay();
            ui.hidePoster();
            ui.container.style.backgroundImage = "";
            ui.markersUI.resetStoredMarkers();

        },

        resetUiToPlaylistLoaded: function() {

            playlistLoaded({});

        },

        playlistLoaded: playlistLoaded,
        beforeFullscreenEnter : function() {
            currentStateForFullscreenChange(ui);
            ui.pIp.exitPicInPic();
        },
        beforeFullscreenExit : function() {
            currentStateForFullscreenChange(ui);
            Utils.className(document.body,"","fullscreen");
            setButton(ui.fullscreenButton,"p_fullscreenButton",Language.toolTipEnterFullScreen,Language.toolTipEnterFullScreen,ui.config.useHighResIcons && 'fullscreen-enter');
        },
        fullscreenEnter : function() {
            Utils.className(document.body,"fullscreen");
            setButton(ui.fullscreenButton,"p_fullscreenButtonReturn",Language.toolTipExitFullScreen,Language.toolTipExitFullScreen,ui.config.useHighResIcons && 'fullscreen-return');
            ui.UIinfoObject.isFullscreen = true;
            ui.forcedInactive = false;
            removeFocusEnabled();
            setTimeout(removeFocusEnabled,200);
            if (ui.enabled) {
                showControlBarAfterFS(ui);
            } else {
                ui.showControlBarRequired = true;
            }
        },
        fullscreenExit:function() {
            ui.UIinfoObject.isFullscreen = false;
            Utils.deleteCssRules(ui.stylesheet, ['.updatedFullscreenPosition', '.p_gradientBottomfiller']);
            Utils.className(ui.controls,"","updatedFullscreenPosition");
            Utils.className(ui.gradientLayer,"","updatedFullscreenPosition");
            if ( (ui.player.mediaEnded && !ui.config.controls.availableOnMediaEnded) || ui.inPrePlayState ) {
                // SMPHTML-919 - the resize comes out while the fixSize handler is still running
                // forcing enabled makes sure the elements redraw correctly
                // although it may cause a flash of weirdy layout
                ui.enabled = true;
                ui.showPoster();
                ui.hideAllControls();
                ui.showCta();
                ui.enabled = false;
            }
            // SMPHTML-475
            // in some browsers, updateLayout can fire before the browser has
            // finished redrawing everything. Delay this a bit.
            clearTimeout(ui.updateLayoutTimer);
            ui.updateLayoutTimer = setTimeout(function() {
                ui.updateLayout();
                ui.player.Subtitles.updatePositions();
                removeFocusEnabled();
                if (ui.player.Chromecast.isCasting) {
                    ui.showControlBar();
                }
            },500);
            ui.forcedInactive = false;
            removeFocusEnabled();
        },
        picInPicStarted : function() {
            testButton(ui.pIpButton,"p_picInPicButton p_controlBarButton_on", "p_picInPicButton",Language.toolTipStopPicInPic,Language.toolTipPicInPic,true,'picInPic-stop','picInPic');
            if (ui.player.isFullScreen) {
                ui.player.minimise();
            }
        },
        picInPicStopped : function() {
            testButton(ui.pIpButton,"p_picInPicButton p_controlBarButton_on", "p_picInPicButton",Language.toolTipStopPicInPic,Language.toolTipPicInPic,false,'picInPic-stop','picInPic');
        },
        timeupdate : function() {
            ui.timeUpdate();
        },
        languageUpdated : function() {

            testButton(ui.pIpButton,"p_picInPicButton p_controlBarButton_on", "p_picInPicButton",Language.toolTipStopPicInPic,Language.toolTipPicInPic,ui.pIp.isPlayingInPicture(),'picInPic-stop','picInPic');

           testButton(ui.chromecastButton,"p_chromecastButton p_controlBarButton_on", "p_chromecastButton",Language.toolTipStopChromecast,Language.toolTipChromecast, ui.player.Chromecast.isCasting || ui.player.Chromecast.isAttemptingToCast);

            testButton(ui.playPauseButton,"p_pauseButton",ui.playClassName,Language.toolTipPause,Language.toolTipPlay,(ui.player.playingState=="playing"));
            testButton(ui.embedButton,"p_embedButton","p_embedButton",Language.toolTipEmbed,Language.toolTipEmbed,ui.config.embed.enabled);


            if(ui.subtitleSettingsPanel) {
                ui.subtitleSettingsPanel.updateLanguage();
            }

            ui.playbackSettingsPanel.updateLanguage();

            ui.ctaUpdate();
            ui.hitAreaUpdate();
            ui.updateGuidance();
            testButton(ui.fullscreenButton,"p_fullscreenButton","p_fullscreenButtonReturn",Language.toolTipEnterFullScreen,Language.toolTipExitFullScreen, (!ui.player.isFullScreen));
        },
        durationchange : function() {
            // the video size may well have changed.
            ui.dispatchUIInfo();
            ui.checkIfCanDisplaySeekBar();
            ui.markersUI.updateMarkers();
            checkPiPavailability(ui);
        },
        subtitles: function(e) {
            if(ui.subtitleSettingsPanel) {
                if (e.active) {
                    ui.subtitleSettingsPanel.indicateSubsOn();
                } else {
                    ui.subtitleSettingsPanel.indicateSubsOff();
                }
            }
        },
        guidanceHide:function() {
            ui.resetGuidance();
            Utils.className(document.body,"","p_continuousGuidanceOrWarning");
        },
        chromecast: function(e) {
            ui.pIp.exitPicInPic();
            testButton(ui.chromecastButton,"p_chromecastButton p_controlBarButton_on", "p_chromecastButton",Language.toolTipStopChromecast,Language.toolTipChromecast, e.active);
        },
        ccConnect: function(){
            ui.playbackSettingsPanel.checkQualityAvailability(true);
            testButton(ui.chromecastButton,"p_chromecastButton p_controlBarButton_on", "p_chromecastButton",Language.toolTipStopChromecast,Language.toolTipChromecast, true);
        },
        ccDisconnected: function(){
            ui.playbackSettingsPanel.checkQualityAvailability(null,true);
            testButton(ui.chromecastButton,"p_chromecastButton p_controlBarButton_on", "p_chromecastButton",Language.toolTipChromecast,Language.toolTipChromecast, false);
        },
        configUpdated: function() {
            ui.playbackSettingsPanel.setAutoplay(ui.player.config.continuousPlay);
        },
        volumeOpening: function() {
            ui.updateControlBarDisplayForOpenVolume();
        },
        volumeClosed: function() {
            Utils.className(ui.fullscreenButton, '', 'p_covered');
            Utils.className(ui.subtitlesButton, '', 'p_covered');
            Utils.className(ui.playbackSettingsButton, '', 'p_covered');
            Utils.className(ui.pIpButton, '', 'p_covered');
            Utils.className(ui.chromecastButton, '', 'p_covered');
            Utils.className(ui.embedButton, '', 'p_covered');
            Utils.className(ui.timeDisplay, '', 'p_covered');
        }
    };
}

    // XXX refactor so config is shared so we can be
    // ready to swap between the two skins more easily.

var defaultConfig = {
    buffer : {
        enabled:true,
        colour:'',
        foreColour:'#ffffff',
        width:50,
        thickness:10,
        top:"50%",
        left:"50%",
        forceShow: false
    },
    poster : {
        enabled:true,
        effects:false
    },
    cta : {
        enabled:true,
        visiblyHidden:false,
        ignoreAudio:false,
        backgroundColour : "#808080"
    },
    errorDialog : {
        enabled:true
    },
    controls : {
        enabled : true,
        mode : 'default',
        always : false,
        availableOnMediaEnded: false,
        enableLiveRewind : true,
        iplayerPlay : false,
        spaceControlsPlayback : false,
        experimentalShortcuts : false,
        muteButtonOnly: false,
        volumeSlider: true,
        volumeDismissTime: 2000,
        timeout: 2000,
        timeoutTouch: 5000
    },
    markers : {
        enabled: true,
        suppressMarkerKinds : [],
        hideBelowWidth : 600
    },
    subtitles : {
        enabled : true,
        desnakeLiveSubtitles: true,
        reformatLiveSubtitles: true,
        supportLiveSubtitles: true,
        defaultOn : false,
        yOffset : NaN,
        kind: "subtitles",
        margins: [],
        useNarrative : false
    },
    guidance :  {
        enabled : true,
        pinRequired : false,
        displayContinuousGuidanceInQueuePlaylist : true,
        displayGuidanceInAutoplay : true
    },
    fullscreen : {
        enabled : true,
        dblclick : true
    },
    embed : {
        enabled : true
    },
    embedded : {
        enabled : false
    },
    miniMode: {
        enabled : false,
        backgroundColour : "#ffffff"
    },
    locale : {
        lang : "en",
        path : "/emp/translations/smp/{lang}.xml"
    },
    chromecast: {
        enabled : true,
        shiftCentralControls: false
    },
    thumbnail: {
        enabled : true
    },
    pictureInPicture : {
        enabled : true
    },
    useInPlayerGuidance : true,
    mediaSessionAPI : {
        enabled : true
    },
    colour : '#f54997',
    accessibility : {
        enhanceBrightColoursContrast : false
    },
    foreColour : '#ffffff',
    playbackSettingsPanel: {
        enabled: false,
        continuousPlaySetting: false,
        highlightMenuColour: "#ffffff"
    },
    skin: 'classic'
};

// Toggle button parameters: c1: CSS on, c2: CSS off, t1: tooltip off, t2: tooltip on, test: on/off
function testButton(button,c1,c2,t1,t2,test,i1,i2) {
    if (test) {
        setButton(button,c1,t1,t1,i1);
    } else {
        setButton(button,c2,t2,t2,i2);
    }
}

function setButton(button,className,title,ariaLabel,icon) {
    if (!button) {
        return;
    }
    if (Utils.hasClass(button,"p_buttonHover")) {
        className = className + " p_buttonHover";
    }
    button.setAttribute('aria-label',ariaLabel);
    button.className = 'p_button p_controlBarButton ' + className;
    if (icon) {
        updateExistingSvg(button,icon);
    }
    if (button.title!=title) {
        button.title = title;
        var hiddenElement = button.getElementsByClassName('p_hiddenElement')[0];
        if (hiddenElement) {
            // XXX are we sure innerHTML is safe/needed here?
            hiddenElement.innerHTML = title;
        }
    }
}

function addHoverListeners(button) {
   // SMPHTML-1170: Replace css hover with class to overcome
   // inconsistent touch device behaviour
    button.addEventListener("mouseover", function() {
        Utils.className(button,"p_buttonHover");
    });
    button.addEventListener("mouseout", function() {
        Utils.className(button,"","p_buttonHover");
    });
    // Disable background color transition on touch
    button.addEventListener("touchstart", function() {
        Utils.className(button,"p_buttonHover p_buttonTouch");
    },{passive:true} );
    button.addEventListener("touchend", function() {
        Utils.className(button,"","p_buttonHover p_buttonTouch");
    });
}

function getButton(className,func,title,ariaLabel,ui,includeIndicator,icon) {
    var button = createElement('button','p_button','<span class="p_hiddenElement" aria-hidden="true"></span>',title);
    if (includeIndicator) {
        var selectedBackground = createElement('div','p_selected_background');
        selectedBackground.appendChild(createElement('div','p_selected_indicator'));
        button.appendChild(selectedBackground);

    }

    addHoverListeners(button);

    Utils.multiAddEventListener(button,"touchend click mouseup",stop(func));

    button.setAttribute("role","button");
    button.setAttribute('aria-live','polite'); //Inform screen reader when any child elements are updated but wait until user input has completed

    button.addEventListener("focusin", ui.focusInButton);
    setButton(button,className,title,ariaLabel,ui.config.useHighResIcons && icon);
    return button;
}

var allowedTags = {
    a: true,
    button: true
};

function shouldGetFocus(element) {
    if ( Utils.hasClass(element,"p_chapterMarker") || Utils.hasClass(element,"p_keyMoment"))  {
        return true;
    }

    if(element && element.getAttribute('role') == 'checkbox') {
        return true;
    }

    var tag = element && (element.tagName+'').toLowerCase();
    return allowedTags[tag];
}

function stop(func) {
     return function(e) {
         if (func) {
             func(e);
         }
         stopIt(e);
         return false;
     };
}

function getGettersAndSetters(ui) {
    return {
        active : {
            get : function() {
                if (ui.inError || ui.forcedInactive || ui.player.destroying) {
                    return false;
                }
                return ui.readyToPlay;
            }
        },
        inError : {
            get : function() {
                if (ui.player.inErrorState || (ui.error && ui.error.className.indexOf("p_errorDialog") >= 0)) {
                    return true;
                }
                return false;
            }
        },
        playClassName : {
            get : function() {
                var className = "";
                if (ui.config.controls.iplayerPlay) {
                    className = "p_iplayerPlay ";
                }
                return className + "p_playButton";
            }
        },
        markerData : {
            get : function() {
                return ui.markersUI._markerData;
            },
            set : function(data) {
                ui.markersUI.setMarkers(data);
            }
        },
        miniModeEnabled : {
            get : function() {
                if (ui.config.miniMode && ui.config.miniMode.enabled) {
                    return true;
                } else {
                    var width = Utils.getOffset(ui.container, 'width');
                    var height = Utils.getOffset(ui.container, 'height');
                    if(ui.player.isAudio && height < 200 && width/height > 2.5 ) {
                        // tiny wide audio players are always miniMode
                        return true;
                    } else {
                        return false;
                    }
                }
            }
        }
    };
}

    /**
     * Constructor for UI class
     *
     */
     var UI = function(player, config/*, subs*/) {
        var ui = this;

        BaseUI.call(this, player, defaultConfig, config);

        Utils.defineProperties(ui, getGettersAndSetters(ui));

        // XXX this is needed in Audio UI too
        if (Device.trident) {
            document.addEventListener("focusin",handlePageFocusIn(ui));
        }
        document.addEventListener("keyup", function(e) {
                                      if (e.keyCode==9) {
                                          Utils.className(document.body,"focusEnabled");
                                      }
                                  });
        window.addEventListener("blur",handlePageFocusOut(ui, false));
        document.addEventListener("touchend",removeFocusEnabled);
        document.addEventListener("keydown",handlepageKeyPress(ui));

        ui.UIinfoObject={
            subtitles:false,
            controlBarVisible: false,
            seekBarVisible:false,
            controlsTop:0,
            controlsLeft:0,
            controlsHeight:0,
            controlsWidth:0,
            seekBarLeft:0,
            seekBarRight:0,
            markersBarVisible:false,
            isFullscreen:false,
            videoX:0,
            videoY:0,
            videoWidth:0,
            videoHeight:0
        };

        ui.markersUI = new MarkersUI(ui);
        ui.pGuidance = new ParentalGuidance(ui, ui.player);

        ui.pIp = new PictureInPicture(ui.player, ui);

        ui.settingsPanels = [];

        ui.controlbarTimer =- 1;

        // SMPHTML-791
        ui.needStopTouch = false;

        // these functions are used across multiple places, so let's
        // just create once
        ui.focusPlayPauseButton = function() {
            if (ui.inPrePlayState && ui.cta) {
                ui.cta.focus();
            } else {
                ui.playPauseButton.focus();
            }
        };

        ui.fadeControlBar = function(e) {
            if (!ui.disallowFade) {
                if ((e.type != "pointerout" || e.pointerType == "mouse") && !document.body.contains(e.relatedTarget) && !player.Chromecast.isCasting && !player.mediaEnded) {
                    ui.hideControlBar();
                }
            }
        };

        ui.focusInButton = function() {
            if (ui.controls && !ui.controls.visible) {
                ui.showControlBar();
            }
        };

        return ui;
    };

    function getCtaIconName(ui, audio) {
        if (ui.config.cta.ignoreAudio) {
            audio=false;
        }
        if (ui.config.cta.iplayer) {
            return audio ? 'play-iplayer-audio' : 'play-iplayer';
        }
        return  audio ? 'audio' : 'play';
    }


    function handleIphoneFullscreen(ui) {
        return function(e) {
            if (ui.player.isFullScreen) {
                return;
            }
            if (e.type=="webkitfullscreenchange" && ui.player.mediaPlayer.webkitisfullscreen) {
                return;
            }
            ui.player.dispatch({ type: "playlistStopped" });
        };
    }

    function handlePageFocusIn(ui) {
        return function() {
            // if we are fullscreen, and we get focus on an element
            // that we shouldn't (because of an IE bug) then we should
            // focus on the playPause button
            if ( ui.player.isFullScreen && !shouldGetFocus(document.activeElement) && !ui.pGuidance.nowShowing) {
                if (!ui.controls.visible) {
                    ui.forcedControlsInteraction = true;
                    setTimeout(function() {
                                   ui.forcedControlsInteraction = false;
                               },DUPLICATE_EVENT_TIMEOUT+50);
                }
                Utils.asyncDelay(ui.focusPlayPauseButton);
            }
        };
    }

    function handlePageFocusOut(ui, async) {
        return function(e) {
            // XXX don't we only need to do this in fake fullscreen? Real fullscreen also. Browsers do not always limit tabbing to the fullscreen element
            //
            // if we are in fullscreen, we need to constrain the
            // tabbing to player elements only including any focusable
            // elements within the plugin container
            if ( ui.player.isFullScreen && Device.canTabbing ) {
                if (!document.body.contains(e.relatedTarget) || (e.relatedTarget == document.body)) {
                    if(async) {
                        Utils.asyncDelay(ui.focusPlayPauseButton);
                    } else {
                        ui.focusPlayPauseButton();
                    }
                }
            } else if (!document.body.contains(e.relatedTarget) || (e.relatedTarget == document.body)) {
                ui.fadeControlBar(e);
            }
        };
    }

    function handlepageKeyPress(ui) {

        return function(e) {
            if ( !e.metaKey && !e.ctrlKey ) { // SMPHTML-1162

                if (e.keyCode == KEY_F) {
                    ui.player.trackAction(ui.player.isFullScreen ? 'exit_full_screen' : 'enter_full_screen', 'shortcut_key_press');
                    ui.player.toggleFullscreen();
                }
            }
        };

    }

    function removeFocusEnabled() {
        Utils.className(document.body,"","focusEnabled");
        Utils.className(document.body,"","nonPointerFocus");
    }

    function shouldCloseSettingsPanel(ui, event) {

        var dontCloseSettingsPanelNodes = document.querySelectorAll('.p_dontCloseSettingsPanel');

        for(var i=0; i < dontCloseSettingsPanelNodes.length; i++) {

            if(dontCloseSettingsPanelNodes[i] == event.target || dontCloseSettingsPanelNodes[i].contains(event.target)) {
                return false;
            }
        }

        return ui.isSettingsPanelOpen();

    }


    function getControlBarShowHandler(ui) {
        var acting = false;
        var resetActing = function() {
            acting = false;
        };

        var pressed = false;
        var x;
        var y;

        var previousMouseMove;
        var throttleShow = function(event) {
            if (!acting) {
                ui.showControlBar();

                if (ui.player.isPlaying360) {
                    ui.player.threeSixty.showCompass();
                }

                ui.resetIdleTimeout(event);
                acting = true;
                setTimeout(resetActing, DUPLICATE_EVENT_TIMEOUT);
            }

        };

        var throttleHide = function() {
            if (!acting) {
                ui.hideControlBar();
                acting = true;
                setTimeout(resetActing, DUPLICATE_EVENT_TIMEOUT);
            }
        };

        return function(event) {
            ui.isControlsInteraction = (!(event.target == ui.player.mediaPlayer || Utils.hasClass(event.target,"notInteractiveContent")));
            if (event.type == 'keyup') {
                Utils.className(document.body,"focusEnabled");

                if (!Utils.hasClass(event.target, 'p_noShowOnKey')) {
                    throttleShow(event);
                }

                return;
            }

            if (!ui.isControlsInteraction && !ui.inPrePlayState && !ui.miniModeEnabled && ui.config.fullscreen.dblclick && event.type == "dblclick") {
                ui.player.toggleFullscreen(event.type);
                return;
            }

            if ( (!ui.inPrePlayState && !ui.player.outOfControl) || (ui.inPrePlayState && ui.player.isFullScreen) ) {
                if (event.type == "pointerdown" || event.type == "mousedown" || event.type == "touchstart") {
                    if (ui.player.isPlaying360) {
                        pressed = true;
                        x = event.type == "touchstart" ? event.changedTouches[0].clientX : event.clientX;
                        y = event.type == "touchstart" ? event.changedTouches[0].clientY : event.clientY;
                    }
                    return;
                }

                if (!pressed && (event.type == "mousemove" || (event.type == "pointermove" && event.pointerType == "mouse"))) {

                    // Some devices/UAs will give you mousemoves but nothing has changed.
                    if (previousMouseMove && previousMouseMove.clientX == event.clientX && previousMouseMove.clientY == event.clientY) {
                        if (DEBUG_FULL) {
                            console.log('Supressing mousemove as cursor has not moved.');
                        }
                        return;
                    }

                    previousMouseMove = event;

                    if (ui.config.controls.activeStartsAt || ui.player.isPlaying360) {
                        var perc = event.clientY / ui.container.clientHeight;
                        var limit = ui.config.controls.activeStartsAt ? ui.config.controls.activeStartsAt : 0.8;
                        if (perc < limit) {
                            //Ignore all mouse movements if the active
                            //mouse area has been reduced
                            return;
                        }
                    }
                    throttleShow(event);
                    return;
                }

                if (event.type == "pointerup" || event.type == "mouseup" || event.type == "touchend") {

                    pressed = false;

                    if(shouldCloseSettingsPanel(ui, event)) {
                        ui.closeSettingsPanels();
                        return;
                    }

                    var nx = event.type == "touchend" ? event.changedTouches[0].clientX : event.clientX;
                    var ny = event.type == "touchend" ? event.changedTouches[0].clientY : event.clientY;

                    if (!ui.player.isPlaying360 || (Math.abs(nx - x) < 10) && (Math.abs(ny - y) < 10)) {
                        if (ui.controls.visible && !ui.isControlsInteraction  && !ui.forcedControlsInteraction) {
                            throttleHide();
                        } else if (!ui.isControlsInteraction) {
                            throttleShow(event);
                        }
                    }

                }
            }
        };
    }



    function getTogglePlay(ui) {
        return Utils.getActionFn(ui.togglePlay);
    }

    function getCtaPlay(ui) {
        return Utils.getActionFn(function(actionType) {
            if (DEBUG_FULL) {
                console.log('cta play');
            }
            // time is meaningless on the CTA as it's not the startTime
            ui.player.trackAction('call_to_action', actionType,{time:false});
            ui.player.requestGuidanceAndPlay(false,true);
            if (Device.trident) {
                // SMPHTML-1301
                setTimeout(function() {
                               ui.playPauseButton.focus();
                               ui.hideControlBar();
                               removeFocusEnabled();
                           },100);
            }
        });
    }

    function getGuidanceHide(ui) {
        return Utils.getActionFn(function() {
            ui.eventCallbacks.guidanceHide();
        });
    }

    function getLinkGuidance(ui) {
        return Utils.getActionFn(function(actionType) {
            var guidance = ui.player.config.guidance;
            if (!guidance.isGuidanceLocked && guidance.hasGuidancePIN) {
                //If the player is not locked and a PIN is set then lock the player
                ui.player.trackAction("padlock_lock_guidance", actionType);

                ui.pGuidance.guidanceLock();
            } else {
                ui.player.trackAction("padlock_show_guidance", actionType);
                //Force new PIN setup
                ui.player.guidanceShow(true);
            }
        });
    }

    function getToggleFullscreen(ui) {
        return Utils.getActionFn(function(actionType) {
                        var action =  ui.player.isFullScreen ? 'exit_full_screen' : 'enter_full_screen';
                        ui.player.toggleFullscreen(actionType);
                        setTimeout(ui.focusPlayPauseButton,20);
                        ui.player.trackAction(action, actionType);
                    });
    }

    function getToggleChromecastButton(ui) {
        return Utils.getActionFn(function(actionType) {
           ui.player.Chromecast.toggle();
           var statsReport = ui.player.Chromecast.isAttemptingToCast ? 'attempt_cast_mode' : 'exit_cast_mode';
           ui.player.trackAction(statsReport, actionType);

           testButton(ui.chromecastButton,"p_chromecastButton p_controlBarButton_on", "p_chromecastButton",Language.toolTipStopChromecast,Language.toolTipChromecast, ui.player.Chromecast.isCasting || ui.player.Chromecast.isAttemptingToCast);

        });
    }

    function getTogglePiPButton(ui) {
        return Utils.getActionFn(function(actionType) {
            var statsReport = (ui.pIp.isPlayingInPicture() ? 'exit_picture_in_picture_mode' : 'enter_picture_in_picture_mode');
            ui.pIp.toggle();
            ui.player.trackAction(statsReport, actionType);

            testButton(ui.pIpButton,"p_picInPicButton p_controlBarButton_on", "p_picInPicButton",Language.toolTipStopPicInPic,Language.toolTipPicInPic);
        });
    }

    function getEmbedFunction(ui) {
        return Utils.getActionFn(function(actionType) {
                               ui.player.dispatch({type:"embed"});
                               ui.player.pause();
                               ui.player.minimise();
                               ui.player.trackAction('embed', actionType);
                    });
    }

    function updateMiniModeClasses(ui) {

        var add = "";
        if (ui.miniModeEnabled) {
            add = "minimode nofullscreen";
        } else {
            if (!ui.config.fullscreen.enabled) {
                add = "nofullscreen";
            }
        }
        Utils.className(document.body,add,"minimode nofullscreen");

    }

    UI.prototype = Utils.object(BaseUI.prototype);

    UI.prototype.initialised = false;
    UI.prototype.resetIdleTimeout = function(event) {
        var ui = this;
        clearTimeout(ui.idleTimeoutInterval);
        var type = event && event.type.substring(0,5);
        var timeout = (event && ((type=="point" && event.pointerType!="mouse") || type=="touch")) ? ui.config.controls.timeoutTouch : ui.config.controls.timeout;
        if (!ui.player.Chromecast.isCasting && !ui.player.mediaEnded) {
            ui.idleTimeoutInterval = setTimeout(function() {
                ui.hideControlBar(false,type,event);
            }, timeout);
        }
    };
    UI.prototype.showPoster = function() {
        var ui = this;
        if (ui.enabled && ui.config.poster.enabled) {

            if (ui.config.poster.video && ui.player.playlist && ui.player.playlist.videoHoldingImage) {
                ui.container.style.backgroundPosition = "";
                ui.container.style.backgroundImage = "";
                if (!ui.videoHoldingImage) {
                    ui.videoHoldingImage = document.createElement('video');
                    ui.videoHoldingImage.autoplay=true;
                    ui.videoHoldingImage.muted=true;
                    ui.videoHoldingImage.loop=true;
                    ui.container.insertBefore(ui.videoHoldingImage,ui.container.firstChild);
                }
                ui.videoHoldingImage.poster = Utils.holdingImage(ui.player.playlist,ui.container, ui.config.poster);
                ui.videoHoldingImage.src=ui.player.playlist.videoHoldingImage;
                ui.videoHoldingImage.style.display="block";
                ui.videoHoldingImage.play();

            } else {
                if (ui.videoHoldingImage) {
                    ui.container.removeChild(ui.videoHoldingImage);
                    ui.videoHoldingImage = null;
                }
                ui.container.style.backgroundPosition = "";
                ui.container.style.backgroundImage = Utils.holdingImage(ui.player.playlist,ui.container, ui.config.poster);
            }
        }
    };
    UI.prototype.hidePoster = function() {
        var ui = this;
        ui.container.style.backgroundPosition = NO_POSTER;
        if (ui.videoHoldingImage) {
            ui.videoHoldingImage.pause();
            ui.videoHoldingImage.style.display="none";
        }
    };
    UI.prototype.isSettingsPanelOpen = function() {

        for(var i=0; i < this.settingsPanels.length; i++) {
            if(this.settingsPanels[i].isPanelOpen()) {
                return true;
            }
        }

        return false;

    };
    UI.prototype.closeSettingsPanels = function() {

        for(var i=0; i < this.settingsPanels.length; i++) {
            if(this.settingsPanels[i].isPanelOpen()) {
                this.settingsPanels[i].closePanel();
            }
        }

    };
    UI.prototype.resizeFixEnd = function(width) {
        var ui = this;
        if (width!==undefined && ( width!==ui.lastResizeWidth || Device.android ) ) {
            // SMPHTML-1391: On iPlayer pages the player width is always 100% on small mobile devices.
            // It needs to re-calculate the layout because the controlsHolder.clientWidth
            // changes when going fullscreen
            ui.updateLayout(width);
        }
        ui.lastResizeWidth=width;

        clearTimeout(ui.posterResizeTimer);
        ui.posterResizeTimer = setTimeout(function () {
            ui.container.style.backgroundImage = Utils.holdingImage(ui.player.playlist,ui.container, ui.config.poster);
           // XXX it might be worth using 2 images here so we can
           // do cross-fade or similar so we don't have the black
           // portion while it's doing a partial download, but
           // that's probably something for the long future.
        }, POSTER_RESIZE_DELAY);
        ui.player.Subtitles.resizeFixEnd();
        ui.spinner.resizeFixEnd();
        if (ui.showControlBarRequired) {
            ui.showControlBarRequired = false;
            showControlBarAfterFS(ui);
        }
        updateMiniModeClasses(ui);
    };
    UI.prototype.showCta = function() {
        var ui = this;

        BaseUI.prototype.showCta.call(this);
        if (ui.player.isAudio || ui.player.isThreeSixty) {
            ui.pIp.exitPicInPic();
        }
        if (ui.player.isFullScreen) {
            ui.showControlBar();
            ui.guidancePopUp();
            return;
        }
        if (ui.controls) {
            ui.closeSettingsPanels();
            ui.controls.visible = false;
            ui.controls.style.clip="rect(1px,1px,1px,1px)";
            ui.controls.style.display = "none";
            Utils.className(ui.container,"controlsFadedOut","controlsFadedIn");
        }
        if (ui.cta) {
            if (ui.enabled && ui.config.cta.enabled && !ui.inError) {
                ui.ctaVisible = true;
                ui.cta.style.display = "block";
                ui.guidanceOrWarning();
                ui.ctaUpdate();
            } else {
                ui.cta.style.display = "none";
                ui.guidance.style.display = "none";
            }
            // XXX should switch this to classes etc.
            ui.cta.style.visibility = ui.config.cta.visiblyHidden ? "hidden" : "visible";
            ui.guidance.style.visibility = ui.config.cta.visiblyHidden ? "hidden" : "visible";
            ui.hitArea.setAttribute("aria-hidden", "false");
        }
        ui.hideAllControls();
        document.body.style.cursor = 'default';

        Utils.className(document.body, 'cta');
        if (!ui.inError) {
            ui.player.dispatch({type:"showCta"});
        }

    };
    UI.prototype.ctaUpdate = function() {
        var ui = this;
        if (ui.player.playlist) {
            var title = Language.get("toolTipCTAPlay",{title:ui.player.playlist.title});
            if (ui.player.playlist.guidance) {
                title += ", "+ui.player.playlist.guidance;
            }
        } else {
            title = Language.toolTipPlay;
        }
        ui.cta.title = title;
        ui.cta.setAttribute("aria-label",title);
    };
    UI.prototype.hideCta = function() {
        var ui = this;
        BaseUI.prototype.hideCta.call(this);
        ui.ctaVisible = false;
        if (ui.cta) {
            if (!ui.guidanceTimeout) {
                ui.guidance.style.display = "none";
            }
            ui.cta.style.display = "none";
            ui.hitArea.setAttribute("aria-hidden", "true");
        }
        if (ui.config.controls.always || (ui.player.isAudio && !ui.config.allowAudioControlsToHide)) {
            ui.showControlBar();
        }
        Utils.className(document.body, '', 'cta');

    };
    UI.prototype.hitAreaUpdate = function() {
        var ui = this;
        if (ui.hitArea) {
            if (ui.player.playlist) {
                ui.hitArea.setAttribute('aria-label',  Language.get("toolTipFrameMedia",{title:ui.player.playlist.title}));
            }
        }
    };
    UI.prototype.updatePoster = function() {
        var ui = this;
        if (ui.container.style.backgroundPosition!==NO_POSTER) {
            ui.hidePoster();
            ui.showPoster();
        }
    };
    UI.prototype.hideEffects = function() {
        clearTimeout(sliderTimeout);
        clearTimeout(fadeTimeout);
        this.setSlideEffectVisibility(false);
        this.setZoomEffectVisibility(false);
    };
    UI.prototype.setZoomEffectVisibility = function(visible) {
        var zoomEffect = this.posterZoomImage;
        if (zoomEffect) {
            zoomEffect.style.display = Utils.noneOrBlock(visible);
        }
    };
    UI.prototype.setSlideEffectVisibility = function(visible) {
        var slideEffect =  this.slideEffectImageContainer;
        if (slideEffect) {
            slideEffect.style.display = Utils.noneOrBlock(visible);
        }
    };
    UI.prototype.zoomInPosterImage = function(effects) {
        var ui = this;
        var zoomScale = (typeof effects.scale != "undefined" ? effects.scale : 1.5);
        var zoomTime = (typeof effects.time != "undefined" ? effects.time : 1);

        ui.setSlideEffectVisibility(false);
        ui.updatePoster();

        ui.posterZoomImage.src = ui.getBackgroundImageUrl();
        Utils.deleteCssRules(ui.stylesheet, ['.zoomEffectTransition', '.zoomEffectScale']);

        ui.setZoomEffectVisibility(true);

        Utils.asyncDelay(zoomStyleFunction,[ui,zoomTime,zoomScale]);
    };
    UI.prototype.fadeInNewPosterImage = function(effects) {
        var ui = this;

        var fadeTime = ( effects.time !== undefined ? effects.time : 1 );

        ui.posterFadeEffectImage.src = ui.getBackgroundImageUrl();

        //we need to apply the zoom effect's scaling factor to the fade image to avoid jumping
        if (ui.posterZoomImage.style.display == 'block') {
            Utils.className(ui.posterFadeEffectImage, 'zoomEffectScale', 'noScale');
        } else {
            Utils.className(ui.posterFadeEffectImage, 'noScale', 'zoomEffectScale');
        }

        Utils.deleteCssRules(ui.stylesheet, ['fadeEffect']);
        ui.setSlideEffectVisibility(false);
        ui.setZoomEffectVisibility(false);

        ui.updatePoster();

        Utils.asyncDelay(fadeStyleFunction,[ui,fadeTime]);
    };
    UI.prototype.slideInNewPosterImage = function(effects) {
        var ui = this;

        Utils.deleteCssRules(ui.stylesheet, ['.slidingEffect']);
        var oldImage = ui.slideEffectImageContainer.firstChild;
        var newImage = ui.slideEffectImageContainer.lastChild;

        oldImage.src = ui.getBackgroundImageUrl();

        Utils.className(oldImage, 'p_onScreen', 'p_offScreenLeft p_offScreenRight');

        var slideTime = (effects.time !== undefined ? effects.time : 1) ;
        ui.stylesheet.insertRule('.slidingEffect {-webkit-transition: ' + slideTime + 's; -moz-transition-duration: ' + slideTime + 's; transition-duration: ' + slideTime + 's;}', 0);

        Utils.className(newImage, effects.leftToRight ? 'p_offScreenLeft' : 'p_offScreenRight','p_onScreen');

        //we need to apply the zoom effect's scaling factor to the
        //slide image to avoid jumping
        if (ui.posterZoomImage.style.display == 'block') {
            Utils.className(oldImage, 'zoomEffectScale', 'noScale');
        } else {
            Utils.className(oldImage, 'noScale', 'zoomEffectScale');
        }

        ui.updatePoster();

        newImage.src = ui.getBackgroundImageUrl();
        ui.setSlideEffectVisibility(true);

        Utils.asyncDelay(slideStyleFunction,[ui,newImage]);
    };
    UI.prototype.setCta = function(mediaState){
        var ui = this;
        var previousState = (mediaState === "video") ? "audio" : "video";
        Utils.className(document.body, mediaState, previousState);
        ui.updateCta(mediaState);
    };
    UI.prototype.updateCta = function(mediaState) {
        var ui = this;
        if (ui.config.cta.enabled) {
            var makeCtaDuration = ui.config.cta.mode == "duration" && ui.player.playlist && ui.player.playlist.programmeDuration !== "";
            if (!ui.cta) {
                ui.drawCta();
            }
            if (ui.cta) {
                if (ui.config.cta.custom) {
                    ui.cta.style.backgroundImage = "url(" + ui.config.cta.custom + ")";
                    // just removes so no new icon
                    updateExistingSvg(ui.cta);
                } else {
                    ui.cta.style.backgroundImage = "";
                }
            }
            // XXX do we really want to update the stylesheet every
            // time we update the CTA, rather than only when the
            // uiconfig changes?
            Utils.deleteCssRules(ui.stylesheet, ["p_cta", "p_padlock"]);
            // XXX this is no good, adding it to the
            // mediaContainer means that anything overlaid in the
            // mediaContainer - plugins etc. or the guidance block
            // which should not trigger the CTA will also
            // highlight the cta
            ui.stylesheet.insertRule(".p_cta:hover, .p_cta:focus, .mediaContainer:hover .p_cta { background-color: "+ui.config.colour+"; }",0);

            if (ui.config.cta.direction === 'rtl') {
                Utils.className(document.body, 'rtlCta');
            }

            // a custom cta sets a background image, so no need to add an svg as well
            if (ui.config.useHighResIcons && !ui.config.cta.custom) {
                if (ui.cta) {
                    // set a sensible default icon
                    var ctaIconName = getCtaIconName(this, mediaState === "audio");

                    var svgClasses = "p_ctaIcon";
                    if (makeCtaDuration) {
                        svgClasses += " p_hasDuration";
                    }
                    updateExistingSvg(ui.cta, ctaIconName, svgClasses);
                }
                ui.stylesheet.insertRule(".svg .p_cta:hover .p_ctaIcon, .focusEnabled.svg .p_cta:focus .p_ctaIcon { fill: "+ui.config.foreColour+"; }",0);
                ui.stylesheet.insertRule(".svg .mediaContainer:hover .p_cta .p_svg, .svg .p_cta:focus .p_svg { fill: "+ui.config.foreColour+"; }",0);
            }

            if (makeCtaDuration) {
                ui.ctaDuration.textContent = ui.player.playlist.programmeDuration;
                Utils.className(ui.cta, 'p_hasDuration font-family-sans');

                if (ui.config.useHighResIcons) {
                    ui.stylesheet.insertRule(".p_cta:hover .p_ctaDuration, .focusEnabled .p_cta:focus .p_ctaDuration { color: " + ui.config.foreColour + "; }",0);
                    ui.stylesheet.insertRule(".mediaContainer:hover .p_ctaDuration, .p_cta:focus .p_ctaDuration { color: " + ui.config.foreColour + "; }",0);
                }
            } else {
                ui.ctaDuration.textContent = "";
                Utils.className(ui.cta, '', 'p_hasDuration');
            }

            Utils.setOrUnsetClass(ui.cta, "p_iplayerIcon", ui.config.cta.iplayer);
        }
    };
    UI.prototype.updateGuidance = function() {
        var ui = this;

        if (ui.padlock && ui.player.config && ui.config.guidance.pinRequired) {
            if (ui.player.config.guidance && ui.player.config.guidance.isGuidanceLocked) {
                ui.padlock.className = "p_padlock p_button";
                ui.padlock.title = Language.guidanceStateOn1Text;
                if (ui.config.useHighResIcons) {
                    updateExistingSvg(ui.padlock,'padlock-locked');
                }
            } else {

                if (ui.player.config.guidance && ui.player.config.guidance.canPlay && ui.player.config.guidance.guidanceSkipped && !ui.player.config.under16) {
                    ui.padlock.style.display = "block";
                }

                ui.padlock.className = "p_padlock p_button p_padlock_unlocked";
                ui.padlock.title = Language.guidanceStateOff1Text;
                if (ui.config.useHighResIcons) {
                    updateExistingSvg(ui.padlock,'padlock-unlocked');
                }
            }
        }

    };

    UI.prototype.updateControlBarDisplayForOpenVolume = function() {
        var ui = this;

        ui.closeSettingsPanels();

        // time display
        var timeDisplayCovered = Utils.getOffset(ui.timeDisplay) < ui.volumeControl.getRight();
        if (timeDisplayCovered) {
            var rhsButtonCovered = false;
            var width = ui.volumeControl.getRight();
            // fullscreen button

            rhsButtonCovered = testButtonCovered(ui.fullscreenButton, rhsButtonCovered, width);
            rhsButtonCovered = testButtonCovered(ui.subtitlesButton, rhsButtonCovered, width);
            rhsButtonCovered = testButtonCovered(ui.playbackSettingsButton, rhsButtonCovered, width);
            rhsButtonCovered = testButtonCovered(ui.pIpButton, rhsButtonCovered, width);
            rhsButtonCovered = testButtonCovered(ui.chromecastButton, rhsButtonCovered, width);
            testButtonCovered(ui.embedButton, rhsButtonCovered, width);

            Utils.setOrUnsetClass(ui.timeDisplay, 'p_covered', timeDisplayCovered);
        }
    };

    UI.prototype.updateEffectsContainer = function() {
        var ui = this;
        var container = ui.posterEffectsContainer;
        if (ui.config.poster.effects) {
            if (!container) {
                ui.createPosterEffectsContainer();
            }
        } else {
            if (container) {
                container.parentNode.removeChild(container);
                ui.posterEffectsContainer = null;
            }
        }
    };
    UI.prototype.drawCta = function() {
        var ui = this;
        if (ui.enabled && ui.config.cta.enabled && !ui.cta) {
            var cta = createElement('button','p_button p_cta','<span class="p_hiddenElement"></span>',Language.toolTipPlay);

            ui.ctaDuration = createElement('span', 'p_ctaDuration');
            cta.appendChild(ui.ctaDuration);

            ui.container.appendChild(cta);
            Utils.multiAddEventListener(cta,"click mouseup", getCtaPlay(ui));
            cta.style.display = "none";
            ui.cta = cta;
            ui.drawHitArea();
            ui.updateCta();
        }
    };
    UI.prototype.drawGuidance = function() {
        var ui = this;
        ui.guidance = createElement('div','p_ctaGuidance p_guidance');

        ui.guidance.style.display = "none";

        var guidanceContainer = createElement('div','p_guidanceContainer');
        ui.guidanceBox = createElement('span','p_guidanceText');
        ui.guidanceBox.style.marginLeft = '25px';

        var guidanceHolder = createElement('div','p_guidanceHolder');

        // always create a G with CSS circle
        // we will use css to disable it if not needed
        var circle = createElement('span','p_guidanceFallback');
        var circleText = createElement('span','p_guidanceFallbackText');
        circle.appendChild(circleText);
        circleText.textContent = "G";
        guidanceHolder.appendChild(circle);

        if (ui.config.useHighResIcons) {
            // create an svg icon
            var icon = Utils.generateSVG(44,44,'guidance','p_guidanceIcon');
            guidanceHolder.appendChild(icon);
        }

        guidanceContainer.appendChild(guidanceHolder);
        guidanceHolder.appendChild(ui.guidanceBox);

        ui.guidance.appendChild(guidanceContainer);

        ui.padlock = document.createElement('button');
        Utils.multiAddEventListener(ui.padlock,"mouseup touchend click", getLinkGuidance(ui));
        ui.guidance.appendChild(ui.padlock);

        ui.guidanceClose = createElement('span','guidanceClose');
        Utils.multiAddEventListener(ui.guidanceClose,"mouseup touchend click", getGuidanceHide(ui) );
        ui.guidanceClose.style.display = 'none';
        ui.guidance.appendChild(ui.guidanceClose);

        if (ui.config.useHighResIcons) {
            icon = Utils.generateSVG(44,44,'cross','p_crossIcon');
            ui.guidanceClose.appendChild(icon);
        }

        // XXX this needs careful consideration as it's breaking
        // out of container... should get to body in current code,
        // should we do this better?
        ui.container.parentNode.appendChild(ui.guidance);
        ui.updateGuidance();
    };
    UI.prototype.checkIfCanDisplaySeekBar = function() {
        var ui = this;
        if (ui.progressBar) {
            var previousDisplayMode = ui.progressBar.isVisible();
            var newDisplayMode = ui.player.timeHelper.drawSeekBar && (safeLower(ui.config.controls.mode) != "controls");
            if (previousDisplayMode != newDisplayMode) {
                ui.progressBar.show();
                ui.markersUI.updateMarkers();
                ui.updateGradientAndControlsPosition();
                ui.dispatchUIInfo();
            }
            Utils.setOrUnsetClassOnlyAfterCheck(ui.container, "noSeekingBar", !newDisplayMode, newDisplayMode);
        }
    };
    UI.prototype.displayCover = function() {
        var ui = this;
        if (ui.player.els) {
            // MP-2933: Force displayCover if the container ratio is within 5% of the source ratio, or if container is 0x0 (during fullscreen toggle) then preserve state
            var videoRatio = ui.player.els.video.videoWidth / ui.player.els.video.videoHeight;
            if (isNaN(videoRatio)) {
                videoRatio=16/9;
            }
            var forceCover = Math.abs( 1 - window.innerWidth / (window.innerHeight*videoRatio) ) < 0.05 || ( window.innerWidth===0 && window.innerHeight===0 && Utils.hasClass(document.body,"displayCover")  );
        }
        Utils.className(document.body, '','videoPositionTop videoPositionBottom');
        if (forceCover || ui.config.displayCover) {
            Utils.className(document.body, 'displayCover');
        } else {
            Utils.className(document.body, '', 'displayCover');
            if (ui.config.videoPosition=="top") {
                Utils.className(document.body, 'videoPositionTop');
            } else {
                if (ui.config.videoPosition=="bottom") {
                    Utils.className(document.body, 'videoPositionBottom');
                }
            }
        }
    };
    UI.prototype.initialise = function() {
        var ui = this;

        BaseUI.prototype.initialise.call(this);

        ui.markersUI.container = ui.container = ui.player.mediaContainer;

        ui.playbackSettingsPanel={
            checkQualityAvailability:emptyFunction,
            updateLanguage:emptyFunction,
            showOrHideContinuousPlaySetting:emptyFunction,
            setAutoplay:emptyFunction
        };

        ui.progressBar = new ProgressBar(ui);
        ui.spinner = new Spinner(ui);
        ui.errorDialog = new ErrorDialog(ui);
        ui.volumeControl = new VolumeControl(ui);

        ui.enabled = true;

        ui.previousPosterWidth = 0;

        ui.eventCallbacks = ui_getCallbackObject(ui);
        ui.eventArray = [ui.eventCallbacks, ui.progressBar.getEventCallbacks(), ui.spinner.getEventCallbacks(), ui.errorDialog.getEventCallbacks(), this.volumeControl.getEventCallbacks()];


        if (Device.iPhoneOutOfPagePlayback) {
            Utils.multiAddEventListener(ui.player.els.video, "webkitfullscreenchange webkitendfullscreen", handleIphoneFullscreen(ui));
        }

        if (Device.iPhoneIos10){
            Utils.className(document.body, "iPhoneIos10", "");
        }
        if (Device.iPhoneIos11orGreater){
            Utils.className(document.body, "iPhoneIos11orGreater", "");
        }

        if (Device.preferHls){
            Utils.className(document.body, "preferHls", "");
        }

        //SMPHTML-791
        window.addEventListener('touchstart', function onFirstTouch() {
            ui.needStopTouch = true;
            window.removeEventListener('touchstart', onFirstTouch);
        },{passive:true, once:true});

        appendChildren(ui.container,ui.spinner.getDomNodes());

        // XXX what's the point of checking if there's a container
        // here, how could there not be, what would happen with
        // the player?
        if (ui.container) {
            ui.showPoster();
            if(ui.config.buffer.forceShow) {
                ui.spinner.startBufferTimer();
            }
            ui.drawCta();
            ui.drawGuidance();
            ui.drawControlBar();
            ui.addControlBarListeners();
            ui.displayCover();
            updateMiniModeClasses(ui);
            if (ui.config.poster.effects) {
                ui.createPosterEffectsContainer();
            }


        }

        ui.player.Subtitles.updateConfig(ui.config);

        ui.initialised = true;
    };

    UI.prototype.updateStyles = function() {

        BaseUI.prototype.updateStyles.call(this);

    };

    UI.prototype.updateControls = function() {
        var ui = this;

        Utils.deleteCssRules(ui.stylesheet, [".nonPointerFocus .p_toggle:focus", ".nonPointerFocus #p_subtitleSettingsContainer .p_subtitleSizeButton:focus", ".p_toggleOn .p_toggleSlot", ".p_toggleSlider .p_tick","p_selected_indicator","p_controlBarButton", "p_sliderControls:hover", ".minimode .mediaContainer", ".cta.minimode .mediaContainer"]);
        ui.stylesheet.insertRule(".p_controlBarButton.p_buttonHover, .p_controlBarButton.p_settingsPanelOpen, .nonPointerFocus .p_controlBarButton:focus, .p_selected_indicator { background-color: " + ui.config.colour + "; }",0);
        if (ui.config.useHighResIcons) {
           ui.stylesheet.insertRule(".svg .p_controlBarButton.p_buttonHover .p_svg, .svg .p_controlBarButton.p_settingsPanelOpen .p_svg, .nonPointerFocus.svg .p_controlBarButton:focus .p_svg { fill: " + ui.config.foreColour + "; }",0);
        }

        ui.stylesheet.insertRule(".minimode .mediaContainer { background-color: "+ui.config.miniMode.backgroundColour+"; }",0);
        ui.stylesheet.insertRule(".cta.minimode .mediaContainer { background-color: "+ui.config.cta.backgroundColour+"; }",0);

        if(ui.config.colour == '#222222') {
            ui.stylesheet.insertRule(".p_toggleOn .p_toggleSlot { background-color: #000; border-color: #fff; }", 0);
        } else {
            ui.stylesheet.insertRule(".p_toggleOn .p_toggleSlot { background-color: " + ui.config.colour + "; border-color: " + ui.config.colour + "; }", 0);
        }

        var sliderBackground = ui.config.accessibility.enhanceBrightColoursContrast ? "#191919" : "#FFF";
        ui.stylesheet.insertRule(".p_toggleOn .p_toggleSlider { background-color: " + sliderBackground + ";}", 0);
        ui.stylesheet.insertRule(".p_toggleSlider .p_tick { border-color: " + ui.config.colour + "; }", 0);
        ui.stylesheet.insertRule(".nonPointerFocus #p_subtitleSettingsContainer .p_subtitleSizeButton:focus { background-color: " + ui.config.colour + "; }", 0);
        ui.stylesheet.insertRule(".nonPointerFocus .p_toggle:focus { -webkit-box-shadow: inset 0 0 0 2px " + ui.config.colour + "; box-shadow: inset 0 0 0 2px " + ui.config.colour + ";}", 0);

        ui.stylesheet.insertRule(".nonPointerFocus #p_qualityPanelFirstRow:focus, .nonPointerFocus #p_qualityPanelMediumRow:focus, .nonPointerFocus #p_qualityPanelHighRow:focus { -webkit-box-shadow: inset 0 0 0 2px " + ui.config.playbackSettingsPanel.highlightMenuColour + "; box-shadow: inset 0 0 0 2px " + ui.config.playbackSettingsPanel.highlightMenuColour + ";}", 0);
        ui.stylesheet.insertRule(".nonPointerFocus #p_qualityRow:focus { -webkit-box-shadow: inset 0 0 0 2px " + ui.config.playbackSettingsPanel.highlightMenuColour + "; box-shadow: inset 0 0 0 2px " + ui.config.playbackSettingsPanel.highlightMenuColour + ";}", 0);

        if (safeLower(ui.config.controls.mode) == "seekbar") {
            if (ui.controlsHolder) {
                ui.closeSettingsPanels();
                ui.controlsHolder.style.display = "none";
                Utils.className(ui.controls,"p_noControlBar");
            }
        } else {
            if (ui.controlsHolder) {
                ui.controlsHolder.style.display = "block";
                Utils.className(ui.controls,"","p_noControlBar");
            }
            if (ui.progressBar) {
                if(safeLower(ui.config.controls.mode) == "controls") {
                    ui.progressBar.hide();
                } else {
                    ui.progressBar.show();
                }
            }
        }

        Utils.setOrUnsetClass(ui.controlsHolder, 'p_noVolume',!ui.config.controls.volumeSlider);

        // do we need to pass the type here?
        testButton(ui.playPauseButton,"p_pauseButton",ui.playClassName,Language.toolTipPause,Language.toolTipPlay,(ui.player.playingState == "playing"));
    };

    UI.prototype.createPosterEffectsContainer = function() {
        var ui = this;
        if (!ui.posterEffectsContainer) {
            ui.posterEffectsContainer = createElement('div','p_posterEffectsContainer');
            // XXX is this right what's happening with position here?
            // XX unprefixed?
            ui.posterZoomImage = createElement('img','zoomEffectScale zoomEffectTransition');
            ui.posterEffectsContainer.appendChild( ui.posterZoomImage);

            //Sliding effect
            ui.slideEffectImageContainer = document.createElement('div');
            ui.slideEffectImageContainer.appendChild(createElement('img','slidingEffect .p_oldSlideImage'));
            ui.slideEffectImageContainer.appendChild(createElement('img','slidingEffect .p_newSlideImage'));
            ui.posterEffectsContainer.appendChild(ui.slideEffectImageContainer);
            ui.posterFadeEffectImage = createElement('img','fadeEffect');
            ui.posterEffectsContainer.appendChild(ui.posterFadeEffectImage);
            ui.container.insertBefore(ui.posterEffectsContainer,ui.hitArea);
        }
    };
    UI.prototype.updateConfig = function(config, suppressConfigDistribution) {
        var ui = this;
        var uiConfigToSendToBump = {};
        var count = 0;
        var subsOffsetChanged;
        var subsOffsetFound = false;
        var yOffset = ui.config.subtitles.yOffset;
        for (var i in config) {
            if (config.hasOwnProperty(i)) {
                count++;
                if (i=="subtitles") {
                    for (var j in config.subtitles) {
                        if (j!="yOffset") {
                            count++;
                        } else {
                            subsOffsetFound = true;
                            subsOffsetChanged = (config.subtitles.yOffset!=yOffset && (!isNaN(yOffset) || !isNaN(config.subtitles.yOffset)));
                        }
                    }
                }
            }
        }
        // if there's no change, or the only change is subtitles
        // just do that (or nothing)
        if (count===0 || (count==1 && subsOffsetFound)) {
            if (subsOffsetChanged) {
                ui.config.subtitles.yOffset = config.subtitles.yOffset;
                ui.player.Subtitles.updateConfig(ui.config);
            }
            return;
        }

        if(config.subtitles && (ui.config.subtitles.sizeAdjustment != config.subtitles.sizeAdjustment)) {
            uiConfigToSendToBump.subtitles = {
                sizeAdjustment: config.subtitles.sizeAdjustment
            };
        }

        var type = ui.player.playlistHasAudio ? 'audio' : 'video';


        var previousAlways = ui.config.controls.always;

        var configChanged = BaseUI.prototype.updateConfig.call(this, config);

        if(!configChanged) {
            return;
        }

        ui.player.Subtitles.updateConfig(ui.config);

        ui.spinner.updateConfig(ui.config);

        ui.player.Chromecast.updateConfig(ui.config);


        ui.updatePoster();
        ui.errorDialog.updateErrorDialog();
        ui.updateControls();
        ui.updateCta(type);
        ui.updateGuidance();
        ui.updateEffectsContainer();
        ui.displayCover();

        if (ui.inPrePlayState) {
            ui.showCta();
        } else {
            ui.hideCta();
            if (previousAlways && ui.config.controls.always === false && !(!ui.config.allowAudioControlsToHide && (ui.miniModeEnabled || ui.player.isAudio))) {
                ui.hideControlBar(true);
            }
        }

        if (ui.controls) {
            if (!ui.config.controls.enabled) {
                ui.closeSettingsPanels();
                ui.controls.visible = false;
                ui.controls.style.display = "none";
                ui.gradientLayer.style.display = "none";
                ui.gradientBottomFiller.style.display = "none";
                Utils.className(ui.container,"controlsFadedOut","controlsFadedIn");
            } else {
                ui.gradientLayer.style.display = "block";
                ui.gradientBottomFiller.style.display = "block";
            }
        }

        updateMiniModeClasses(ui);

        if (ui.miniModeEnabled) {
            if (ui.player.mediaPlayer && ui.player.mediaPlayer.style.left == "0px") {
                ui.player.mediaPlayer.style.left = HIDDEN_PLAYER_MINIMODE;
            }
        } else {
            if (ui.player.mediaPlayer && ui.player.mediaPlayer.style.left == HIDDEN_PLAYER_MINIMODE) {
                ui.player.mediaPlayer.style.left = "0px";
            }
        }

        ui.checkIfCanDisplaySeekBar();

        ui.updateLayout();

        ui.playbackSettingsPanel.showOrHideContinuousPlaySetting(ui.config.playbackSettingsPanel.continuousPlaySetting);


        ui.dispatchUIInfo();

        if(!suppressConfigDistribution && !Utils.isObjectEmpty(uiConfigToSendToBump)) {
            ui.player.dispatch({
                type: "uiConfigFromPlayer",
                config: uiConfigToSendToBump
            });
        }

    };
    UI.prototype.addControlBarListeners = function() {
        var ui = this;
        if (!ui.listenersAdded) {
            var controlBarShowHandler = getControlBarShowHandler(ui);
            if (window.PointerEvent) {
                // pointerdown needed to record the starting location for press
                Utils.multiAddEventListener(ui.container,"pointerdown pointermove pointerup dblclick",controlBarShowHandler);
                ui.container.addEventListener("pointerout", ui.fadeControlBar);
            } else {
                Utils.multiAddEventListener(ui.container,"mousedown mouseleave touchmove touchstart touchend dblclick",controlBarShowHandler, true);
                Utils.multiAddEventListener(document, "mousemove mouseup", controlBarShowHandler, true);
                if (!Device.windowsPhone){
                    // XXX review this, are there winphones
                    // without pointerEvents and why if there are
                    // is the previous pointerout fine in those
                    // where it does exist?
                    ui.container.addEventListener("mouseout", ui.fadeControlBar);
                }
            }
            document.addEventListener("keyup", controlBarShowHandler, true);
            ui.listenersAdded = true;
        }
    };



    UI.prototype.updateTimeDisplay = function(time) {
        var ui = this;

        if (ui.currentTime && ui.duration) {
            var timeObj = ui.player.timeHelper.getTimeInfoToDisplay(time);
            var durationString = ui.duration.textContent = timeObj.duration;
            ui.currentTime.textContent = timeObj.currentTime;
            ui.timeDisplaySeparator.style.display = (durationString === "") ? "none" : "";
        }
    };
    UI.prototype.updateDisplayedProgress = function(time, addTip) {
        var ui = this;
        var displayFraction = ui.player.timeHelper.timeToPercent(time);

        ui.progressBar.updateProgressBar(displayFraction, addTip);
        ui.updateTimeDisplay(time);
        ui.markersUI.fillChapters(time);
    };
    UI.prototype.timeUpdate = function(force) {
        var ui = this;
        if (force || (!ui.player.isSeeking && ui.controls && ui.controls.visible)) {
            //ui.progressBar.updateProgressBar(ui.player.timeHelper.percent, ui.seekThumbHasFocus && !ui.seekOver);
            ui.updateTimeDisplay();
            ui.markersUI.testDrawMarkers(force);
        }
        if (ui.config.markers.reportProgress) {
            ui.markersUI.reportProgress();
        }
    };


    UI.prototype.drawHitArea = function() {
        var ui = this;
        var touchThenMove = false;

        var moveFunction = function() {
            touchThenMove = true;
        };
        var hitFunction = function(event) {

            var canPlayFromTouch = ( (event.type == "touchend" && !touchThenMove) || (event.type == "pointerup" && event.pointerType == "touch") );

            var isTrippleTap = ((event.type === "touchstart") && (event.targetTouches.length === 3));

            if (event.type == "touchstart" || (event.type == "pointerdown" && event.pointerType !== "mouse")) {
                ui.hitArea.addEventListener("pointermove",moveFunction);
                ui.hitArea.addEventListener("touchmove",moveFunction);
                touchThenMove = isTrippleTap;
            }

            if ((event.type == "touchend" && event.touches.length === 0) || event.type == "pointerup" || event.type == "pointerout") {
                ui.hitArea.removeEventListener("pointermove",moveFunction);
                ui.hitArea.removeEventListener("touchmove",moveFunction);
                touchThenMove = false;
            }


            if (ui.ctaVisible && ui.config.cta.enabled  && (canPlayFromTouch || event.type == "mouseup" || event.type == "click" || (event.type == "pointerup" && event.pointerType == "mouse"))) {

                if (event.button && event.button !== 0) {
                    return;
                }

                ui.player.trackAction('call_to_action_background', Utils.getActionType(event), {time:false});
                ui.player.requestGuidanceAndPlay();
            }
        };

        ui.hitArea = document.createElement('div');
        ui.hitArea.className = "p_accessibleHitArea notInteractiveContent";
        ui.hitArea.setAttribute('role','img');
        ui.container.appendChild(ui.hitArea);

        if (window.PointerEvent) {
            Utils.multiAddEventListener(ui.hitArea,"pointerup pointerdown", hitFunction);
        } else {
            Utils.multiAddEventListener(ui.hitArea,"mouseup touchstart touchend touchmove",hitFunction);
        }
    };
    UI.prototype.drawControlBar = function() {
        var ui = this;
        if (ui.enabled && ui.config.controls.enabled && !ui.controls) {

            ui.gradientLayer = createElement('div','p_gradientLayer');
            ui.gradientBottomFiller = createElement('div','p_gradientBottomfiller');

            // ideally better not to use childNodes
            // be sure that DOM elements are positioned after the flash container
            ui.container.insertBefore(ui.gradientLayer, ui.container.childNodes[2]);
            ui.container.insertBefore(ui.gradientBottomFiller, ui.container.childNodes[3]);

            ui.controls = createElement('div','p_playerControls');
            ui.controlsHolder = createElement('div','p_playerControlBarHolder');
            ui.controls.appendChild(ui.controlsHolder);

            ui.chapterMarkersHolder = createElement('div','p_chapterMarkersHolder');
            ui.controls.appendChild(ui.chapterMarkersHolder);

            ui.markersUI.markersHolder = ui.chapterMarkersHolder;

            appendChildren(ui.controls,ui.progressBar.getDomNodes());

            ui.timeDisplay = createElement('div','p_timeDisplay');
            ui.timeDisplay.setAttribute('aria-hidden', true);
            ui.timeDisplay.setAttribute('aria-live', 'off');
            ui.timeDisplay.setAttribute('aria-role', 'timer');

            ui.timeDisplaySeparator = createElement('span','p_timeSeparator','/');

            ui.currentTime = createElement('span','p_time');
            ui.duration = createElement('span','p_time p_duration');
            ui.timeDisplay.appendChild(ui.currentTime);
            ui.timeDisplay.appendChild(ui.timeDisplaySeparator);
            ui.timeDisplay.appendChild(ui.duration);

            ui.playPauseButton = getButton(ui.playClassName,getTogglePlay(ui),Language.toolTipPlay,Language.toolTipPlay,ui,false,'play');

            ui.pIpButton = getButton("p_picInPicButton",getTogglePiPButton(ui),Language.toolTipPicInPic,Language.toolTipPicInPic,ui,true, 'picInPic' );

            ui.chromecastButton = getButton("p_chromecastButton",getToggleChromecastButton(ui),Language.toolTipChromecast,Language.toolTipChromecast,ui,true, ( ui.config.controls.chromecastMode !== 'catcast' ) ? 'chromecast' : 'catcast');

            ui.subtitleSettingsPanel = new SubtitleSettingsPanel(ui, getButton);
            ui.settingsPanels.push(ui.subtitleSettingsPanel);

            ui.subtitlesButton = ui.subtitleSettingsPanel.getOpenCloseButton();

            ui.playbackSettingsPanel = new PlaybackSettingsPanel(ui, getButton);
            ui.settingsPanels.push(ui.playbackSettingsPanel);

            ui.playbackSettingsButton = ui.playbackSettingsPanel.getOpenCloseButton();

            ui.embedButton = getButton("p_embedButton",getEmbedFunction(ui),Language.toolTipEmbed,Language.toolTipEmbed,ui,false,'embed');

            ui.updateControls();
            ui.controlBarFiller = createElement('div','p_controlBarFiller');
            if (!ui.config.controls.volumeSlider) {
                Utils.className(ui.controlBarFiller, 'p_noVolume');
            }

            ui.controlsHolder.appendChild(ui.playPauseButton);

            //ADD VOLUME
            appendChildren(ui.controlsHolder,ui.volumeControl.getDomNodes());

            ui.controlsHolder.appendChild(ui.controlBarFiller);
            ui.controlBarFiller.appendChild(ui.timeDisplay);

            ui.fullscreenButton = getButton("p_fullscreenButton",getToggleFullscreen(ui),Language.toolTipEnterFullScreen,Language.toolTipEnterFullScreen,ui,false,'fullscreen-enter');
            ui.controlsHolder.appendChild(ui.fullscreenButton);
            ui.controlsHolder.appendChild(ui.subtitlesButton);
            ui.controlsHolder.appendChild(ui.subtitleSettingsPanel.getSubsSettingsContainer());
            ui.controlsHolder.appendChild(ui.playbackSettingsButton);
            ui.controlsHolder.appendChild(ui.playbackSettingsPanel.getPanel());
            ui.controlsHolder.appendChild(ui.chromecastButton);
            ui.controlsHolder.appendChild(ui.pIpButton);
            ui.controlsHolder.appendChild(ui.embedButton);
            ui.container.appendChild(ui.controls);
            ui.hideControlBar();
            ui.controls.style.display = "none";
            Utils.className(ui.container,"controlsFadedOut","controlsFadedIn");
            ui.updateLayout(ui.container.clientWidth);
        }
    };
    UI.prototype.updateGradientAndControlsPosition = function(){
        var ui = this;
        if (ui.player.isFullScreen && ui.controls.visible && ui.enabled ) {
            //  we should also probably make all this only
            //  update when resizing rather than all the time,
            //  getting clientX is expensive.
            var clientWidth = window.innerWidth;
            var clientHeight = window.innerHeight;
            var clientRatio = clientHeight/clientWidth;
            var sixteenByNineRatio = 0.5625;
            var fadeHeight = 148;
            var gradientFillerHeight = "3.5625%";
            var barHeightPercent = "3.5625%";

            // iPhone 5 and iPhone SE need additional margin otherwise
            // apple navigation bar when popup covers the SMP
            // controls, audio on iOS 9 need it too SMPHTML-1110
            // SMPHTML-240
            var needsBiggerMargin = (Device.iPhoneOutOfPagePlayback || Device.iPhoneNeedFullScreenMarginButton);

            if (clientRatio <= sixteenByNineRatio || ui.player.isPlaying360) {
                // Longer or equal to 16:9 (Side black bars) or full screen 360
                if (needsBiggerMargin) {
                    barHeightPercent = "14%";
                    gradientFillerHeight = "14%"; //((14 * clientHeight) / 100)+"px;";
                }

            } else {
                // Taller than 16:9 (Top/bottom black bars)
                // the 3.5625% of the iframe height in pixels
                var pixelsSupplement = Math.ceil(3.5625 / 100 * clientHeight);
                var videoHeightWithoutBars = clientWidth * sixteenByNineRatio;
                var barHeight = Math.floor((clientHeight - videoHeightWithoutBars)/2);

                // calculating if the control bar plus the 3.5625% of
                // the iframe height fits in the black bar
                var notEnoughSpaceForControlsOnBlackBar = (barHeight < (pixelsSupplement + fadeHeight));

                if (notEnoughSpaceForControlsOnBlackBar || needsBiggerMargin) {
                    gradientFillerHeight = (barHeight+1)+"px";
                    barHeightPercent= (barHeight+1)+"px";
                }

            }

            Utils.className(ui.controls,"updatedFullscreenPosition");
            Utils.className(ui.gradientLayer,"updatedFullscreenPosition");
            ui.stylesheet.insertRule(" .p_gradientBottomfiller { height:"+gradientFillerHeight+"; }", ui.stylesheet.cssRules.length);
            ui.stylesheet.insertRule(" .updatedFullscreenPosition { bottom:"+barHeightPercent+"; }", ui.stylesheet.cssRules.length);
        }
    };

    UI.prototype.hideAllControls = function(always,type) {
        var ui = this;

        if (ui.player.isPlaying360) {
            ui.player.threeSixty.hideCompass();
        }
        ui.hideControlBar(always,type);
    };

    UI.prototype.hideControlBar = function(always,type,event) {
        var ui = this;
        if (ui.controls) {
            if (!always) {
                if ( (!ui.controls.visible || ui.config.controls.always || (!ui.config.allowAudioControlsToHide && (ui.miniModeEnabled || ui.player.isAudio))) || ui.player.isSeeking || (ui.player.mediaEnded && ui.config.controls.availableOnMediaEnded)) {
                    return;
                }

                var pointerTypeTouch = false;
                if (event && event.pointerType === "touch") {
                    pointerTypeTouch = true;
                }

                // SMPHTML-1102: Don't hide if controls have hover
                // (unless it was triggered by a touch event)
                if ( ((isHovering(ui) || ui.subtitleSettingsPanel.hasFocus || ui.playbackSettingsPanel.hasFocus ) && (!type || type.substring(0,5)!="touch") && !pointerTypeTouch) || (ui.isControlsInteraction && type && type.substring(0,5)=="mouse") ){
                    if (DEBUG_FULL) { console.log("Not hiding due to:"+isHovering(ui)+"/"+ui.isControlsInteraction); }
                    return;
                }
            }

            if (!ui.player.isPlaying360 && ui.player.isFullScreen && Device.hideCursorInFullscreen) {
                document.body.style.cursor = 'none';
            }

            ui.volumeControl.closeVolumeControls();
            ui.controls.visible = false;

            Utils.asyncDelay(function(){
                Utils.className(ui.container,"controlsFadedOut","controlsFadedIn");
            });

            ui.closeSettingsPanels();

            removeFocusEnabled();
            clearTimeout(ui.controlbarTimer);
            ui.controlbarTimer = setTimeout(function() {
                ui.controls.style.clip = "rect(1px,1px,1px,1px)";
                ui.player.Subtitles.updatePositions();
            },800);
        }
        ui.markersUI.resetMarkerTip();
        ui.player.dispatch({type:"uiControlBarHidden"},true);

        //SMPHTML-791
        if (ui.needStopTouch) {
            Utils.className(ui.container,"stopTouch","");
        }

    };
    UI.prototype.showControlBar = function(fadedOut) {
        var ui = this;

        if (ui.active && (!Device.iPhoneOutOfPagePlayback || ui.player.isAudio) && !ui.player.Chromecast.isAttemptingToCast ) {
            if (!fadedOut) {
               clearTimeout(ui.idleTimeoutInterval);
            }
            clearTimeout(ui.controlbarTimer);
            if (!ui.controls || ui.controls.visible) {
                return;
            }
            if ( ui.enabled && ui.config.controls.enabled && (!ui.inPrePlayState || ui.player.isFullScreen) ) {
                if (DEBUG_FULL) {  console.log("showControlBar display is:"+ui.controls.style.display+", fadedOut is:"+fadedOut); }

                document.body.style.cursor = 'default';
                ui.controls.style.display = "block";
                ui.timeUpdate(true);

                if (fadedOut && !ui.miniModeEnabled) {
                    ui.controls.visible = false;
                    Utils.className(ui.container,"controlsFadedOut","controlsFadedIn");
                    ui.player.Subtitles.updatePositions();
                } else {
                    ui.controls.visible = true;
                    ui.updateGradientAndControlsPosition();
                    Utils.asyncDelay(function() { // this lets the style.display = block, above occur first.
                                         ui.controls.style.clip="";
                                         ui.player.Subtitles.updatePositions();
                                         Utils.className(ui.container,"controlsFadedIn","controlsFadedOut");
                                     });
                    ui.player.dispatch({type:"uiControlBarShown"},true);

                    //SMPHTML-791
                    if (ui.needStopTouch) {
                        setTimeout(function() {
                            Utils.className(ui.container,"","stopTouch");
                        }, 150);
                    }
                }
            }

            ui.markersUI.updateMarkers();

        }
    };
    UI.prototype.updateLayout = function(forceWidth) {
        var ui = this;
        if (ui.controlsHolder && ((ui.container.clientWidth > 0) || forceWidth)) {
            var buttons = (!ui.config.controls.volumeSlider ? 1 : 2);

            var w = ui.controlsHolder.clientWidth || ui.container.clientWidth;

            if (w <= 0) {
                w = forceWidth || 0;
            }

            var remainingSpace = w - (buttons * BUTTON_WIDTH1);

            buttons += ui.checkFullScreenButton(remainingSpace);
            remainingSpace = w - (buttons * BUTTON_WIDTH1);
            buttons += ui.checkSubtitlesButton(remainingSpace);
            remainingSpace = w - (buttons * BUTTON_WIDTH1);
            buttons += ui.checkPlaybackSettingsButton(remainingSpace);
            remainingSpace = w - (buttons * BUTTON_WIDTH1);
            buttons += ui.checkPiPButton(remainingSpace);
            remainingSpace = w - (buttons * BUTTON_WIDTH1);
            buttons += ui.checkChromecastButton(remainingSpace);
            remainingSpace = w - (buttons * BUTTON_WIDTH1);
            buttons += ui.checkEmbedButton(remainingSpace);

            ui.controlBarFillerWidth = w - (buttons * BUTTON_WIDTH1);

            if(ui.controlBarFillerWidth < 90) {
                ui.timeDisplay.style.display = 'none';
            } else {
                ui.timeDisplay.style.display = 'block';
            }

            ui.controlBarFiller.style.width = ui.controlBarFillerWidth +"px";
            ui.markersUI.updateMarkers();

            if (ui.volumeControl.isOpen()) {
                ui.updateControlBarDisplayForOpenVolume();
            }
            ui.updateGradientAndControlsPosition();

            ui.progressBar.updateProgressBar(ui.player.timeHelper.percent);

            ui.dispatchUIInfo();

        }
    };
    UI.prototype.checkFullScreenButton = function(remainingSpace) {
        var ui = this;
        var test = (ui.miniModeEnabled || !ui.config.fullscreen.enabled || (remainingSpace < BUTTON_WIDTH1));
        return Math.abs(checkButtonForBody(test,"nofullscreen")-1);
    };
    UI.prototype.checkPiPButton = function(remainingSpace) {
        var ui = this;
        var test = !ui.player.isPlaying360 && !ui.player.Chromecast.isCasting && (ui.pIp.supported && ui.config.pictureInPicture.enabled) && (remainingSpace >= BUTTON_WIDTH1);
        return checkButtonForBody(test, "picInPic");
    };
    UI.prototype.checkChromecastButton = function(remainingSpace) {
        var ui = this;
        var test = !ui.player.isPlaying360 && ui.config.chromecast.enabled && ui.player.Chromecast.isAvailable && (ui.player.config.supportLiveChromecast || !ui.player.isLive) && (remainingSpace >= BUTTON_WIDTH1);
        return checkButtonForBody(test, "chromecast");
    };
    UI.prototype.checkSubtitlesButton = function(remainingSpace) {
        var ui = this;
        var test = (ui.config.subtitles.enabled && ui.player.Subtitles.subsAvailable()) && (remainingSpace >= BUTTON_WIDTH1);

        if(!test && ui.subtitleSettingsPanel && ui.subtitleSettingsPanel.isPanelOpen() ) {
            ui.subtitleSettingsPanel.closePanel();
        }

        return checkButtonForBody(test,"subtitles");
    };
    UI.prototype.checkEmbedButton = function(remainingSpace) {
        var ui = this;
        var test = (ui.player.playlist && ui.config.embed.enabled && ui.player.playlist.embedRight) && (remainingSpace >= BUTTON_WIDTH1);
        return checkButtonForBody(test,"embed");
    };
    UI.prototype.checkPlaybackSettingsButton = function(remainingSpace) {
        var ui = this;
        var test = ui.config.playbackSettingsPanel.enabled && (ui.config.playbackSettingsPanel.continuousPlaySetting || ui.config.playbackSettingsPanel.qualitySetting) && (ui.container.clientWidth >= 320) && (remainingSpace >= BUTTON_WIDTH1) && !(!ui.config.playbackSettingsPanel.continuousPlaySetting && ui.config.playbackSettingsPanel.qualitySetting && (Device.preferHls || ui.container.clientHeight < 295) );


        if(!test && ui.playbackSettingsPanel && ui.playbackSettingsPanel.isPanelOpen() ) {
            ui.playbackSettingsPanel.closePanel();
        }

        return checkButtonForBody(test, "playbackSettings");
    };
    UI.prototype.resetGuidance = function() {
        var ui = this;
        clearTimeout(ui.guidanceTimeout);
        ui.guidanceTimeout = false;
        if (ui.padlock && ui.player.config) {
            var guidance = ui.player.config.guidance;
            if (guidance) {
                //Don't display the padlock icon if no PG has been
                //set or cookies have been cleared, pressing play
                //will trigger PG
                var pinRequired = ui.config.guidance.pinRequired;
                var noPadlock = !pinRequired || ( pinRequired && (!(guidance.hasGuidancePIN) && (!guidance.guidanceSkipped)) || (ui.player.config.under16 && !ui.player.config.guidance.hasGuidancePIN) );
                ui.padlock.style.display= Utils.noneOrBlock(!noPadlock);
                ui.guidanceClose.style.display = 'none';
                ui.guidance.style.display = "none";
                ui.guidance.className = "p_ctaGuidance p_guidance";
                Utils.className(document.body,"","p_continuousGuidanceOrWarning");

                if (ui.config.cta.direction === 'rtl' && !noPadlock) {
                    Utils.className(ui.guidance, 'rtlPadlock');
                    ui.guidanceBox.style.marginLeft = '40px';
                }
            }
        }

        // remove warnings
        Utils.setOrUnsetClassOnlyAfterCheck(ui.guidance,'p_warning',null,true);
        Utils.setOrUnsetClassOnlyAfterCheck(ui.guidance,'p_warningCta',null,true);
    };
    UI.prototype.guidanceOrWarning = function () {
        var ui = this;
        if (!ui.config.guidance.enabled || !ui.player.playlist) {
            ui.guidance.style.display = "none";
            return;
        }
        var guidance = "";
        if (ui.player.playlist.guidance !== "") {
            guidance = ui.player.playlist.guidance;
        } else {
            if (ui.player.playlist.warning !== "") {
                guidance = ui.player.playlist.warning;
                if (ui.padlock) {
                    ui.padlock.style.display = "none";
                }
                ui.guidance.className = "p_ctaGuidance p_guidance p_warningCta";
            }
        }

        if (guidance !== "") {
            ui.guidance.style.display = "table";
            ui.guidanceBox.textContent = guidance;
        } else {
            ui.guidance.style.display = "none";
        }
    };
    UI.prototype.dispatchUIInfo = function() {
        var ui=this;
        var uiInfo = this.UIinfoObject;

        var divWidth = ui.player.mediaContainer.clientWidth;
        var divHeight = ui.player.mediaContainer.clientHeight;
        if (divHeight<=0 || divWidth<=0) {
            return;
        }

        // this is really in the CSS, could get this sanely some
        // other way?
        uiInfo.referenceHeight = BUTTON_WIDTH1 - 1;

        uiInfo.seekBarVisible = ui.progressBar.isVisible();
        uiInfo.controlBarVisible = isElementVisible(ui.controlsHolder);
        uiInfo.markersBarVisible = Utils.hasClass( ui.container,"p_hasMarkers");

        uiInfo.controlsHeight = (uiInfo.referenceHeight * ( (uiInfo.seekBarVisible ? 1 : 0)+ (uiInfo.controlBarVisible ? 1 : 0)) + (uiInfo.markersBarVisible ? ui.markersUI.markerDisplayHeight : 0));
        if (ui.controls) {
            var rect=Utils.getOffsets(ui.controls);
            if (rect.width>0) {
                uiInfo.controlsWidth = rect.width;
                uiInfo.controlsTop = rect.top;
                uiInfo.controlsLeft = rect.left;
            }

            if (ui.progressBar) {
                var progressBarRect = Utils.getOffsets(ui.progressBar.seekBar);
                if (progressBarRect.width>0) {
                    uiInfo.seekBarLeft = progressBarRect.left;
                    uiInfo.seekBarRight = progressBarRect.right;
                }
            }
        }

        // The video size
        var videoWidth = ui.player.mediaPlayer.videoWidth;
        var videoHeight = ui.player.mediaPlayer.videoHeight;
        if (videoHeight !== 0) {
            var videoAspectRatio = videoWidth / videoHeight;
            var divAspectRatio = divWidth / divHeight;
            if (videoAspectRatio < divAspectRatio){
                uiInfo.videoWidth = Math.round((videoWidth*divHeight)/videoHeight);
                uiInfo.videoHeight = divHeight;
                uiInfo.videoX = Math.round((divWidth -  uiInfo.videoWidth)/2.0);
                uiInfo.videoY = 0;
            } else {
                uiInfo.videoHeight = Math.round((videoHeight*divWidth)/videoWidth);
                uiInfo.videoWidth = divWidth;
                uiInfo.videoX = 0;
                uiInfo.videoY = Math.round((divHeight - uiInfo.videoHeight)/2.0);
            }
        }


        if (ui.initialised && (!ui.controls || uiInfo.controlsWidth>0)) {
            var stringy = JSON.stringify(uiInfo);
            if (stringy!=ui.lastUIinfoDispatch) {
                var event = {type:"uiinfo", properties:uiInfo};
                for (var property in uiInfo) {
                    if (uiInfo.hasOwnProperty(property)) {
                        event[property]=uiInfo[property];
                    }
                }

                ui.player.delayedDispatch(event);
                ui.lastUIinfoDispatch = stringy;
            }
        }
    };
    UI.prototype.getBackgroundImageUrl = function() {
        var ui = this;
        var path = ui.container.style.backgroundImage;
        var regExp = /url\(([^)]+)\)/;
        var matches = regExp.exec(path);
        return ((matches && matches.length >= 2) ? matches[1].replace(/^"+|"+$/g, '') : path);
    };
    UI.prototype.guidancePopUp = function(isFromQueue) {
        var ui = this;

        if (!ui.config.guidance.enabled) {
            return;
        }

        if ((!ui.config.guidance.displayContinuousGuidanceInQueuePlaylist && isFromQueue) || !ui.config.guidance.displayGuidanceInAutoplay) {
            ui.guidance.style.display = "none";
            return;
        }


        var guidance = "";
        var className="p_guidance p_continuous";
        if (ui.player.playlist.guidance !== "") {
            guidance = ui.player.playlist.guidance;
        } else {
            if (ui.player.playlist.warning !== "") {
                className="p_warning p_guidance p_continuous";
                guidance = ui.player.playlist.warning;
            }
        }

        if (guidance !=="") {
            ui.padlock.style.display="none";
            ui.guidance.style.visibility = "visible";
            ui.guidanceBox.textContent = guidance;
            ui.guidance.style.display='table';
            ui.guidance.className=className;
            ui.guidanceClose.style.display = 'block';
            Utils.className(document.body, "p_continuousGuidanceOrWarning");
            clearTimeout(ui.guidanceTimeout);
            ui.guidanceTimeout = setTimeout(ui.eventCallbacks.guidanceHide, 10000);
        } else {
            ui.guidance.style.display = "none";
        }
    };

    UI.prototype.areControlsVisible = function() {

        return this.controls && this.controls.visible;

    };

    UI.prototype.canDisplayRemoteInput = function() {
        return true;
    };

    UI.prototype.displayRemoteInput = function() {
        var ui = this;

        ui.ensureRemoteInput();
        ui.remoteInput.style.display = 'block';
    };

    UI.prototype.appendRemoteInputContent = function(content) {
        var ui = this;

        ui.ensureRemoteInput();

        if (ui.remoteInput.textContent.length === 3) {
            // already performed handleRemoteInput(), clear text and timeout
            ui.remoteInput.textContent = '';
        }

        ui.remoteInput.textContent += content;

        if (ui.remoteInput.timeout) {
            clearTimeout(ui.remoteInput.timeout);
        }
        if (ui.remoteInput.textContent.length === 3) {
            // remoteInput code is at max length: handle code now, and clear after a delay
            handleRemoteInput(ui);
            ui.remoteInput.timeout = setTimeout(ui.clearRemoteInput.bind(ui), 2000);
        } else {
            ui.remoteInput.timeout = setTimeout(handleRemoteInputAndClear, 2000, ui);
        }
    };

    var handleRemoteInputAndClear = function(ui) {
        handleRemoteInput(ui);
        ui.clearRemoteInput();
    };

    var handleRemoteInput = function(ui) {
        var input = ui.getRemoteInputContent();
        var number = parseInt(input, 10);
        var subtitles = ui.player.Subtitles;

        // We want to show the control bar in the same way we do as on a
        // keyup event... so fake a keyup event :)
        var fakeEvent = { type: 'keyup' };
        var controlBarShowHandler = getControlBarShowHandler(ui);
        controlBarShowHandler(fakeEvent);

        if (ui.config.controls.experimentalShortcuts && number >= 0 && number <= 9) {
            ui.player.seekToPercent(number / 10);
            ui.player.trackAction('seek_numberkey_' + number, 'shortcut_key_press');
        }

        if (number === 888 && subtitles.subsAvailable()) {

            if (subtitles.showingSubs) {
                subtitles.off();
                ui.player.trackAction('subtitles_off', 'shortcut_key_press');
            } else {
                subtitles.on();
                ui.player.trackAction('subtitles_on', 'shortcut_key_press');
            }

        }
    };

    UI.prototype.getRemoteInputContent = function() {
        var ui = this;

        return ui.remoteInput ? ui.remoteInput.textContent : '';
    };

    UI.prototype.clearRemoteInput = function() {
        var ui = this;

        if (ui.remoteInput) {
            ui.remoteInput.style.display = 'none';
            ui.remoteInput.textContent = '';
        }
    };

    UI.prototype.ensureRemoteInput = function() {
        var ui = this;

        if (!ui.remoteInput) {
            ui.remoteInput = document.createElement('div');
            ui.remoteInput.id = 'p_remoteInput';
            ui.remoteInput.style.display = 'none';
            ui.player.mediaContainer.appendChild(ui.remoteInput);
        }
    };

    return UI;
})();
var AudioUI = (function() {


    // XXX refactor so config is shared so we can be
    // ready to swap between the two skins more easily.
    var defaultConfig = {
        buffer : {
            enabled:true,
            colour:'',
            foreColour:'#ffffff',
            width:50,
            thickness:10,
            top:"50%",
            left:"50%",
            forceShow: false
        },
        poster : {
            enabled:true,
            effects:false
        },
        cta : {
            enabled:true,
            visiblyHidden:false,
            ignoreAudio:false,
            backgroundColour : "#808080"
        },
        errorDialog : {
            enabled:true
        },
        controls : {
            enableLiveRewind : true,
            spaceControlsPlayback : false,
            experimentalShortcuts : false,
            volumeSlider: true,
            volumeDismissTime: 2000,
            includeNextButton: false,
            includePreviousButton: false,
            popout: false
        },
        markers : {
            enabled: true,
            suppressMarkerKinds : [],
            hideBelowWidth : 600
        },
        subtitles : {
            enabled : true,
            desnakeLiveSubtitles: true,
            supportLiveSubtitles: true,
            defaultOn : false,
            yOffset : NaN,
            kind: "subtitles",
            margins: []
        },
        guidance :  {
            enabled : true,
            pinRequired : false,
            displayContinuousGuidanceInQueuePlaylist : true,
            displayGuidanceInAutoplay : true
        },
        embedded : {
            enabled : false
        },
        miniMode: {
            enabled : false,
            backgroundColour : "#ffffff"
        },
        locale : {
            lang : "en",
            path : "/emp/translations/smp/{lang}.xml"
        },
        // use in player guidance
        useInPlayerGuidance : false,
        mediaSessionAPI : {
            enabled : true
        },
        colour : '#f54997',
        foreColour : '#ffffff',
        timesRelativeToLive: false
    };

    function createDomElements(self) {

        var audioUiContainer = self.audioUiContainer = document.createElement('div');
        audioUiContainer.id = 'p_audioui_container';

        var coreControlsContainer = document.createElement('div');
        coreControlsContainer.id = 'p_audioui_coreControls';

        var rightRegionControls = document.createElement('div');
        rightRegionControls.id = 'p_audioui_rightRegionControls';

        coreControlsContainer.appendChild(self.playPauseButton.getDomNodes());
        coreControlsContainer.appendChild(self.backIntervalButton.getDomNodes());
        coreControlsContainer.appendChild(self.forwardIntervalButton.getDomNodes());
        coreControlsContainer.appendChild(self.previousButton.getDomNodes());
        coreControlsContainer.appendChild(self.backToStartButton.getDomNodes());
        coreControlsContainer.appendChild(self.nextButton.getDomNodes());
        coreControlsContainer.appendChild(self.toLiveButton.getDomNodes());
        coreControlsContainer.appendChild(self.audioCtaDuration.getDomNodes());

        audioUiContainer.appendChild(coreControlsContainer);
        audioUiContainer.appendChild(self.volumeControl.getDomNodes()[0]);

        rightRegionControls.appendChild(self.playbackSettingsButton.getDomNodes());
        rightRegionControls.appendChild(self.popOutPlayerButton.getDomNodes());

        audioUiContainer.appendChild(rightRegionControls);

        appendChildren(audioUiContainer,self.progressBar.getDomNodes());

        audioUiContainer.appendChild(self.audioTimeDisplays.getDomNodes()[0]);
        audioUiContainer.appendChild(self.audioTimeDisplays.getDomNodes()[1]);

        self.container.appendChild(audioUiContainer);

    }



    function getEventCallbacks(self) {

        return {

            notPlayingState: function() {
            },

            playingState: function() {
                self.showControls();
            },

            losingControl: function() {
                self.hideControls();
            },

            tryingToPlay: function() {
                //self.showControls();
            },

            play: function() {
                //self.showControls();
            },

            playerDisconnected: function() {
                self.showCta();
            },

            playlistStopped: function() {
                self.showCta();
            },

            playlistEnded : function(e) {
                if(!e.willAutomaticPlayQueuedItem && !self.config.controls.availableOnMediaEnded) {
                    self.showCta();
                }
            },

            playlistLoaded: function() {

                Utils.asyncDelay(function() {
                    if (!self.player.tryingToPlay) {
                        self.showCta();
                    }
                });

            },

            durationchange: function() {
                //TODO check if should show seekbar
                //checkIfCanDisplaySeekBar
                //updateTimeDisplay(self);
            },

            beforeErrorDisplay: function() {
                self.hideControls();
            }

        };

    }

    var AudioUI = function(player, config) {

        BaseUI.call(this, player, defaultConfig, config);

        this.type = 'audio';
        this.container = player.mediaContainer;

        this.pGuidance = new ParentalGuidance(this, player);

    };

    AudioUI.prototype = Utils.object(BaseUI.prototype);

    AudioUI.prototype.initialise = function() {

        var self = this;

        var player = self.player;

        BaseUI.prototype.initialise.call(this);

        this.playPauseButton = new AudioPlayButton(this);
        this.playPauseButton.setActionFunction(self.togglePlay);
        this.backIntervalButton = new BackIntervalButton(this);
        this.backIntervalButton.setActionFunction(function(actionType) {
            player.time = player.time - player.config.skipInterval;
            player.trackAction('back_interval_button', actionType);
        });

        this.forwardIntervalButton = new ForwardIntervalButton(this);
        this.forwardIntervalButton.setActionFunction(function(actionType) {
            player.time = player.time + player.config.skipInterval;
            player.trackAction('forward_interval_button', actionType);
        });

        this.previousButton = new PreviousButton(this);
        this.previousButton.setActionFunction(function(actionType) {
            if(player.time < 5 && player.hasPrevious) {
                player.previous(player.playingState == 'playing');
            } else {
                player.time = 0;
            }
            player.trackAction('previous_button', actionType);
        });


        this.nextButton = new NextButton(this);
        this.nextButton.setActionFunction(function(actionType) {
            player.next(player.playingState == 'playing');
            player.trackAction('next_button', actionType);
        });

        this.backToStartButton = new BackToStartButton(this);
        this.backToStartButton.setActionFunction(function(actionType) {
            player.time = player.timeHelper.earliestSeek;

            if(player.playingState !== 'playing') {
                player.requestGuidanceAndPlay();
            }

            player.trackAction('back_to_start_button', actionType);

        });

        this.toLiveButton = new ToLiveButton(this);
        this.toLiveButton.setActionFunction(function(actionType) {
            player.time = player.timeHelper.latestSeek;

            if(player.playingState !== 'playing') {
                player.requestGuidanceAndPlay();
            }

            player.trackAction('to_live_button', actionType);

        });

        this.popOutPlayerButton = new PopOutPlayerButton(this);
        this.popOutPlayerButton.setActionFunction(function(actionType) {

            player.dispatch({type:"popoutrequest"});

            player.trackAction('pop_out_player_button', actionType);

        });

        this.playbackSettingsButton = new PlaybackSettingsButton(this);

        this.progressBar = new ProgressBar(this);
        this.errorDialog = new ErrorDialog(this);

        this.volumeControl = new VolumeControl(this);

        this.audioTimeDisplays = new AudioTimeDisplays(this);

        this.audioCtaDuration = new AudioCtaDuration(this);

        //init components
        this.playPauseButton.hide();
        this.audioCtaDuration.hide();
        this.audioCtaDuration.remove();
        this.backIntervalButton.hide();
        this.forwardIntervalButton.hide();
        this.previousButton.remove();
        this.nextButton.remove();
        this.backToStartButton.remove();
        this.toLiveButton.remove();
        this.volumeControl.hide();
        this.progressBar.hide();
        this.progressBar.seekBarHolder.style.opacity = 0;
        this.popOutPlayerButton.hide();
        this.playbackSettingsButton.hide();

        createDomElements(this);

        this.eventArray = [getEventCallbacks(this), this.playPauseButton.getEventCallbacks(), this.backIntervalButton.getEventCallbacks(), this.forwardIntervalButton.getEventCallbacks(), this.previousButton.getEventCallbacks(), this.nextButton.getEventCallbacks(), this.backToStartButton.getEventCallbacks(), this.toLiveButton.getEventCallbacks(), this.progressBar.getEventCallbacks(), this.errorDialog.getEventCallbacks(), this.volumeControl.getEventCallbacks(), this.audioTimeDisplays.getEventCallbacks(), this.popOutPlayerButton.getEventCallbacks(), this.playbackSettingsButton.getEventCallbacks()];

    };

    AudioUI.prototype.showCta = function() {

        BaseUI.prototype.showCta.call(this);

        this.audioUiContainer.style.display = 'block';
        this.playPauseButton.show();
        this.audioCtaDuration.show();
        this.backIntervalButton.hide();
        this.forwardIntervalButton.hide();
        this.nextButton.hide();
        this.previousButton.hide();
        this.backToStartButton.hide();
        this.toLiveButton.hide();
        this.volumeControl.hide();
        this.progressBar.hide();
        this.progressBar.seekBarHolder.style.opacity = 1;
        this.popOutPlayerButton.hide();
        this.playbackSettingsButton.hide();

        this.player.dispatch({type:"showCta"});

    };

    AudioUI.prototype.showControls = function() {

        BaseUI.prototype.hideCta.call(this);

        this.audioUiContainer.style.display = 'block';
        this.playPauseButton.show();
        this.audioCtaDuration.hide();
        this.backIntervalButton.show();
        this.forwardIntervalButton.show();
        this.nextButton.show();
        this.previousButton.show();
        this.backToStartButton.show();
        this.toLiveButton.show();
        this.volumeControl.show();
        this.progressBar.show();
        this.progressBar.seekBarHolder.style.opacity = 1;
        this.popOutPlayerButton.show();
        this.playbackSettingsButton.show();

    };

    AudioUI.prototype.hideControls = function() {

        this.audioUiContainer.style.display = 'none';

    };

    AudioUI.prototype.areControlsVisible = function() {

        return true;

    };

    return AudioUI;

})();
var API= (function() {

    function API(player) {
        var ui = player.ui;
        this.onAdsProcessed = function(data){
            player.onAdsProcessed(data);
        };
        this.updateQuality = function(config) {
            if (DEBUG_FULL) { console.log('API updateQuality:', config); }
            player.updateQuality(config);
        };
        this.updateUiConfig = function(config) {
            if (DEBUG_FULL) { console.log('API updateUiConfig:', config); }
            ui.updateConfig(config);
        };
        this.uiConfigFromBump = function(config) {
            if (DEBUG_FULL) { console.log('API uiConfigFromBump:', config); }
            ui.updateConfig(config, true);
        };
        this.captureIntent = function(config, xdCall) {
            if (DEBUG_FULL) { console.log('API captureIntent:',config); }
            if (xdCall) {
                if (DEBUG_FULL) { console.log('API captureIntent rejected because it came over xdCall'); }
                return;
            }
            var type=config ? config.type : null;
            player.captureIntent(type);
        };
        this.dispatch = function(event,internal) {
            if (DEBUG_FULL) { console.log('API dispatch:', event); }
            player.dispatch(event,internal);
        };
        this.updateGuidance = function(data) {
            if (DEBUG_FULL) { console.log('API updateGuidance:', data); }
            player.config.guidance = Utils.merge(player.config.guidance || {},data);
            player.ui.updateGuidance();
            player.dispatch({type:"guidanceUpdated"},true);
        };
        this.next = function(andPlay) {
            if (DEBUG_FULL) { console.log('API next',andPlay); }
            player.next(andPlay);
        };
        this.previous = function(andPlay) {
            if (DEBUG_FULL) { console.log('API previous',andPlay); }
            player.previous(andPlay);
        };
        this.queuePlaylist = function(data) {
            if (DEBUG_FULL) { console.log('API queuePlaylst:', data); }
            if (player.playlist) {
                // ensure playlists are not the same object.
                try {
                    data = JSON.parse(JSON.stringify(data));
                } catch (e) {
                }
                player.setQueuedItem(data);
            }
        };
        this.setPreviousPlaylist = function(data) {
            if (DEBUG_FULL) { console.log('API setPreviousPlaylst:', data); }
            if (player.playlist) {
                // ensure playlists are not the same object.
                try {
                    data = JSON.parse(JSON.stringify(data));
                } catch (e) {
                }
                player.setPreviousItem(data);
            }
        };
        this.updateConfig = function(data) {
            if (DEBUG_FULL) { console.log('API updateConfig:', data); }
            player.updateConfig(data);
        };
        this.configFromBump = function(data) {
            if (DEBUG_FULL) { console.log('API configFromBump:', data); }
            player.updateConfig(data, false, true);
        };

        // need to change this back to loadPlaylist
        this.loadPlaylist2 = function(settings, xdCall) {
            if (DEBUG_FULL) { console.log('API LoadPlaylist2:', settings); }
            player.loadingPlaylistURL = null;
            xdCall = xdCall || settings.nonUserBypass;

            // ensure playlists are not the same object.
            try {
                var playlistObject = JSON.parse(JSON.stringify(settings.playlistObject));
            } catch (e) {
                // it might survive some basic playing.
                playlistObject = settings.playlistObject;
            }
            
            var delayIt=function() {
                player.reset();
                player.resetStatsObject();
                player.updateConfig(settings);

                if (playlistObject) {
                    player.loadPlaylistObject(playlistObject, xdCall);
                } else {
                    if (settings.playlist) {
                        player.loadPlaylistUrl(settings.playlist+"", xdCall);
                    }
                }
            };
            var elType="video";
            if (playlistObject && playlistObject.items) {
                var item = playlistObject.items[0];
                // XXX we should care about adverts here.
                if (item && (item.kind=="audio" || item.kind=="radioProgramme")) {
                    elType="audio";
                }
            }
            if (!(xdCall || !settings.autoplay || player.willAutoplayWhenPlayCalled[elType])) {
                // if we need to capture the intent and we can.
                player.captureIntent(elType);
            }
            Utils.asyncDelay(delayIt);
        };
        this.play = function(param,xdCall) {
            if (DEBUG_FULL) { console.log('API PLAY, '+param+', xdCall:' + xdCall); }
            // XXX BUMP defaults param to true, so shouldn't
            // break pages with external play buttons,
            // but for plugins it's up to them.
            player.playWithUserCheck(!param || xdCall);
        };
        this.pause = function() {
            if (DEBUG_FULL) { console.log('API PAUSE, '); }
            player.pause();
        };
        this.stop = function(obj) {
            if (DEBUG_FULL) { console.log('API STOP, '); }
            if (obj && obj.destroy) {
                player.destroying = true;
            }
            player.stop();
        };
        this.suspend = function() {
            if (DEBUG_FULL) { console.log('API SUSPEND, '); }
            player.suspend();
        };
        this.volume = function(setVolume) {
            if (typeof setVolume !== 'undefined' && !isNaN(setVolume) ) {
                if (DEBUG_FULL) { console.log('API Player.volume', setVolume); }
                player.volume=setVolume;
            }
            return player.volume;
        };
        this.muted = function(newValue) {
            if (DEBUG_FULL) { console.log("API muting " + newValue); }
            player.muted = newValue;
            return player.muted;
        };
        this.showSubtitles = function(setSubs) {
            if (DEBUG_FULL) { console.log("API showSubtitles " + setSubs); }
            var subs = player.Subtitles;
            if (setSubs) {
                subs.on();
            } else {
                subs.off();
            }
            return subs.showingSubs;
        };
        this.currentTime = function(newTime) {
            if (DEBUG_FULL) { console.log("API currentTime " + newTime); }
            if (typeof newTime != 'undefined') {
                player.time = newTime;
            }
            return player.time;
        };
        this.guidanceClosed = function(success) {
            player.dispatch({type:"guidanceClosed", success:success});
            if (success) {
                ui.pGuidance.close(false,true);
            } else {
                if (player.isFullScreen && !player.iframeFullscreen) {
                    player.minimise();
                }
            }
        };
        this.setData = function(data) {
            if (DEBUG_FULL) { console.log('API setData:', data); }
            if (data) {
                var d = data.data;
                Utils.asyncDelay(function() {
                  if (data.name === "SMP.markers") {
                      ui.markerData=d;
                  }
                  if (data.name=="SMP.webcastData") {
                      player.webcastData={};
                      if (d) {
                          player.webcastData.accurateStartTime=d.accurateStartTime;
                          player.webcastData.accurateEndTime=d.accurateEndTime;
                          player.webcastData.scheduledEndTime=d.scheduledEndTime;
                          player.webcastData.scheduledStartTime=d.scheduledStartTime;
                          player.webcastData.ignoreJoinTime = d.ignoreJoinTime;
                      }
                  }
                  if (data.name=="SMP.subtitlesHref" && d) {
                      player.Subtitles.updateSubs(d.url);
                  }
                  if (data.name=="SMP.thumbManifestUrl" && d) {
                      player.thumbScrub.updateOverrideManifest(d.url);
                  }
                  if (data.name=="SMP.protectionData" && d) {
                      player.setProtectionData(d);
                  }
                  if (data.name=="SMP.availableTime" && d) {
                      player.timeHelper.setAvailableTime(d);
                      player.ui.timeUpdate();
                  }
                  if (data.name=="SMP.mediaSessionAPI") {
                      player.dispatch({type:"setMediaSessionAPIdata",data:data});
                      return;
                  }
                });
                player.dispatch({type:"setData",data:data},true);
            }
        };
        this.pauseAt = function(data) {
            if (DEBUG_FULL) { console.log('API pauseAt:', data); }
            if (data && data.sort) {
                player.pauseTimes = data.sort(Utils.sortSimple);
            }
        };
        this.loadPlugin2 = function(obj) {
            if (DEBUG_FULL) { console.log('API loadPlugin2:', obj); }
            PluginManager.loadPlugin(obj.url, obj.data, obj.waitOnPluginLoad);
        };
        this.setPoster = function(obj) {
            if (DEBUG_FULL) { console.log('API setPoster:', obj); }
            var url = obj.url;
            var effect = obj.effect;
            if (player.playlist) {
                player.playlist.posterRecipe = url;
                if (ui.config.poster.effects && effect && effect.type) {
                    switch(effect.type) {
                    case 'fade':
                        ui.fadeInNewPosterImage(effect);
                        break;
                    case 'slide':
                        ui.slideInNewPosterImage(effect);
                        break;
                    case 'zoom':
                        ui.zoomInPosterImage(effect);
                        break;
                    }
                    return;
                }
                ui.updatePoster();
                ui.hideEffects();
            }
        };
        this.ccInfo = function(obj) {
            if (DEBUG_FULL) { console.log('API ccInfo:', obj); }
            var cc = player.Chromecast;

            if (obj.id && (cc.deviceId !== obj.id)) {
                cc.deviceId = obj.id;
            }

            if (cc.isAvailable !== obj.available || cc.isCasting !== obj.casting) {
                cc.isAvailable = obj.available;
                if (cc.isCasting && !cc.isAvailable) {
                    cc.stopCast();
                }
                cc.isCasting = obj.casting;
                ui.updateLayout();
            }

            if (cc.activeSession !== obj.activeSession) {
                cc.activeSession = obj.activeSession;
            }

            if (obj.state) {
                var state = obj.state.toLowerCase();

                if (state === 'connecting') {
                    cc.connect();
                }

                if (state === 'error') {
                    cc.stopCastAttempt();
                }

                if (cc.isCasting && state === 'playing') {
                    cc.playing(obj);
                }

                if (cc.isCasting && state === 'paused') {
                    cc.paused();
                }

                if (cc.isCasting && state === 'buffering') {
                    cc.buffering();
                }

                if (state === 'stopped' || state === 'idle') {
                    cc.stopped();
                }

                if (state === 'finished') {
                    cc.finished();
                }

                if (cc.isAvailable) {
                    cc.externalControlCheck(obj);
                }
            }
        };
        
        this.PINverified = function(data){
            ui.pGuidance.verified(data);
        };
    }
    return API;
})();
/**
 * PluginUtilities
 * Provides plugins with utility methods
 *
 */
var PluginUtilities = (function () {
    function PluginUtilities_relativeUrl(url) {
        if (url.indexOf("http:")!==0 && url.indexOf("https:")!==0) {
            var ref = this.url;
            if (ref.indexOf('?')!=-1) {
                ref=ref.substring(0,ref.indexOf('?'));
            }
            return ref.substring(0,ref.lastIndexOf('/'))+"/"+url;
        }
        return url;
    }

    // Plugin Utilities Class Methods
    function PluginUtilities_loadCSS(css,id) {
        if (!css) {
            return;
        }
        var pi = this.playerInterface;
        var url = this.relativeUrl(css);

        var head = document.getElementsByTagName('head')[0];
        var link = document.createElement('link');
        link.type = 'text/css';
        link.rel = 'stylesheet';
        link.href = url;
        link.addEventListener("load", function() {
                                  pi.dispatchToPlugins( { type:"cssLoaded", path:css, url:url, id:id });
                              });

        link.addEventListener("error", function() {
                                  pi.dispatchToPlugins( { type:"cssLoadFailed", path:css, url:url, id:id });
                              });
        head.appendChild(link);
        return;
    }

    var PluginUtilities = function(playerInterface, url, pluginManager) {
        this.url = url;
        this.playerInterface = playerInterface;
        this.getPluginList = function getPluginList() {
            return pluginManager.getPluginList();
        };

        return this;
    };

    PluginUtilities.prototype = {
        loadCSS : PluginUtilities_loadCSS,
        relativeUrl : PluginUtilities_relativeUrl,
        register: null
    };

    return PluginUtilities;
})();



/**
 * DataStore
 * Provides plugins with an object to interface with the datastore
 */
var DataStore = (function() {
   var DataStore = function() {
   };
   DataStore.prototype = {
       set:function(obj) {
           if (obj) {
               if (typeof obj.name=="string" && obj.name!=="" && obj.name!="get" && obj.name!="set") {
                   this[obj.name]=obj.data;
               }
           }
       },
       get:function(name) {
           return this[name];
       }
   };
   return DataStore;
})();



/**
 * PlayerInterface
 * Provides plugins with an object to interface with the player
 */
var PlayerInterface = (function() {
    // Constructor
    var p,ds;

    function getGettersAndSetters(playerInterface, player, datastore) {
        return {
            listenerObject : {
                get: function() {
                    if (DEBUG_FULL) { console.log("Someone requesting listener object, this is not allowed"); }
                },
                set: function(obj) {
                    playerInterface.listenerObjects.push(obj);
                }
            },
            datastore : {
                get : function() {
                    return datastore;
                }
            },

            settings : {
                get : function() {
                    return player.config;
                },

                set: function(value) {
                    player.updateConfig(value);
                }
            },
            uiInfo : {
                get : function() {
                    return player.ui.UIinfoObject;
                }
            },
            currentTime : {
                get : function() {
                    return player.time;
                },

                set : function(value) {
                    player.time=value;
                }
            },
            canPause : {
                get : function() {
                    return player.timeHelper.canSeek();
                }
            },
            currentItem : {
                get : function() {
                    return player.mediaItem;
                }
            },
            currentChapter : {
                get : function() {
                    return player.ui.markersUI.getCurrentChapter();
                }
            },
            playlist : {
                get : function() {
                    if (!player.playlist || player.playlist.loading) {
                        return null;
                    }
                    return player.playlist;
                }
            },
            muted : {
                get : function() {
                    return player.muted;
                },

                set : function(value) {
                    player.muted=value;
                }
            },
            volume : {
                get : function() {
                    return player.volume;
                },

                set : function(value) {
                    player.volume=value;
                }
            },
            paused : {
                get : function() {
                    return player.paused;
                }
            },
            duration : {
                get : function() {
                    return player.duration;
                }
            },
            hasGuidancePassed : {
                get : function() {
                    return player.hasGuidancePassed;
                }
            },
            canShowControls : {
                get : function() {
                    return player.ui.active && !player.ui.inPrePlayState;
                }
            },
            inError : {
                get : function() {
                    return player.ui.inError;
                }
            },
            isFromIdent : {
                get : function() {
                    return (player.mediaItem.kind == 'ident');
                }
            },
            pluginManagerFailedArray : {
                get : function() {
                    return PluginManager.failedArray;
                }
            }
        };
    }

    var PlayerInterface = function(player,datastore) {
        p = player;
        ds = datastore;
        var playerInterface = this;
        playerInterface.listenerObjects = [];

        var container = document.createElement("div");
        container.id = "p_pluginContainer";
        container.className = "notInteractiveContent";
        container.style.width = window.innerWidth+"px";
        container.style.height = window.innerHeight+"px";
        player.mediaContainer.appendChild(container);
        player.ui.pluginContainer = container;

        this.container = container;
        function relayEvent(event) {
            var wrappedEvent={
                target:playerInterface
            };

            for (var i in event.properties) {
                if (i!="type" && i!="target") {
                    wrappedEvent[i] = event.properties[i];
                }
            }

            for (i in event) {
                if (i!="_" && i!="target" && i!="properties") {
                    wrappedEvent[i] = event[i];
                }
            }

            if (event.type=="setData") {
                ds.set(event.data);
            }

            playerInterface.dispatchToPlugins(wrappedEvent);

            if (event.type=="setData") {
                // double up for now with pluginData aswell as setData
                wrappedEvent.type="pluginData";
                playerInterface.dispatchToPlugins(wrappedEvent);
            }
        }

        // Attach all events from player
        player.requestAllEvents(relayEvent);

        Utils.defineProperties(playerInterface,getGettersAndSetters(playerInterface,player, datastore));

        return playerInterface;
    };

    function outOfControlVolumeListener(e) {
        p.volume = e.target.volume;
    }

    function destroyPluginPlayer() {
        if (pluginMediaElement) {
            pluginMediaElement.removeEventListener('volumechange', outOfControlVolumeListener);
            p.mediaContainer.removeChild(pluginMediaElement);
            pluginMediaElement = null;
        }
    }

    function releaseElement() {
        if (p.outOfControl) {
            if (p.resetAfterOutOfControl) {
                if (Device.supportsMultipleMediaElements) {
                    destroyPluginPlayer();
                    p.mediaPlayer.style.left = "0px";
                } else {
                    if (p.isPlayingDash) {
                        p.dashEvents.reattachView();
                    } else {
                        if (src) {
                            p.mediaPlayer.src = src;
                            p.mediaPlayer.load();
                            src = null;
                        }
                    }
                }
            }

            p.swf.enableMouseUIBypass();

            p.dispatch({ type:"regainingControl" });
            p.outOfControl = false;
        } else {
            if (DEBUG_FULL) { console.log("Someone releasing an element with not out of control"); }
        }
    }

    function getRequestControl(type) {
        return function(justReference) {
            var el;
            if (justReference) {
                return p.els[type];
            }
            if (!p.outOfControl) {
                if (Device.supportsMultipleMediaElements) {
                    p.hidePlayer(type, true);
                    destroyPluginPlayer();
                    pluginMediaElement = el = document.createElement(type);
                    pluginMediaElement.style.width = "100%";
                    pluginMediaElement.style.height = "100%";
                    pluginMediaElement.addEventListener('volumechange', outOfControlVolumeListener);
                    p.mediaContainer.insertBefore(pluginMediaElement, p.els[type]);
                } else {
                    if (p.isPlayingDash) {
                        p.dashEvents.detachView();
                    } else {
                        p.selectMediaPlayer(type);
                        src = p.mediaPlayer.src;
                    }
                    el = p.mediaPlayer;
                }

                p.swf.disableMouseUIBypass();

                p.dispatch({ type:"losingControl" });
                p.outOfControl = true;
                p.tryingToPlay = false;
                p.resetAfterOutOfControl = true;
                if (p.Subtitles) {
                    p.Subtitles.clearSubtitles();
                }
            } else {
                if (DEBUG_FULL) { console.log("Someone requesting "+type+" element when already out of control"); }
            }
            return el;
        };
    }


    var src;
    var pluginMediaElement;
    PlayerInterface.prototype = {
        callbacks:{},
        addEventListener: function(type,method) {
            if (!this.callbacks[type]) {
                this.callbacks[type]=[];
            }
            this.callbacks[type].push(method);
        },
        removeEventListener:function(type,method) {
            if (this.callbacks[type]) {
                for (var i=this.callbacks[type].length-1;i>=0;i--) {
                    if (this.callbacks[type][i]==method) {
                        this.callbacks[type].splice(i,1);
                    }
                }
            }
        },
        dispatchEvent:function(event) {
            p.dispatch(event);
        },
        dispatchToPlugins:function(event) {
            var type=event.type;
            var listeners = this.listenerObjects;
            for (var i=0;i<listeners.length;i++) {
                var listener = listeners[i];
                if (listener && listener[type]) {
                    try {
                        listener[type](event);
                    } catch (e) {
                        console.error("%cError in a plugin with event"+type+" "+e.message,"color:red;background-color:#ccc");
                        if (DEBUG_FULL) { 
                            console.log("relayEvent: error running callback for event " + type + " in listenerObject.");
                            console.log(e);
                        }
                    }
                }
            }
            var callback = this.callbacks[type];
            if (callback) {
                for (i=callback.length-1;i>=0;i--) {
                    try {
                        callback[i](event);
                    } catch (e) {
                        console.error("%cError in a plugin with event"+type+" "+e.message,"color:red;background-color:#ccc");
                        if (DEBUG_FULL) { 
                            console.log("relayEvent: error running callback for event " + type + " in listenerObject.");
                            console.log(e);
                        }
                    }
                }
            }
        },
        updateUiConfig:function(config, resetIdleTimer) {
            if (DEBUG_FULL) { console.log('Plugin API updateUiConfig:', config, resetIdleTimer); }
            p.ui.updateConfig(config);
            if (resetIdleTimer) {
                p.ui.resetIdleTimeout();
            }
        },
        loadPlaylist:function(playlist, options, image) {
            if (DEBUG_FULL) { console.log('Plugin API loadPlaylist:', playlist,options,image); }
            var newSettings = {};
            if (options === true || options === false) {
                newSettings={ autoplay:options, overideHoldingImage:image };
            } else {
                if (typeof(options)=="object") {
                    newSettings = options;
                }
            }
            if (typeof(playlist)!="string") {
                newSettings.playlistObject = playlist;
            } else {
                newSettings.playlist = playlist;
            }
            if (DEBUG_FULL) { console.log('Plugin LoadPlaylist:', newSettings); }
            p.api.loadPlaylist2(newSettings, false);
        },
        queuePlaylist:function(playlistObject,optionsObject) {

            if (DEBUG_FULL) { console.log('Plugin API queuePlaylist:', playlistObject,optionsObject); }
            p.api.queuePlaylist(playlistObject,optionsObject);
        },
        setPoster:function(url) {
            if (DEBUG_FULL) { console.log('Plugin API setPoster:', url); }

            p.api.setPoster(url);
        },
        setData:function(data) {
            if (DEBUG_FULL) { console.log('Plugin API setData:', data); }
            p.api.setData(data);
        },
        play:function(notFromUser){
            if (DEBUG_FULL) { console.log('Plugin API play:', notFromUser); }
            p.requestGuidanceAndPlay(notFromUser===true);
        },
        pauseAt: function(arr) {
            if (DEBUG_FULL) { console.log('Plugin API pauseAt:', arr); }
            p.api.pauseAt(arr);
        },
        stop: function() {
            if (DEBUG_FULL) { console.log('Plugin API stop'); }
            p.api.stop();
        },
        suspend: function() {
            if (DEBUG_FULL) { console.log('Plugin API suspend'); }
            p.api.suspend();
        },
        showSubtitles: function(show) {
            if (DEBUG_FULL) { console.log('Plugin API showSubtitles:', show); }
            p.api.showSubtitles(show);
        },
        trackAction: function(controlId,actionType,labelsObject) {
            if (DEBUG_FULL) { console.log("Track Action:",controlId,actionType,labelsObject); }
            p.trackAction(controlId,actionType,labelsObject);
        },
        log:function(a) {
            if (DEBUG_FULL) { console.log("From Plugin:",a); }
        },
        pause:function(){
            if (DEBUG_FULL) { console.log('Plugin API pause'); }
            p.pause();
        },
        previous:function(andPlay) {
            if (DEBUG_FULL) { console.log('Plugin API previous'); }
            p.previous(andPlay);
        },
        next:function(andPlay){
            if (DEBUG_FULL) { console.log('Plugin API next'); }
            p.next(andPlay);
        },
        toggleFullscreen:function(){
            p.toggleFullscreen();
        },
        addContextMenuItem:function(id,text,callback) {
            DebugConsole.addContextMenuItem(id,text,callback);
        },
        updateContextMenuItem:function(id,text) {
            DebugConsole.updateContextMenuItem(id,text);
        },
        requestVideoElement:getRequestControl('video'),
        requestAudioElement:getRequestControl('audio'),
        releaseVideoElement:releaseElement,
        releaseAudioElement:releaseElement
    };

    return PlayerInterface;
})();



/**
 * PluginManager
 * Retrieves and manages plugins
 *
 */

var PLUGIN_LOAD_TIMEOUT = 4000;
var REPORT_PLUGIN_LOAD_TIMEOUT = 50000;

function PluginManager_init(player) {
    PluginManager.player = player;
    PluginManager.playerInterface = new PlayerInterface(player,new DataStore());
    PluginManager.loadingCount = 0;
    PluginManager.failedArray = [];
}

function PluginManager_resizeFix() {
    var container = PluginManager.playerInterface.container;
    container.style.width = "0px";
    container.style.height = "0px";
}

function PluginManager_resizeFixEnd() {
    var container = PluginManager.playerInterface.container;
    container.style.width = window.innerWidth+"px";
    container.style.height = window.innerHeight+"px";
}

function PluginManager_resizeFixComplete() {
    PluginManager.playerInterface.dispatchToPlugins({type:"resize",target:PluginManager.player});
}

function PluginManager_isPluginLoading() {
    if (!PluginManager.playerInterface){
        return false;
    }
    return PluginManager.waitingOnPluginLoad;
}

function checkEndOfPluginLoads() {
    PluginManager.loadingCount--;
    if (PluginManager.loadingCount <= 0) {
        if (PluginManager.waitingOnPluginLoad) {
            PluginManager.waitingOnPluginLoad = false;
            if (PluginManager.playlistLoadedEvent) {
                PluginManager.player.loadPluginCompleted(PluginManager.playlistLoadedEvent);
            }
        }
    }
}

function getPluginErrorFunction(player,type, msg, pluginURL) {
    return function() {
        var error = SMPError.getError(type);
        error.nonPlayer = true;
        error.msg = msg;
        error.extra = pluginURL;
        player.dispatch(error);
    };
}


// Plugin Manager Class Methods
function PluginManager_loadPlugin(pluginURL, data, wait) {
    // chuck any data passed through in to the datastore
    PluginManager.playerInterface.datastore.set(data);

    // add in a very simplistic check of duplication too.
    if (PluginManager.urls[pluginURL]) {
        return;
    }
    PluginManager.waitingOnPluginLoad = wait;

    PluginManager.loadingCount++;
    PluginManager.urls[pluginURL] = true;

    var loadedPlugin;
    var arrayReference = PluginManager.pluginArray;
    var player = PluginManager.player;

    var pluginUtilities = new PluginUtilities(PluginManager.playerInterface,pluginURL, PluginManager);

    var loadPluginTimeout = setTimeout(
        function(){
            PluginManager.failedArray.push(pluginURL);
            checkEndOfPluginLoads();
            loadPluginTimeout = setTimeout(getPluginErrorFunction(player, SMPError.PLUGIN_LOAD_TIMEOUT, "", pluginURL),REPORT_PLUGIN_LOAD_TIMEOUT);
        }, PLUGIN_LOAD_TIMEOUT);

    require([pluginURL], function() {
        clearTimeout(loadPluginTimeout);
        var pluginName = pluginURL;//default the name to the url.
        try {
            pluginUtilities.register = function (register) { //Set the temp variable here if called.
                pluginName = register.name;
            };

            loadedPlugin = runPlugin(pluginUtilities, data);
        } catch (e) {
            // Handle initialise Fail
            console.error("%cError in a plugin initialise","color:red;background-color:#ccc");
            if (DEBUG_FULL) {
                console.log('PluginManager_loadPlugin: error loading plugin ' + pluginURL + ' ' + e.message);
            }
        }

        if (loadedPlugin) {
            var pluginObject = {name: pluginName, plugin: loadedPlugin, utils: pluginUtilities};
            arrayReference.push(pluginObject);
            pluginUtilities.register = function(register) { //Change the function to amend existing- maybe bad to allow this, changing name after init?
                if (DEBUG_FULL) {
                    console.log('PluginUtils: Plugin at: ' + pluginObject.name + ' named as ' + register.name);
                }
                pluginObject.name = register.name;
            };
            try {
                loadedPlugin.pluginInitialisation(pluginUtilities);
            } catch (e) {
                // Handle initialise Fail
                console.error("%cError in a plugin initialise","color:red;background-color:#ccc");
                if (DEBUG_FULL) {
                    console.log('PluginManager_loadPlugin: error loading plugin ' + pluginURL + ' ' + e.message);
                }
                player.dispatch({type: "pluginInitialisationFailed", properties: {url: pluginURL}});
                getPluginErrorFunction(player, SMPError.PLUGIN_INITIALISE_FAIL, e.message, pluginURL)();

                if (PluginManager.failedArray.indexOf(pluginURL) === -1) {
                    checkEndOfPluginLoads();
                }
                return;
            }

            player.dispatch({type: "pluginLoaded", url: pluginURL, name: pluginName});
            player.trackAction('plugin_manager', 'plugin_loaded', {'plugin_url': pluginURL,is_background:true});

        } else {
            player.dispatch({type: "pluginLoadFailed", properties: {url: pluginURL}});
            getPluginErrorFunction(player, SMPError.PLUGIN_LOAD_FAIL, "", pluginURL)();
        }

        if (PluginManager.failedArray.indexOf(pluginURL) === -1) {
            checkEndOfPluginLoads();
        }

    });
}

function PluginManager_getPluginList() {
    return PluginManager.pluginArray;
}

var PluginManager = {
    pluginArray : [],
    urls : {},
    playerInterface : null,
    mediaPlayer : null,
    loadPlugin : PluginManager_loadPlugin,
    init : PluginManager_init,
    resizeFix : PluginManager_resizeFix,
    resizeFixEnd : PluginManager_resizeFixEnd,
    resizeFixComplete : PluginManager_resizeFixComplete,
    isPluginLoading : PluginManager_isPluginLoading,
    getPluginList: PluginManager_getPluginList
};
//For a propertyName, returns the .toString found as the value for that property.
var PropertySplitter = function(propertyName) {
    return function(obj){
        return ((obj[propertyName] || obj[propertyName] === 0) && typeof (obj[propertyName].toString === "function")) ? obj[propertyName].toString() : null;
    };
};

//Add the items in orderPropertyNames to the array in that order. Leave out items not in orderedPropertyNames
var PropertyCombiner = function(property, orderedPropertyNames) {
    return function(array) {
        var ret = [];
        var testProperty = null;
        var fnPropertiesEqual = function(a) { return a[property] === testProperty; };
        for (var i = 0; i < orderedPropertyNames.length; i++) {
            testProperty = orderedPropertyNames[i];
            ret = ret.concat(array.filter(fnPropertiesEqual));
        }

        return ret;
    };
};

//Sort the array according to the order in orderedPropertyNames. Items not in the list to the back.
var PropertySorter = function(property, orderedPropertyNames) {
    return function(array) {
        return Utils.stableSort(array, function(a, b) {
            return orderedPropertyNames.indexOf(a[property]) - orderedPropertyNames.indexOf(b[property]);
        });
    };
};

var ConnectionTree = (function() {

    function split(node, splitProperties) {
        
        var splitter = new PropertySplitter (splitProperties[0]);
        var unknownCount = 0;
        while (node._data.length > unknownCount) {
            var value = node._data[unknownCount];
            var key = splitter(value);
            if (!key) {
                unknownCount++;
            } else {
                if (!node[key]) {

                    var clonedSplitPath = Utils.clone(node._splitPath);
                    clonedSplitPath[splitProperties[0]] = key;

                    node[key] = {
                        _data: [],
                        _splitPath: clonedSplitPath

                    };
                }
                node[key]._data.push(value);
                node._data.splice(0, 1);
            }
        }

        if (splitProperties.length > 1) {
            for (var k in node) {
                if (k != "_data" && k != "_splitPath" && node.hasOwnProperty(k)) {
                    split(node[k], splitProperties.slice(1, splitProperties.length));
                }
            }
        }
    }

    function combine(node, combinerArray) {
        var ret = [];
        //Collect the children
        for (var k in node) {
            if (k != "_data" && k != "_splitPath" && node.hasOwnProperty(k)) {
                var nextCombinerArray = combinerArray.length > 1 ? combinerArray.slice(1, combinerArray.length) : [];
                ret = ret.concat(combine(node[k], nextCombinerArray));
            }
        }

        if (node._data) {
            ret = ret.concat(node._data);
        }

        //Apply a sort to the whole thing.
        if(combinerArray[0]) {
            ret = combinerArray[0](ret, node._splitPath);
        }

        return ret;
    }

    //Call with array of splitters(makes the tree) or combiners(flattens the tree) for each level.
    //Splitter should take a single connection and for its level, return a key. (e.g., a protocol level splitter would return 'http' or 'https' etc.)
    //Combiner is the inverse of splitter and called at each level on an array of the combined children data. (e.g., sort 'https' before 'http')
    var ConnectionTree = function(splitProperties, combiners) {
        var ct = this;

        ct.splitProperties = splitProperties;
        ct.combiners = combiners ? combiners : [];
        ct.root = {
            _data: [],
            _splitPath: {}
        };

        return ct;
    };

    ConnectionTree.prototype.getCombinedConnections = function() {
        var ct = this;
        return combine(ct.root, ct.combiners);
    };

    ConnectionTree.prototype.addData = function(connectionArray) {
        var ct = this;
        ct.root._data = connectionArray.slice();
        split(ct.root, ct.splitProperties);
    };

    return ConnectionTree;
})();


/**
 * Load balancing of CDN usage
 *
 */
var LoadBalancing = (function () {
    var bitrateFloor = {};
    var bitrateCeiling = {};
    var suppressType = [];
    var forceConnectionSupplier;
    var mainMediatorHref = 'http://open.stage.bbc.co.uk/mediaselector/5/select/version/2.0/vpid/{id}/format/json/mediaset/journalism-http-mobile/jsfunc/{callback}';
    var cvidMediatorHref = null;
    var samlMediatorHref = null;
    var preferProtocol = 'http';
    var maintainTheLock = false;

    function preferPlainOverDashSort(a,b) {
        if (a=='dash' && b=='plain') {
            return 1;
        }
        if (b=='dash' && a=='plain') {
            return -1;
        }
        return 0;
    }

    var preferPlainOverDash = false;

    function getFlashAvailable(connections,ignoreLock) {
        for (var i=0;i<connections.length;i++) {
            if (!maintainTheLock || ignoreLock) {
                if (connections[i].protocol == "rtmp" || connections[i].format=="hds") {
                    return true;
                }
                if (connections[i].mimetype=="video/x-flv") {
                    return true;
                }
            } else {
                if (connections[i].format=="hds" && connections[i].protocol=="https") {
                    return true;
                }
            }
        }
        return false;
    }


function rstr_sha1(a){return binb2rstr(binb_sha1(rstr2binb(a),a.length*8));}
function rstr2hex(c){var f="0123456789abcdef";var b="";var a;for(var d=0;d<c.length;d++){a=c.charCodeAt(d);b+=f.charAt((a>>>4)&15)+f.charAt(a&15);}return b;}
function rstr2binb(b){var a=Array(b.length>>2);for(var c=0;c<a.length;c++){a[c]=0;}for(c=0;c<b.length*8;c+=8){a[c>>5]|=(b.charCodeAt(c/8)&255)<<(24-c%32);}return a;}
function binb2rstr(b){var a="";for(var c=0;c<b.length*32;c+=8){a+=String.fromCharCode((b[c>>5]>>>(24-c%32))&255);}return a;}
function binb_sha1(v,o){v[o>>5]|=128<<(24-o%32);v[((o+64>>9)<<4)+15]=o;var y=Array(80);var u=1732584193;var s=-271733879;var r=-1732584194;var q=271733878;var p=-1009589776;for(var l=0;l<v.length;l+=16){var n=u;var m=s;var k=r;var h=q;var f=p;for(var g=0;g<80;g++){if(g<16){y[g]=v[l+g];}else{y[g]=bit_rol(y[g-3]^y[g-8]^y[g-14]^y[g-16],1);}var z=safe_add(safe_add(bit_rol(u,5),sha1_ft(g,s,r,q)),safe_add(safe_add(p,y[g]),sha1_kt(g)));p=q;q=r;r=bit_rol(s,30);s=u;u=z;}u=safe_add(u,n);s=safe_add(s,m);r=safe_add(r,k);q=safe_add(q,h);p=safe_add(p,f);}return Array(u,s,r,q,p);}
function sha1_ft(e,a,g,f){if(e<20){return(a&g)|((~a)&f);}if(e<40){return a^g^f;}if(e<60){return(a&g)|(a&f)|(g&f);}return a^g^f;}
function sha1_kt(a){return(a<20)?1518500249:(a<40)?1859775393:(a<60)?-1894007588:-899497514;}
function safe_add(a,d){var c=(a&65535)+(d&65535);var b=(a>>16)+(d>>16)+(c>>16);return(b<<16)|(c&65535);}
function bit_rol(a,b){return(a<<b)|(a>>>(32-b));}


    function getToken(str) {
        return "/atk/"+rstr2hex(rstr_sha1(("7dff7671d0c697fedb1d905d9a121719938b92bf"+str)))+"/asn/1";
    }

    function updateSupplier(connection,type) {
        var sup = connection.supplier+"";
        var protocol = connection.protocol === 'https' ? '_https': '';
        if (sup.split('_').length<2) {
            connection.supplier = type.substring(0,1)+"_"+sup+"_"+connection.format+protocol;
        } else {
            if (sup.split('_').length==2 || (type=="audio" && sup.split('_').length==3)) {
                connection.supplier = sup+"_"+connection.format+protocol;
            }
        }
    }


    function filterNull(mediaConnection) {
        return !!mediaConnection;
    }
    function filterLock(mediaConnection) {
        if (maintainTheLock && (location.protocol + '').toLowerCase() === 'https:') {
            return (mediaConnection.protocol === 'https');
        }
        return true;
    }

    function filterDuplicateHref(mediaConnection, existing) {
        for (var i=0;i<existing.length;i++) {
            if (mediaConnection.href === existing[i].href) {
                return false;
            }
        }
        return true;
    }

    function filterFck(mediaConnection) {
        if (forceConnectionSupplier) {
            return (mediaConnection.supplier+'').indexOf(forceConnectionSupplier)>-1;
        }
        if (Device.noSupportForLocationHeader) {
            var supplier = mediaConnection.supplier+'';
            if (supplier.indexOf('bidi_') > -1 && supplier.indexOf('nonbidi_') < 0) {
                return false;
            }
        }
        return true;
    }

    function filterHref(mediaConnection) {
        var url = mediaConnection.href+"";
        return (url.indexOf("http://")===0 || url.indexOf("https://")===0 || url.indexOf("blob:")===0 || url.indexOf("file://")===0);
    }

    function filterSuppressedType(mediaConnection) {
        return suppressType.indexOf(mediaConnection.format ? mediaConnection.format : 'plain') === -1;
    }

    function filterBitrate(mediaConnection, filteredConnections, mediaItem) {
        if (mediaItem.kind != '360' && mediaConnection.format==="plain") {
            var connectionBitrateFloor = bitrateFloor.plain;
            var connectionBitrateCeiling = bitrateCeiling.plain;
            return !((connectionBitrateFloor && mediaConnection.bitrate < connectionBitrateFloor) ||
                   (connectionBitrateCeiling && mediaConnection.bitrate > connectionBitrateCeiling));
        }
        return true;
    }

    function filterDashProtocolDowngrade(mediaConnection) {
        return !(mediaConnection.format === 'dash' && (location.protocol + '').toLowerCase() === 'https:' && (mediaConnection.href + '').toLowerCase().indexOf('http:') === 0);
    }



    function dpwPrioritySort(a, b) {
        if (a.dpw && b.dpw) {
            return b.dpw - a.dpw;
        }
        if (a.dpw) {
            return -1;
        }
        if (b.dpw) {
            return 1;
        }
        // no dpw, use regular priority
        return a.priority-b.priority;
    }

    function validate(mediaItem, onMobileNetwork) {
        if (DEBUG_FULL) { console.log("LoadBalancing, validate, mediaItem: ", mediaItem ); }

        if (!mediaItem || !mediaItem.connections || (mediaItem.connections.length<2)) {
            return;
        }
        sortMediaConnections(mediaItem, onMobileNetwork);

        if (DEBUG_FULL) {
            console.log('Ordered connections:', mediaItem.connections);
        }
    }

    function getProtocolOrder(mediaItem) {
        var ret;
        if (mediaItem.preferProtocol=='https' || preferProtocol=='https') {
            ret = ['https', 'http'];
        } else {
            ret = ['http', 'https'];
        }

        return ret;
    }

    function dpwSort(connections) {
        var total = 0;
        var number = 0;
        if (connections.length<2) {
            return connections;
        }

        for (var i=0;i<connections.length;i++){
            var dpw = connections[i].dpw;
            if ( dpw > 0 && dpw<=100){
                number++;
                total += dpw;
            } else {
                // explicitly set everything else to null
                connections[i].dpw = null;
            }
        }

        connections.sort(dpwPrioritySort);
        if(total === 0){
            return connections; // No dpw - so just default to priority based sorting above
        }

        // if there's over 100 in total, only use highest, and set the
        // second priority one to the remainder;
        if (total>100) {
            for (i=1;i<connections.length;i++) {
                connections[i].dpw = null;
            }
            connections.sort(dpwPrioritySort);
            connections[1].dpw = 100 - connections[0].dpw;
            number=2;
        } else {
            if (total<100) {
                for (i=0;i<connections.length;i++) {
                    if (connections[i].dpw==null) {
                        connections[i].dpw = 100-total;
                        total = 100;
                        break;
                    }
                }
                // add the remainder split between first two if there
                // were none with null
                // XXX this isn't actually specified in
                // https://confluence.dev.bbc.co.uk/display/MediaSelector/Connection+Selection+and+Load+Balancing
                // but is what flash does.
                if (total<100) {
                    var diff = (100-total)/2;
                    connections[0].dpw+=diff;
                    connections[1].dpw+=diff;
                }
            }
        }

        if (number>0) {
            // if we're doing DPW, unshift the selected one to the
            // front of the array
            var randomPercentage = Math.round(Math.random()*100);
            total = 0;
            for (i=0;i<connections.length;i++) {
                var connection = connections[i];
                total+=connection.dpw;
                if (randomPercentage<total) {
                    connections.splice(i,1);
                    connections.unshift(connection);
                    break;
                }
            }
        }
        return connections;
    }

    /**
     * Return all available media connections' bitrates
     *
     */
    /*function getPlainBitrates(mediaConnections) {
        var allBitrates = [];
        mediaConnections.forEach(function(mediaConnection) {
            if(mediaConnection.format=="plain" && mediaConnection.bitrate && (allBitrates.indexOf(mediaConnection.bitrate) === -1)) {
                allBitrates.push(mediaConnection.bitrate);
            }
        });
        // sort numerically ascending
        return allBitrates.sort(Utils.sortSimple);
    }*/

    function getOrderedPlaybackTypes(mediaItem) {

        if(mediaItem.backgroundVideo) {
            return [ 'plain' ];
        }

        var isAudioItem = Utils.isItemAudio(mediaItem);
        // Still try HLS if it's ondemand audio or there's no dash available
        var skipDash = Device.filterDash || (mediaItem.kind == '360' && (Device.ios || Device.macSafari));
        var skipHls = (mediaItem.flashAvailable && Device.preferVideoFallbackOverHLS && !isAudioItem) || (mediaItem.kind == '360' && (Device.ios || Device.macSafari));

        var orderedPlaybackTypes = [ 'plain', 'hls', 'dash' ];

        //Decide if we want Dash/Hls on this device
        var supportsDash = (isAudioItem ? Device.supportsAudioDash : Device.supportsVideoDash);
        if (supportsDash && Device.supportsHls && !skipHls) {
            if (Device.preferHls) {
                orderedPlaybackTypes = [ 'hls', 'dash', 'plain' ];
            } else {
                orderedPlaybackTypes = [ 'dash', 'plain', 'hls' ];
            }
        } else {
            if (supportsDash) {
                orderedPlaybackTypes = [ 'dash', 'plain', 'hls' ];
            } else {
                if (Device.supportsHls) {
                    orderedPlaybackTypes = [ 'hls', 'plain', 'dash' ];
                }
                // else use the default plain,hls,dash
            }
        }

        if (skipHls) {
            orderedPlaybackTypes = orderedPlaybackTypes.filter(isNotHls);
        }
        if (skipDash) {
            orderedPlaybackTypes = orderedPlaybackTypes.filter(isNotDash);
        }
        if (preferPlainOverDash) {
            orderedPlaybackTypes= Utils.stableSort(orderedPlaybackTypes, preferPlainOverDashSort);
        }

        if (DEBUG_FULL) {
            console.log('orderedPlaybackTypes: ', orderedPlaybackTypes);
        }

        return orderedPlaybackTypes;
    }

    function isNotHls(str) {
        return str!='hls';
    }

    function isNotDash(str) {
        return str!='dash';
    }

    function toLower(obj,otherwise) {
        if (obj) {
            return obj.toLowerCase();
        }
        return otherwise;
    }

    function toFloat(obj,otherwise) {
        var val=parseFloat(obj);
        if (!isNaN(val)) {
            return val;
        }
        return otherwise;
    }

    function getSortArrayByBitrate(onMobileNetwork) {

        var sortArrayByBitrate = function (a, splitPath) {

            if(onMobileNetwork && splitPath.format && (splitPath.format == 'plain')) {
                return Utils.stableSort(a, function(a, b) {
                    return a.bitrate-b.bitrate;
                });
            } else {
                return Utils.stableSort(a, function(a, b) {
                    return b.bitrate-a.bitrate;
                });
            }

        };

        return sortArrayByBitrate;

    }



    function sortMediaConnections(mediaItem, onMobileNetwork) {
        var splitProperties = [
            "format",
            "protocol",
            "bitrate"
        ];

        var combiners = [
            new PropertyCombiner("format", getOrderedPlaybackTypes(mediaItem)),
            new PropertySorter("protocol", getProtocolOrder(mediaItem)),
            getSortArrayByBitrate(onMobileNetwork),
            dpwSort
        ];

        var ct = new ConnectionTree(splitProperties, combiners);
        ct.addData(mediaItem.connections);

        mediaItem.connections = ct.getCombinedConnections();
    }

    function sortSubtitleConnections(mediaItem) {
        if(mediaItem.subtitleConnections && mediaItem.subtitleConnections.length > 1) {
            var splitters = [
                "protocol"
            ];

            var combiners = [
                new PropertySorter("protocol", getProtocolOrder(mediaItem)),
                dpwSort
            ];

            var ct = new ConnectionTree(splitters, combiners);
            ct.addData(mediaItem.subtitleConnections);

            mediaItem.subtitleConnections = ct.getCombinedConnections();
        }
    }

    function sortThumbnailConnections(mediaItem) {
        if (mediaItem.thumbnailConnections && mediaItem.thumbnailConnections.length > 1) {
            var splitters = [
                "protocol"
            ];

            var combiners = [
                new PropertySorter("protocol", getProtocolOrder(mediaItem)),
                dpwSort
            ];

            var ct = new ConnectionTree(splitters, combiners);
            ct.addData(mediaItem.thumbnailConnections);

            mediaItem.thumbnailConnections = ct.getCombinedConnections();
        }
    }
    /**
    * Constructor for LoadBalancing class
    *
    */
    var LoadBalancing = {
        getFlashAvailable: getFlashAvailable,
        setConfig : function(config) {
            if (!config) {
                return;
            }
            bitrateFloor = config.bitrateFloor;
            bitrateCeiling = config.bitrateCeiling;
            suppressType = config.suppressType;
            forceConnectionSupplier = config.mediator && config.mediator.fck;
            mainMediatorHref = config.mediatorHref || mainMediatorHref;
            cvidMediatorHref = config.cvidMediatorHref;
            samlMediatorHref = config.samlMediatorHref || samlMediatorHref;
            maintainTheLock = config.maintainTheLock;

            preferPlainOverDash = config.preferPlainOverDash && Device && Device.possiblyPreferPlainOverDash;
            preferProtocol = config.preferProtocol || 'http';
        },
        sortThumbnailConnections : sortThumbnailConnections,
        sortSubtitleConnections : sortSubtitleConnections,
        validateConnections : validate,
        mediate : function(mediaItem, onMobileNetwork, callback) {
            if (mediaItem.mediationRequested) {
                return;
            }
            mediaItem.mediationRequested = true;

            // Build the mediator URL
            var mediatorHref = mainMediatorHref.replace('{id}', mediaItem.identifier);
            if (mediaItem.identifier && mediaItem.identifier.indexOf("CVID:")===0) {
                if (cvidMediatorHref) {
                    mediatorHref = cvidMediatorHref.replace('{id}', mediaItem.cvid);
                } else {
                    Utils.asyncDelay(function() {
                                         mediaItem.mediationAttempted = true;
                                         mediaItem.mediationRequested = false;
                                         mediaItem.result = {
                                             reason: "nocvidmediator"
                                         };
                                         callback(mediaItem);
                                     });
                    return;
                }
            }

            if (mediaItem.samltoken && samlMediatorHref) {
                mediatorHref  = samlMediatorHref.replace('{id}', mediaItem.identifier)+"?saml_auth="+mediaItem.samltoken;
            }
            if (!isNaN(mediaItem.ceiling) && mediaItem.ceiling!==0) {
                mediatorHref = mediatorHref.replace('/jsfunc','/ceiling/'+mediaItem.ceiling+'/jsfunc');
            }
            if(Device && Device.supportPlayerFallback) {
                mediatorHref = mediatorHref.replace('/jsfunc',getToken(mediaItem.identifier)+'/jsfunc');
            }

            mediatorHref=mediatorHref.replace("http://","https://");

            if (DEBUG_FULL) { console.info('Mediator url : ' + mediatorHref); }

            var initiateTime = Utils.now();

            Utils.getJSON(mediatorHref, function(data) {
                //var mediaItem = null;
                var mediaConnections = [];
                if (!data) {
                    data={result:"error"};
                }
                var reason=data.result;
                mediaItem.mediationTime = Utils.now() - initiateTime;
                if(data.media && data.media.length) {
                    var mediaType = '';

                    for (var i=0;i<data.media.length;i++) {
                        var media = data.media[i];
                        // if width/height == 2 then it's 360
                        if ((parseInt(media.width,10)/parseInt(media.height,10))==2) {
                            mediaItem.type = mediaItem.kind="360";

                        }
                        mediaType = media.kind;

                        for (var j=0;j<media.connection.length;j++) {
                            var connection = media.connection[j];
                            if (mediaType == 'audio' || mediaType == 'video') {
                                var mediaConnection = {
                                    href : connection.href,
                                    protocol : toLower(connection.protocol),
                                    mimetype : toLower(media.type),
                                    encoding : toLower(media.encoding),
                                    format : toLower(connection.transferFormat,'plain'),
                                    supplier : toLower(connection.supplier),
                                    bitrate : toFloat(media.bitrate,0),
                                    priority : toFloat(connection.priority),
                                    dpw : toFloat(connection.dpw)
                                };

                                updateSupplier(mediaConnection, mediaType);

                                mediaConnections.push(mediaConnection);
                                if (mediaType!==mediaItem.type && !(mediaType=='video' && mediaItem.type=='360')) {
                                    mediaItem.type = mediaType;
                                }
                            } else if (!mediaItem.backgroundVideo && mediaType == 'captions') {
                                mediaItem.subtitleConnections.push(new SubtitlesItem(
                                    connection.href,
                                    toLower(connection.protocol),
                                    toLower(connection.supplier),
                                    toFloat(connection.dpw)
                                ));
                            } else if (!mediaItem.backgroundVideo && mediaType == "thumbnails") {
                                mediaItem.thumbnailConnections.push({
                                    href: connection.href,
                                    protocol: toLower(connection.protocol),
                                    supplier: toLower(connection.supplier),
                                    dpw: toFloat(connection.dpw),
                                    priority: toFloat(connection.priority)
                                });
                            }
                        }
                    }
                    if (mediaConnections.length) {
                        mediaItem.connections = mediaConnections;
                        sortMediaConnections(mediaItem, onMobileNetwork);
                        validate(mediaItem, onMobileNetwork);

                        for (var k=1;k<mediaConnections.length;k++) {
                            var cs=mediaConnections[k].supplier;
                            for (var l=0;l<k;l++) {
                                if (mediaConnections[l].supplier==cs) {
                                    mediaConnections[l].supplier = cs = cs+'_';
                                }
                            }
                        }


                        mediaItem.originalConnections = Utils.clone(mediaConnections);
                    } else {
                        reason = "noMedia";
                    }
                    if (!mediaItem.backgroundVideo) {
                        sortSubtitleConnections(mediaItem);
                        sortThumbnailConnections(mediaItem);
                    }
                }

                mediaItem.mediationAttempted = true;
                mediaItem.mediationRequested = false;

                mediaItem.result = {
                    reason: reason
                };

                mediaItem.flashAvailableUnlocked = getFlashAvailable(mediaConnections,true); 
                if (Device.flashLockMatters) {
                    mediaItem.flashAvailable = getFlashAvailable(mediaConnections);
                } else {
                    mediaItem.flashAvailable = mediaItem.flashAvailableUnlocked;
                }



                if (DEBUG_FULL) {
                    console.log('Mediated Item:', mediaItem);
                }
                callback(mediaItem);
            });

        },
        /**
         * Pick the initial media connection
         *
         */
        pickInitialMediaConnection : function(mediaItem, onMobileNetwork) {
            validate(mediaItem,onMobileNetwork);
            var mediaConnections = (mediaItem.connections ? mediaItem.connections : []);
            // if there are any connections
            if(mediaConnections.length > 0) {
                return {index:0, connection:mediaConnections[0]};
            }

            return {};
        },
        filter: function(mediaItem) {
            var filteredConnections = [];
            var length = mediaItem.connections.length;
            var filterRules = [filterNull, filterSuppressedType, filterHref, filterBitrate, filterFck, filterDashProtocolDowngrade, filterDuplicateHref, filterLock];
            if (length==1 && filterHref(mediaItem.connections[0]) && filterLock(mediaItem.connections[0])) {
                // if there's only 1 connection, we just try and play it, unless it's not valid url or we need the lock
                return true;
            }
            for (var i=0;i<length;i++) {
                var add = true;
                var mediaConnection = mediaItem.connections[i];
                if (DEBUG_FULL) { console.info(mediaConnection); }

                for (var j=0;j<filterRules.length;j++) {
                    if (!filterRules[j](mediaConnection, filteredConnections, mediaItem)) {
                        if (DEBUG_FULL) {
                            console.info('filtered out connection due to rule ('+j+') ', filterRules[j].name);
                        }
                        add = false;
                        break;
                    }
                }

                if (add) {
                    if (DEBUG_FULL) { console.info('add ' + mediaConnection.format + ' media connection ', mediaConnection.href); }
                    filteredConnections.push(mediaConnection);
                }
            }

            mediaItem.connections = filteredConnections;
            mediaItem.originalConnections = Utils.clone(filteredConnections);
            return filteredConnections.length>0;
        },

        /**
         * Identify if it is possible to switch to another connection
         * based on what is currently playing and whether you would filter
         * the current format. Returns nothing, or filtered potential
         * connections to switch to
         */
        getAlternateMediaConnections: function(player, removeFormat, extraSupplier) {
            // > 1 is not a bug - we need at least two items (the current one, and the potential new one) to switch!
            if (player.mediaItem && !player.mediaItem.failFast && player.mediaItem.connections && player.mediaItem.connections.length > 1) {
                var mediaConnections = player.mediaItem.connections;
                var filteredConnections = [];

                var currentConnection = mediaConnections[0];
                if (currentConnection.format == "plain") {
                    // never remove plain format, plain 404's are treated
                    // as cannot playback format...
                    removeFormat = false;
                }

                for (var i = 1; i < mediaConnections.length; i++) {
                    if (removeFormat) {
                        if (mediaConnections[i].format != currentConnection.format) {
                            filteredConnections.push(mediaConnections[i]);
                        }
                    } else {
                        if (player.mediaItem.failedConnections.indexOf(mediaConnections[i].supplier)<0 && mediaConnections[i].supplier!=extraSupplier) {
                            filteredConnections.push(mediaConnections[i]);
                        }
                    }
                }

                // if the MediaItem has seen a playing event already,
                // don't swap formats or protocols
                if (player.mediaItem.hasSeenPlaying) {
                    var connection = player.mediaConnection;
                    if (connection) {
                        var newConnection = filteredConnections[0];
                        if (connection.format!=newConnection.format || connection.protocol != newConnection.protocol) {
                            if (DEBUG_FULL) { console.log("Have successfully played the previous format/protocol, so refusing switch",connection,newConnection); }
                            return;
                        }
                    }
                }

                if (filteredConnections.length) {
                    return filteredConnections;
                }
            }
        },
        /**
        * Switch to next media item connection on same bitrate (if available)
        *
        */
        // XXX can we have a manual test with BIDI etc. do we do a cdn
        // failover across HLS when an HLS fails?
        switchMediaConnection: function(player, removeFormat,restore) {
            var filteredConnections;
            if (restore) {
                filteredConnections = Utils.clone(player.mediaItem.originalConnections);
            } else {
                filteredConnections = LoadBalancing.getAlternateMediaConnections(player, removeFormat);
            }

            // if there is another connection to switch to
            if (filteredConnections) {

                // XXX this isn't actually true, we can attempt to
                // remove plain and therefore fail over, we can also
                // not failover but still change format If we've not
                // removed a format, then we've, is this badly named
                // or doing the wrong thing?
                player.failedOver = !removeFormat;

                if (DEBUG_FULL) {
                    console.log("previous Connections:", player.mediaItem.connections);
                }

                // change to the highest bitrate available - this assumes
                // all formats are not available.
                var newMediaConnection = filteredConnections[0];
                player.mediaItem.connections = filteredConnections;

                if (removeFormat) {
                    player.mediaItem.originalConnections = Utils.clone(filteredConnections);
                }
                if (DEBUG_FULL) {
                    console.log("new Connections:", filteredConnections);
                }

                // set media src and start playback
                if (DEBUG_FULL) { console.log('switchMediaConnection : ' + newMediaConnection.href); }
                player.failingOver = true;

                var newHref = newMediaConnection.href;

                // if it's HLS the time code doesn't work, need to use
                // the seeking method.
                if (player.mediaItem.live && newMediaConnection.format=='hls' ) {
                    player.timeHelper.setStartTimeAvailable(false);
                    player.waitingForStartTime = player.waitingForStartTime || player.time;
                } else {
                    player.waitingForStartTime = player.waitingForStartTime || player.time - player.timeHelper.presentationTimeOffset;
                }

                player.dispatch({type:"waiting"});
                player.mediaSrc(newHref);

                if (DEBUG_FULL) {
                    console.log("Failing over, new HREF is", newHref);
                }

                // XXX do we actually want to call play on anything?
                // won't the autoplay manage it, in which case do we
                // actually want to do the reverse and play with
                // autoplay here?
                if (player.tryingToPlay && newMediaConnection !== 'dash') {
                    player.mediaPlayer.play();
                }

                return true;
            }
            return false;
        },
        onAdsProcessed : function(mediaItem, data){
            mediaItem.mediationAttempted = true;
            mediaItem.connections = [];
            if(!data.error){
                mediaItem.connections[0] = {
                    href : data.mediaFile.src,
                    // PRESUME EVERYTHING IS PLAIN FOR NOW?
                    format: 'plain'
                    // protocol : (connection.protocol ? connection.protocol.toLowerCase() : null),
                    // mimetype : (media.type ? media.type.toLowerCase() : null),
                    // encoding : (media.encoding ? media.encoding.toLowerCase() : null),
                    // format : (connection.transferFormat ? connection.transferFormat.toLowerCase() : 'plain'),
                    // supplier : (connection.supplier ? connection.supplier.toLowerCase() : null),
                    //bitrate : (!isNaN(parseFloat(media.bitrate)) ? parseFloat(media.bitrate) : 0),
                    // priority : (!isNaN(parseFloat(connection.priority)) ? parseFloat(connection.priority) : null),
                    // dpw : (!isNaN(parseFloat(connection.dpw)) ? parseFloat(connection.dpw) : null)
                };
            }
        },
    };

    return LoadBalancing;
})();
var DashEvents = (function () {
    var DRM_ERROR_TIMEOUT = 10000;
    var SLOW_COUNT_TIMER = 360000; 
    var WEBCAST_MANIFEST_RELOAD_INTERVAL = 60 * 1000;

    function getElementType(mp, player) {
        if (mp == player.els.video) {
            return "video";
        }
        if (mp == player.els.audio) {
            return "audio";
        }
        if (mp == player.els['360']) {
            return "360";
        }
        return "unknown";
    }

    function manifestRewriteDashCodec(manifest) {
        var periods = manifest.Period_asArray;
        if (periods) {
            for (var i=0;i<periods.length;i++) {
                var sets = periods[i].AdaptationSet_asArray;
                if (sets) {
                    for (var j=0;j<sets.length;j++) {
                        var representations = sets[j].Representation_asArray;
                        if (representations) {
                            for (var k=0;k<representations.length;k++) {
                                var rep = representations[k];
                                if (rep.mimeType == "video/mp4") {
                                    rep.codecs = rep.codecs.replace("avc3","avc1");
                                }
                            }
                        }
                    }
                }
            }
        }
        return manifest;
    }

    function manifestRewriteStartNumber(manifest) {
        var periods = manifest.Period_asArray;
        if (periods) {
            for (var i=0;i<periods.length;i++) {
                var sets = periods[i].AdaptationSet_asArray;
                if (sets) {
                    for (var j=0;j<sets.length;j++) {
                        changeTemplateStartNumber(sets[j]);
                    }
                }
            }
        }
    }

    function changeTemplateStartNumber(node) {
        var segmentTemplate = node.SegmentTemplate;
        if (segmentTemplate) {
            if (segmentTemplate.startNumber === 0) {
                segmentTemplate.startNumber = 1;
            }
        }
    }

    //Get the first presentationTimeOffset in the manifest.
    //It is assumed that the first one found is valid for the whole.
    function getPresentationTimeOffset(manifest) {
        var periods = manifest.Period_asArray;
        if (periods) {
            for (var i = 0; i < periods.length; i++) {
                var sets = periods[i].AdaptationSet_asArray;
                if (sets) {
                    for (var j = 0; j < sets.length; j++) {
                        var st = sets[j].SegmentTemplate;
                        if (st && 'presentationTimeOffset' in st) {
                            var timescale = st.timescale || 1;
                            return st.presentationTimeOffset / timescale;
                        }
                    }
                }
            }
        }
        return 0;
    }

    function decideIfLiveWebcast(manifest) {
        var periods = manifest.Period_asArray;
        if (periods[0]) {
            var sets = periods[0].AdaptationSet_asArray;
            for (var i=0;i<sets.length;i++) {
                if (sets[i].InbandEventStream) {
                    return true;
                }
            }
        }
        return false;
    }

    function bufferLevelChangedStartHack(player, newBufferLevel) {
        // SMPHTML-432 - needed for FF41, but verified fixed in FF nightlies (18/08/15)
        if (player.tryingToPlay && player.mediaPlayer.paused) {
            if (newBufferLevel > 10 || (player.buffered >= player.duration)) {
                player.mediaPlayer.play();
            }
        }
    }

    var allDashEvents = [];
    var dashLoading = false;
    // cookie access errors in sandboxed frames
    try {
        var dashJsDebug = document.cookie.indexOf('dashJsDebug=true') > -1;
    } catch (e) {}
    var DASH_LOAD_TIMEOUT = 10000;

    function dashJsLoadTimeout() {
        dashLoading = false;
        for (var i=0; i<allDashEvents.length; i++) {
            allDashEvents[i].errorSettingUp();
        }
    }

    function setDRMErrorTimeout(dashEvents) {
        clearDrmErrorTimeout(dashEvents);
        dashEvents.drmErrorTimeout = setTimeout(dashEvents.errorHandler, DRM_ERROR_TIMEOUT,dashEvents.player, SMPError.DRM_ERROR_TIMEOUT);
    }

    function clearDrmErrorTimeout(dashEvents) {
        if (dashEvents.drmErrorTimeout) {
            clearTimeout(dashEvents.drmErrorTimeout);
            dashEvents.drmErrorTimeout = null;
        }
    }

    function loadDashJs(experimental) {
        if (!dashLoading) {
            dashLoading = true;
            var script = document.createElement('script');
            script.type = 'text/javascript';

            var timeout = setTimeout(dashJsLoadTimeout,DASH_LOAD_TIMEOUT);

            script.onload=function() {
                clearTimeout(timeout);
                dashLoading = false;
                makeErrorMap();
                for (var i=0; i<allDashEvents.length; i++) {
                    allDashEvents[i].ready();
                }
            };
            var baseUrl = '/emp/dashjs/2.9.2-4';
            if (experimental) {
                baseUrl = '/emp/dashjs/2.9.2-4';
            }
            if (DEBUG_FULL) {
                script.src = baseUrl+'/dash.all.debug.js';
            } else {
                script.src = baseUrl+'/dash.all.min.js';
            }

            document.body.appendChild(script);
        }
    }

    function getHandlers(dashEvents) {
      var player = dashEvents.player;

      function clearSlowdownloadCount(stream) {
          dashEvents.slowDownloadCount[stream] = 0;
      }

      return {
          metricAdded : {
              HttpList: function (e) {
                  var stream = e.mediaType;
                  // maybe consider live/od here as live is more
                  // common to have the odd delay
                  var terribleCounts = e.mediaType=="video" ? 3 : 10;
                  var req = e.value;
                  // Wait until it's finished loading and check to see if it
                  // took longer than its duration to download
                  // only do this if fragment duration is larger than 2s
                  if (req.interval && req.type === "MediaSegment" && req.quality === 0 && req._mediaduration>2 && ((req.interval / 1000 / req._mediaduration) > 1.05)) {
                      // just a warning so doesn't need to be async
                      if (dashEvents.canDispatchFragmentWarning) {
                          dashEvents.errorHandler(player, SMPError.DOWNLOAD_WAS_SLOW);
                          dashEvents.canDispatchFragmentWarning = false;
                      }
                      clearTimeout(dashEvents.timersClearedOnReset[stream]);
                      dashEvents.timersClearedOnReset[stream] = setTimeout(clearSlowdownloadCount, SLOW_COUNT_TIMER, stream);
                      dashEvents.slowDownloadCount[stream]++;
                      // If it's taken ages to load and we're on the
                      // lowest bitrate *and* we're buffering, then give
                      // up.
                      if (dashEvents.slowDownloadCount[stream] > terribleCounts && player.mediaPlayer.playbackRate === 0) {
                          player.mediaPlayer.pause();
                          dashEvents.delayedErrorHandler(player, SMPError.DOWNLOADS_OFTEN_SLOW, req.url);
                      }
                  }
              },
              BufferLevel: function (e) {
                  var stream = e.mediaType;
                  var currentBufferLevel = e.value.level / 1000;

                  // XXX not sure the point of this being inside,
                  // it's just an assignment of a thing with no
                  // getters?   Just to avoid the small hack check?

                  if (currentBufferLevel != dashEvents.bufferLevel[stream]) {
                      if (Device.requiresManualDashPlay) {
                          bufferLevelChangedStartHack(player, currentBufferLevel);
                      }
                      dashEvents.bufferLevel[stream] = currentBufferLevel;
                  }
              },
              DVRInfo: function (e) {
                  //The +30 is here to stop restarting to live failing on some webcasts where the beginning is advertised but not available.
                  dashEvents.dashPlayer.currentStart = Math.min(e.value.range.end, e.value.range.start + 30);
                  dashEvents.dashPlayer.currentEnd = e.value.range.end;

                  if (!dashEvents.player.timeHelper.startTimeAvailable) {
                      dashEvents.player.timeHelper.setStartTimeAvailable(true);
                  }

                  // XXX This currently sets to infinity for ondemand
                  // makes us think we have a window, and disables seeking
                  //dashEvents.updateRewindWindow();
              }
          }
      };
    }

    function clampRatioForVisibility(dashEvents, videoRatio) {
        if (dashEvents.dashPlayer) {
            var maxRatio = dashEvents.player.consideredMobileConnection ? 0 : 0.3;
            if (document.hidden && videoRatio > maxRatio) {
                if (DEBUG_FULL) {
                    console.log('Visibility: hidden. Quality ratio clamped to: ' + maxRatio + '; was: ' + videoRatio);
                }
                return Math.min(maxRatio, videoRatio);
            }
            if (DEBUG_FULL) {
                console.log('Visibility: visible. Quality ratio at: ' + videoRatio);
            }
        }
        return videoRatio;
    }

    function getHandleVisibilityChanged(dashEvents) {
        var visibilityChangedTimer;
        var visibilityChange = function() {
            if (dashEvents.dashPlayer) {
                var quality = dashEvents.player.quality || new Quality();
                var videoRatio = quality.getVideoRatio();
                videoRatio = clampRatioForVisibility(dashEvents, videoRatio);
                dashEvents.dashPlayer.setMaxAllowedRepresentationRatioFor('video', videoRatio);
            }
        };

        return function() {
            clearTimeout(visibilityChangedTimer);
            var delay = !document.hidden ? 100 : 2500;
            visibilityChangedTimer = setTimeout(visibilityChange, delay);
            
        };
    }

    function manifestChanged(dashEvents) {
        var player = dashEvents.player;
        return function(event) {
            // Calculate the starting representation
            var initialVideoBitrate = dashEvents.initialBitrate.video || 0;
            var initialAudioBitrate = dashEvents.initialBitrate.audio || 0;

            try {
                if (window.localStorage) {
                    if (!initialVideoBitrate && localStorage.smphtml5_vbr) {
                        initialVideoBitrate = parseInt(localStorage.smphtml5_vbr,10);
                    }
                    if (!initialAudioBitrate && localStorage.smphtml5_abr) {
                        initialAudioBitrate = parseInt(localStorage.smphtml5_abr,10);
                        if (player.consideredMobileConnection) {
                            initialAudioBitrate = Math.min(97, initialAudioBitrate);
                        }
                    }
                }
            } catch (e) {
                // localStorage can error
            }
            // XXX what if the local storage says the ABR is manifest
            // 0, ie they're on a really bad connection, we decide to
            // offer up a higher one again?  Seems bad?
            if (!initialAudioBitrate) {
                var ratio = 0.6;
                // XXX need to check it's a number too surely?
                if (player.config.hasOwnProperty('startingQuality')) {
                    ratio = player.config.startingQuality;
                } else {
                    if (player.config.consideredMobileConnection) {
                        ratio = 0.1;
                    } else {
                        if (player.config.hasOwnProperty('quality')) {
                            switch (player.config.quality) {
                            case 'hd':
                            case 'high':
                                ratio = 1;
                                break;
                            case 'medium':
                                if (player.mediaContainer.clientWidth >= 832) {
                                    ratio = 1;
                                }
                                break;
                            case 'low':
                                ratio = 0;
                            }
                        }
                    }
                }
                dashEvents.dashPlayer.setInitialRepresentationRatioFor('video', ratio);
                dashEvents.dashPlayer.setInitialRepresentationRatioFor('audio', ratio);
            } else {
                dashEvents.dashPlayer.setInitialBitrateFor('video', initialVideoBitrate/1000);
                dashEvents.dashPlayer.setInitialBitrateFor('audio', initialAudioBitrate/1000);
            }

            // SMPHTML-445
            // XXX QoS assumes the 48/96 values - if this logic is changed, update that too
            if (player.mediaItem && player.mediaItem.type == 'video') {
                dashEvents.dashPlayer.setAutoSwitchQualityFor('audio', false);
                if (player.consideredMobileConnection) {
                    dashEvents.dashPlayer.setInitialBitrateFor('audio', 48);
                } else {
                    // So dash.js handles this a bit weirdly. Set 97 for 96.
                    // Step through abrController:getQualityForBitrate if you're bored.
                    dashEvents.dashPlayer.setInitialBitrateFor('audio', 97);
                }
            } else {
                dashEvents.dashPlayer.setAutoSwitchQualityFor('audio', true);
            }

            if (player.mediaItem && player.mediaItem.live) {
                dashEvents.isLiveWebcast = decideIfLiveWebcast(event.data);
            }
            if (dashEvents.isLiveWebcast) {
                var webcastAttributes = parseWebcastAttributes(event.data);
                
                if (webcastAttributes.ended) {
                    dashEvents.isLiveWebcast = false;
                    clearWebcastRefresh(dashEvents);
                    dashEvents.player.timeHelper.setInbandEndTime(webcastAttributes.endTime);
                    if (DEBUG_FULL) { console.log("Manifest switched from dynamic to static - considering webcast ended at time " + webcastAttributes.endTime); }
                    //TODO Raise external event?
                } else {
                    setupWebcastRefresh(dashEvents);
                }
            }
            
            if (dashEvents.manifestRefreshCallback) {
                var callback = dashEvents.manifestRefreshCallback;
                dashEvents.manifestRefreshCallback = null;
                callback();
            }
        };
    }

    function parseWebcastAttributes(manifest) {
        return {
            ended: !isNaN(manifest.mediaPresentationDuration),
            endTime: manifest.mediaPresentationDuration//Not corrected for presentationTimeOffset
        };
    }

    function setupWebcastRefresh(dashEvents) {
        if (!dashEvents.webcastRefreshId) {
            dashEvents.webcastRefreshId = setInterval(
                function() {
                    var th = dashEvents.player.timeHelper;
                    if (th.latestSeek - (dashEvents.player.time) > WEBCAST_MANIFEST_RELOAD_INTERVAL / 1000) {
                        dashEvents.refreshManifest();
                    }
                },
                WEBCAST_MANIFEST_RELOAD_INTERVAL
            );
        }
    }

    function clearWebcastRefresh(dashEvents) {
        if (dashEvents.webcastRefreshId) {
            clearInterval(dashEvents.webcastRefreshId);
            dashEvents.webcastRefreshId = null;
        }
    }

    function streamingBitrateChanged(dashEvents, stream, newBitrate, idx) {
        dashEvents.streamingBitrate[stream] = {rate: newBitrate, index:idx};
    }

    function bitrateChanged(dashEvents, stream, newBitrate, idx) {
        var player = dashEvents.player;
        var mediaConnection = player.mediaConnection;

        player.dispatch({
            type: 'bitrateChanged',
            streamType: stream,
            previousBitrate: dashEvents.bitrate[stream] ? dashEvents.bitrate[stream].rate : NaN,
            newBitrate: newBitrate,
            newIndex: idx
        });
        dashEvents.bitrate[stream] = {rate:newBitrate, index:idx};

        var codecs={all:[]};
        var processors = player.dashEvents.dashPlayer.getActiveStream().getProcessors() || [];
        for (var i=0;i<processors.length;i++) {
            var processor=processors[i];
            if (processor) {
                var streamInfo = processor.getMediaInfo();
                if (streamInfo) {
                    var codecRE=new RegExp('.*codecs="\(.*\)"',"gim");
                    var c=codecRE.test(streamInfo.codec);
                    if (c) {
                        var type=streamInfo.type;
                        codecs.all.push(RegExp.$1);
                        if (type!="all") {
                            codecs[type]=RegExp.$1;
                        }
                    }
                }
            }
        }
        

        player.dispatch({
            type: 'loadedmetadata',
            bitrate: dashEvents.currentBitsPerSecond, //kbps
            codecs : codecs.all.join(','),
            audioCodec: codecs.audio,
            videoCodec: codecs.video,
            cdn: mediaConnection ? mediaConnection.supplier : null
        });
        try {
            if (window.localStorage) {
                if (stream === 'audio') {
                    localStorage.setItem('smphtml5_abr', newBitrate);
                } else {
                    if (stream === 'video') {
                        localStorage.setItem('smphtml5_vbr', newBitrate);
                    }
                }
            }
        } catch (error) {
            if (DEBUG_FULL) {
                console.log('Localstorage write failed: ' + error);
            }
        }

        dashEvents.slowDownloadCount[stream] = 0;
    }

    function getBitrateFromIndex(dashEvents, stream, index) {
        var info = dashEvents.dashPlayer.getBitrateInfoListFor(stream) || [];

        for (var i = 0; i < info.length; i++) {
            if (info[i].qualityIndex === index) {
                return info[i].bitrate;
            }
        }

        return -1;
    }

    function metricHandler(handlers) {
        return function(e) {
            var metric = e.metric;
            if (handlers[e.type] && handlers[e.type][metric]) {
                handlers[e.type][metric](e);
            }
        };
    }

    var ErrorMap;
    function makeErrorMap() {
        var e = window.dashjs.MediaPlayer.errors;
        
        ErrorMap = {}; 
        //This seems to be if DashJS is unable to decide if it's an MPD or a MSS manifest, i.e. choosing which parser is applied - fired if something not an mpd being used
        ErrorMap[e.MANIFEST_ERROR_ID_PARSE_CODE] =                  SMPError.MPD_PARSE_ERROR;
        //Dash is unreasonable and throws errors if media is multiplexed
        ErrorMap[e.MANIFEST_ERROR_ID_MULTIPLEXED_CODE] =            SMPError.MPD_PARSE_ERROR;
        ErrorMap[e.MANIFEST_LOADER_PARSING_FAILURE_ERROR_CODE] =    SMPError.MPD_PARSE_ERROR;
        ErrorMap[e.MANIFEST_ERROR_ID_NOSTREAMS_CODE] =              SMPError.MPD_NO_STREAMS;
        ErrorMap[e.MANIFEST_ERROR_ID_CODEC_CODE] =                  SMPError.NO_SUPPORTED_CODECS;
        ErrorMap[e.DOWNLOAD_ERROR_ID_MANIFEST_CODE] =               SMPError.MPD_LOAD_FAIL;
        ErrorMap[e.DOWNLOAD_ERROR_ID_INITIALIZATION_CODE] =         SMPError.INIT_FRAGMENT_LOAD_FAIL;
        ErrorMap[e.DOWNLOAD_ERROR_ID_CONTENT_CODE] =                SMPError.STREAM_FRAGMENT_LOAD_FAIL;
        ErrorMap[e.MEDIASOURCE_TYPE_UNSUPPORTED_CODE] =             SMPError.DASH_MEDIASOURCE_ERROR;
        ErrorMap[e.DOWNLOAD_CONTENT_LENGTH_MISMATCH] =              SMPError.STREAM_FRAGMENT_CONTENT_LENGTH_MISMATCH;
    }

    function error(dashEvents) {
        return function(e) {
            var dashError = window.dashjs.MediaPlayer.errors;
            if (DEBUG_FULL) { console.log('Dash Error: '+e.error,e); }
            
            if (e.error === "key_session") { //If the problem lies with DRM not having a key, it's external to SMP
                //We fire the DRM_KEY error and if it's not fixed after a timeout, we fire a more serious error.
                dashEvents.delayedErrorHandler(dashEvents.player, SMPError.DRM_KEY, e.event);
                setDRMErrorTimeout(dashEvents);
                return;
            }

            var extra;
            if (e.error && e.error.code) { //New style dash errors (object and not text)
                switch (e.error.code) {
                    case dashError.CAPABILITY_MEDIASOURCE_ERROR_CODE:
                    case dashError.CAPABILITY_MEDIAKEYS_ERROR_CODE:
                        dashEvents.delayedErrorHandler(dashEvents.player, SMPError.DEVICE_NOT_SUPPORTED);
                        break;
                    case dashError.DOWNLOAD_ERROR_ID_MANIFEST_CODE:
                    case dashError.DOWNLOAD_ERROR_ID_INITIALIZATION_CODE:
                    case dashError.DOWNLOAD_ERROR_ID_CONTENT_CODE:
                    case dashError.DOWNLOAD_CONTENT_LENGTH_MISMATCH:
                        var url = e.error.data.request.url;
                        var status = e.error.data.response.status;
                        extra = url + "_" + status;
                        break;
                    case dashError.MANIFEST_ERROR_ID_CODEC_CODE:
                        var codec = e.error ? e.error.message : "(unknown)";
                        extra = codec.match(/\(.*\)/g)[0] || "unknown";
                        break;
                    case dashError.MANIFEST_ERROR_ID_PARSE_CODE:
                    case dashError.MANIFEST_ERROR_ID_MULTIPLEXED_CODE:
                    case dashError.MANIFEST_LOADER_PARSING_FAILURE_ERROR_CODE:
                    case dashError.MANIFEST_ERROR_ID_NOSTREAMS_CODE:
                        break;
                }

                var map = ErrorMap[e.error.code];
                if (map) {
                    if (map == SMPError.NO_SUPPORTED_CODECS) {
                        if (dashEvents.player.config.ignoreCodecErrors) {
                            return;
                        }
                    }
                    if (map === SMPError.INIT_FRAGMENT_LOAD_FAIL || map === SMPError.STREAM_FRAGMENT_LOAD_FAIL) {
                        map = handleBadFragmentError(dashEvents, map, e);
                    }
                    if (map == SMPError.NO_SUPPORTED_CODECS) {
                            Utils.asyncDelay(dashEvents.reset,[],dashEvents);
                        if (dashEvents.player.supportFallback ) {
                            map=SMPError.NO_SUPPORTED_CODECS_FAILOVER;
                            Utils.asyncDelay(dashEvents.player.fallbackAsAppropriate, [],dashEvents.player);
                        }
                    }
                    dashEvents.delayedErrorHandler(dashEvents.player, map, extra);
                } else {
                    if (DEBUG_FULL) {
                        console.log("Unmapped dash error - no action: " + e.error);
                    }
                }
            }
        };
    }

    function removeSupplier(dashEvents, serviceLocation) {
        //Store a list of connections that we removed with this; is used by the
        //player error handling code to remove from media item, but we can't do it until after 
        //LoadBalancing.alternateConnections because it wants to know the current connection
        dashEvents.removedList = dashEvents.connections.filter(function(c) {
              return c.supplier === serviceLocation;
        });
        
        dashEvents.connections = dashEvents.connections.filter(function(c) {
            return c.supplier !== serviceLocation;
        });

        //This is just a fix for when we flow down the not baseUrlFailover method
        //Because we didn't make the manifest baseUrl in these cases, servicelocation doesn't match supplier
        //so the above doesn't work.
        if (dashEvents.connections.length === 1) {
            dashEvents.removedList = dashEvents.connections;
            dashEvents.connections = [];
        }
    }

    //Handle a fragment not downloading - This returns a lower priority code if baseURL failover happened.
    function handleBadFragmentError(dashEvents, map, e) {
        var ret = map;
        var request = e.error.data.request;
        var streamDuration = request.mediaInfo.streamInfo.duration;
        var fragmentStartTime = request.startTime;
        if (streamDuration - fragmentStartTime < 1) {
            // MP-2876 Suppress DASH errors in last fragment (if within 1s of end) by overriding stream duration to force early end
            //dashEvents.dashPlayer.setDuration(fragmentStartTime);
            dashEvents.player.endOnWaiting = true;
            return SMPError.FRAGMENT_END_DOWNLOAD_INFORMATION;
        }
        
        removeSupplier(dashEvents, request.serviceLocation);
        // we only want one critical version, when there are no more.
        if (dashEvents.dashFailoversRemaining() === 0 && !dashEvents.streamFragmentErrorSent) {
            dashEvents.streamFragmentErrorSent = true;
        } else {
            switch(map) {
                case SMPError.INIT_FRAGMENT_LOAD_FAIL:
                    ret = SMPError.INIT_FRAGMENT_DOWNLOAD_INFORMATION;
                    break;
                case SMPError.STREAM_FRAGMENT_LOAD_FAIL:
                    ret = SMPError.FRAGMENT_DOWNLOAD_INFORMATION;
                    break;
            }
        }

        return ret;
    }

    function qualityChangeRequested(dashEvents) {
        return function(e) {
            var newQuality = e.newQuality;
            var mediaType = e.mediaType;
            if (DEBUG_FULL) {
                console.log('Quality change requested for', e.mediaType, 'to index', e.newQuality, 'due to', e.reason, "buffer is:",dashEvents.bufferLevel);
            }

            streamingBitrateChanged(dashEvents, mediaType, getBitrateFromIndex(dashEvents, mediaType, newQuality), newQuality);
        };
    }

    function qualityChangeRendered(dashEvents) {
        return function(e) {
            var newQuality = e.newQuality;
            var mediaType = e.mediaType;
            if (DEBUG_FULL) {
                console.log('Quality change rendering for', mediaType, 'to index', newQuality);
            }

            bitrateChanged(dashEvents, mediaType, getBitrateFromIndex(dashEvents, mediaType, newQuality), newQuality);
        };
    }

    function baseUrlSelected(dashEvents) {
        return function(e) {
            var result;
            for (var i = 0; i < dashEvents.connections.length; i++) {
                var c = dashEvents.connections[i];
                if (c.href.indexOf(e.baseUrl.url) >= 0) { //Rather make dash give the original manifest url for proper comparison
                    result = c;
                    break;
                }
            }
            if (result && dashEvents.connections[0] !== result) {
                pushToFrontOfArray(dashEvents.connections, result);
                pushToFrontOfArray(dashEvents.player.mediaItem.connections, result);

                dashEvents.player.dispatch({
                    type: "changingsrc",
                    supplier: result.supplier,
                    encoding: result.encoding,
                    format: result.format
                });
            }
        };
    }

    function pushToFrontOfArray(array, item) {
        var index = array.indexOf(item);
        if (index > 0) {
            array.splice(index, 1);
            array.unshift(item);
        }

        return index >= 0;
    }

    //This happens when we run out of baseurls; or something in the manifest is wrong
    function baseUrlResolutionFailed(dashEvents) {
        return function() {
            if (dashEvents.player.mediaItem.dashAlternates) {
                if (DEBUG_FULL) {
                    console.log("DASH BaseUrl resolution failed");
                }
                dashEvents.connections = [];
            }
        };
    }

    function onNeedKey(dashEvents) {
        return function(e) {
            dashEvents.player.dispatch(e);
        };
    }

    function onManifestValidityChanged(dashEvents) {
        return function(e) {
            if (!isNaN(e.newDuration)) {
                dashEvents.player.timeHelper.setInbandEndTime(e.newDuration);
            }
        };
    }

    function initialiseEvents(dashEvents) {
        if (dashEvents.eventsInitialised) {
            return;
        }

        dashEvents.errorHistory = [];
        var player = dashEvents.player;
        var dp = dashEvents.dashPlayer;
        var eventsEnum = dashjs.MediaPlayer.events;
        
        Utils.multiAddEventListener(dp, [eventsEnum.METRIC_ADDED, eventsEnum.METRIC_UPDATED], metricHandler(getHandlers(dashEvents)));
        dp.addEventListener(eventsEnum.STREAM_INITIALIZED, function() {
            var bitrateInfoListVideo = dp.getBitrateInfoListFor('video') || [];
            var bitrateInfoListAudio = dp.getBitrateInfoListFor('audio') || [];
            var videoBitrates = [];
            var audioBitrates = [];

            for(var i=0; i < bitrateInfoListVideo.length; i++) {
                videoBitrates.push({
                    bitrate: bitrateInfoListVideo[i].bitrate,
                    qualityIndex: bitrateInfoListVideo[i].qualityIndex
                });
            }

            for(i=0; i < bitrateInfoListAudio.length; i++) {
                audioBitrates.push({
                    bitrate: bitrateInfoListAudio[i].bitrate,
                    qualityIndex: bitrateInfoListAudio[i].qualityIndex
                });
            }

            player.dispatch({
                type: "streamInitialized",
                bitrates: videoBitrates || audioBitrates,
                audioBitrates : audioBitrates
            });

        });
        dp.addEventListener(eventsEnum.MANIFEST_LOADED, manifestChanged(dashEvents));
        dp.addEventListener(eventsEnum.ERROR, error(dashEvents));
        dp.addEventListener(eventsEnum.QUALITY_CHANGE_REQUESTED, qualityChangeRequested(dashEvents));
        dp.addEventListener(eventsEnum.QUALITY_CHANGE_RENDERED, qualityChangeRendered(dashEvents));
        // Detect pre-availability live content
        dp.addEventListener(eventsEnum.AST_IN_FUTURE, function(e) {
                                if (DEBUG_FULL) {
                                    console.log('AST_IN_FUTURE:',e);
                                }
                                // if the spinner is going to be shown
                                // for longer than 20 seconds, trigger
                                // the error, otherwise don't
                                if (e.delay>20000) {
                                    clearTimeout(dashEvents.timersClearedOnReset.AST_IN_FUTURE);
                                    dashEvents.timersClearedOnReset.AST_IN_FUTURE=setTimeout(Utils.callErrorFunction,100,player,SMPError.CONTENT_NOT_AVAILABLE_PRE_START);
                                }
                            });
        if (eventsEnum.BASEURL_SELECTED) { // let this work with -8 DASH for now
            dp.addEventListener(eventsEnum.BASEURL_SELECTED, baseUrlSelected(dashEvents));
            dp.addEventListener(eventsEnum.URL_RESOLUTION_FAILED, baseUrlResolutionFailed(dashEvents));
        }
        dp.addEventListener("needkey", onNeedKey(dashEvents));
        dp.addEventListener(eventsEnum.MANIFEST_VALIDITY_CHANGED, onManifestValidityChanged(dashEvents));

        // Might be better to have a systemwide "throttle" which also
        // reduces other reasons for dropping and just have this
        // respond to that?
        dashEvents._visibilityChangeHandler = getHandleVisibilityChanged(dashEvents);
        document.addEventListener("visibilitychange", dashEvents._visibilityChangeHandler);

        dashEvents.eventsInitialised = true;
    }

    function detachEvents(dashEvents) {
        var eventsEnum = dashjs.MediaPlayer.events;
        var dpEventList = [
            eventsEnum.METRIC_ADDED,
            eventsEnum.METRIC_UPDATED,
            eventsEnum.MANIFEST_LOADED, 
            eventsEnum.ERROR,
            eventsEnum.QUALITY_CHANGE_REQUESTED,
            eventsEnum.QUALITY_CHANGE_RENDERED,
            eventsEnum.AST_IN_FUTURE,
            eventsEnum.MEDIA_FRAGMENT_LOADED,
            eventsEnum.BASEURL_SELECTED,
            eventsEnum.SERVICE_LOCATION_BLACKLIST_CHANGED,
            eventsEnum.URL_RESOLUTION_FAILED,
            eventsEnum.STREAM_INITIALIZED,
            eventsEnum.MANIFEST_VALIDITY_CHANGED,
            "needkey"
        ];
        var dp = dashEvents.dashPlayer;

        for (var i = 0; i < dpEventList.length; i++) {
            dp.removeEventListener(dpEventList[i]);
        }

        document.removeEventListener("visibilitychange", dashEvents._visibilityChangeHandler);

        dashEvents.eventsInitialised = false;
    }

    function getGettersAndSetters(dashEvents) {
        return {
            currentBitsPerSecond : {
                get: function () {
                    // need to deal with the event that came out before and
                    // suppress the NaN when we only get 1?
                    return dashEvents.bitrate ? Math.round((dashEvents.bitrate.video.rate + dashEvents.bitrate.audio.rate) / 1000) : 0; //kbps
                }
            },
            currentBitrateIndex: {
                get: function() {
                    var index;
                    if (dashEvents.bitrate) {
                        index = dashEvents.bitrate.video.index;
                    }
                    if (isNaN(index)) {
                        index = dashEvents.bitrate.audio.index;
                    }
                    return index;
                }
            },
            dashJsDebug: {
                get: function() {
                    return dashJsDebug;
                },
                set: function(value) {
                    var dashPlayer = this.dashPlayer;
                    dashJsDebug = !!value;
                    if (dashPlayer) {
                        dashPlayer.getDebug().setLogToBrowserConsole(value);
                    }
                }
            }
        };
    }

    function addAlternateBaseUrls(dashEvents, manifest) {
        if (!dashEvents.player.isLive) {
            // For VOD, we loop through the MS connections and add each alternate base url
            var baseUrls = [];
            var connections = dashEvents.connections.slice(1);
            var currentConnection = dashEvents.connections[0];
            // Current connection added as highest priority
            baseUrls.push({
                __text: manifest.baseUri,
                'dvb:priority': 1,
                serviceLocation: currentConnection.supplier
            });

            connections = connections.filter(function(c) { return (c.supplier+"").indexOf('bidi') == -1; });
            
            var priority = 2;
            // When a connection fails, any priority that features that supplier is blacklisted.
            // So we need to split up into many priorities of all possible combinations of failover.
            // This won't follow a proper load-balancing path for more than two alternate baseURLs for failover.
            // All of the connections are available for the first failover and chosen by weight.
            // Then after it would go by index. (So everything is fine as long as we have 3 cdns.
            for (var i = 0; i < connections.length; i++) {
                baseUrls.push(mapConnectionToBaseUrl(connections[i], priority));
            }
            priority++;
            if (connections.length > 1) {
                for (var j = 0; j < connections.length; j++) {
                    baseUrls.push(mapConnectionToBaseUrl(connections[j], priority++));
                }
            }

            
            if (DEBUG_FULL) {
                console.log("Setting base urls:",baseUrls);
            }
            if (baseUrls.length) {
                manifest.BaseURL_asArray = baseUrls;
                delete manifest.baseUri;
                if (dashEvents.player.mediaItem) {
                    dashEvents.player.mediaItem.dashAlternates = true;
                }
            }
        }
    }

    function mapConnectionToBaseUrl(connection, priority) {
        var href = connection.href;
        var splitUrl = href.split('.ism/');
        if (!splitUrl || href.indexOf('.ism/') == -1) {
            return; // Something odd going on, give up
        }
        var baseUrl = splitUrl[0] + '.ism/';
        return {
            __text: baseUrl,
            'dvb:priority': priority,
            'dvb:weight': connection.dpw,   //We are assuming at this point that resolution of incomplete mediaselector dpw values is done already.
            serviceLocation: connection.supplier || baseUrl
        };
    }

    function hasLiveSubtitles(mediaItem, supportLive) {
        return mediaItem && mediaItem.simulcast && !Utils.isItemAudio(mediaItem) && supportLive;
    }

    function addLiveSubtitlesItem(dashEvents, fragmentLoadEvent, mediaItem, manifest) {
        var baseUrl = manifest.BaseURL && manifest.BaseURL.__text;

        if (!baseUrl) {
            baseUrl = manifest.originalUrl;
        }

        if (baseUrl) {
            var liveSubsItem = new LiveSubtitlesItem(baseUrl,false);
            mediaItem.subtitleConnections.push(liveSubsItem);
            var fragmentLoadCallback = function (e) {
                if (e.chunk.mediaInfo.type == "video") {
                    liveSubsItem.onFragmentLoaded(e.chunk, e.request);
                }
            };
            dashEvents.dashPlayer.addEventListener(fragmentLoadEvent, fragmentLoadCallback);
            if (dashEvents.player.Subtitles) {
                dashEvents.player.Subtitles.onNewConnection();
            }

            return true;
        }

        return false;
    }

    function setProtectionData(dashEvents, protectionData) {
        if (dashEvents.dashPlayer) {
            clearDrmErrorTimeout(dashEvents);
            dashEvents.dashPlayer.setProtectionData(protectionData);
        }
    }

    var DashEvents = function (player, experimentalDash, errorHandlerFunction) {
        var dashEvents = this;
        allDashEvents.push(dashEvents);
        // load dash player etc.
        dashEvents.player = player;
        dashEvents.experimentalDash = experimentalDash;

        Utils.defineProperties(dashEvents,getGettersAndSetters(dashEvents));

        if (!window.dashjs) {
            loadDashJs(experimentalDash);
        } else {
            dashEvents.ready(dashjs.MediaPlayer);
        }
        this.codecRefresh = -1;
        this.setup();
        
        dashEvents.errorHandler = errorHandlerFunction; //We want to react differently to an error if we are in a preload state

        return this;
    };

    DashEvents.prototype = {
        ready: function() {
            var mp = dashjs.MediaPlayer;
            var dashEvents = this;
            if (!dashEvents.dashPlayer) {
                dashEvents.dashPlayer = mp().create();
                dashEvents.dashPlayer.addEventListener = dashEvents.dashPlayer.on;
                dashEvents.dashPlayer.removeEventListener = dashEvents.dashPlayer.off;
                dashEvents.dashPlayer.getDebug().setLogToBrowserConsole(dashJsDebug);
                dashEvents.dashPlayer.initialize();
                initialiseEvents(dashEvents);
            }
            if (dashEvents.connections && dashEvents.connections.length) {
                dashEvents.go();
            }
        },
        resetSrc: function() {
            var dashEvents = this;
            dashEvents.connections=null;
        },
        setSrc: function(connections) {
            var dashEvents = this;
            dashEvents.connections = connections.filter(function(c) { return c.protocol === connections[0].protocol && c.format=="dash"; });
            if (dashEvents.player.config.disableDashBaseUrlFailover || dashEvents.player.isLive) {
                dashEvents.connections = dashEvents.connections.slice(0,1);
            }
            if (!window.dashjs) {
                // XXX this always loads the non-experimental as a fallback
                loadDashJs();
            } else {
                dashEvents.ready(dashjs.MediaPlayer);
            }
        },
        updatePortalSize:function() {
            var dashEvents = this;
            if (dashEvents.dashPlayer) {
                clearTimeout(dashEvents.portalResizer);
                dashEvents.portalResizer = setTimeout(dashEvents.dashPlayer.updatePortalSize.bind(dashEvents.dashPlayer), 300);
            }
        },
        applyQuality: function () {
            var dashEvents = this;
            var player = dashEvents.player;
            var quality = player.quality || new Quality();
    
            if (dashEvents.dashPlayer) {
                dashEvents.dashPlayer.setMaxAllowedRepresentationRatioFor("video", clampRatioForVisibility(dashEvents, quality.getVideoRatio()));
                dashEvents.dashPlayer.setMaxAllowedRepresentationRatioFor("audio", quality.getAudioRatio());
                dashEvents.dashPlayer.setMaxAllowedBitrateFor("video", NaN);
    
                if(!isNaN(parseInt(player.config._dashVideoIndex))) {
                    dashEvents.dashPlayer.setAutoSwitchQualityFor('video', false);
                    dashEvents.dashPlayer.setLimitBitrateByPortal(false);
                    dashEvents.dashPlayer.setQualityFor('video', player.config._dashVideoIndex);
                } else {
                    dashEvents.dashPlayer.setAutoSwitchQualityFor('video', true);
                    var mediaItem = player.mediaItem;
                    var limitByPortal = !(mediaItem && mediaItem.kind === "360");
                    dashEvents.dashPlayer.setLimitBitrateByPortal(limitByPortal);
                }
    
                if(!isNaN(parseInt(player.config._dashAudioIndex))) {
                    dashEvents.dashPlayer.setAutoSwitchQualityFor('audio', false);
                    dashEvents.dashPlayer.setQualityFor('audio', player.config._dashAudioIndex);
                } else {
                    if(player.isAudio) {
                        dashEvents.dashPlayer.setAutoSwitchQualityFor('audio', true);
                    }
                }
            }
        },
        go: function() {
            var dashEvents = this;
            var player = dashEvents.player;
            
            dashEvents.dashPlayer.reset();
            if (player.storedProtectionData) {
                setProtectionData(dashEvents, player.storedProtectionData);
            }

            dashEvents.dashPlayer.setSelectionModeForInitialTrack(player.config.lowBandwidth ? 'lowestBitrate' : 'highestBitrate');
            dashEvents.dashPlayer.setScheduleWhilePaused(true);
            dashEvents.dashPlayer.clearDefaultUTCTimingSources();
            dashEvents.dashPlayer.setLimitBitrateByPortal(true);
            dashEvents.dashPlayer.setPortalScale(1);
            dashEvents.dashPlayer.setPortalLimitMinimum(2000);
            dashEvents.dashPlayer.enableLastBitrateCaching(false);
            dashEvents.dashPlayer.enableLastMediaSettingsCaching(false);
            dashEvents.dashPlayer.setBufferToKeep(90);
            
            if (player.config.lowLatencyMode) {
                dashEvents.dashPlayer.setLowLatencyEnabled(true);
            } else {
                dashEvents.dashPlayer.useSuggestedPresentationDelay(false);
                dashEvents.dashPlayer.setLiveDelay(10);
            }

            dashEvents.applyQuality();
            /*
            if (player.config.dvbReporting) {
                if (dashEvents.dashPlayer.setDefaultDVBMetricsEndpoint) {
                    dashEvents.dashPlayer.setDefaultDVBMetricsEndpoint( { "dvb:reportingUrl":RDotReporting.dvbUrl() });
                }
                if (dashEvents.dashPlayer.disableDVBReportingResponseChecking) {
                    dashEvents.dashPlayer.disableDVBReportingResponseChecking(true);
                }
            }
            */
            dashEvents.dashPlayer.setInitialMediaSettingsFor('audio', {
                audioChannelConfiguration: 2
            });

            if (dashEvents.mediaElement) {
                dashEvents.dashPlayer.attachView(dashEvents.mediaElement);
                dashEvents.dashPlayer.updatePortalSize();
            }

            var elType = getElementType(player.mediaPlayer,player);
            var manifestHref = dashEvents.connections[0].href;
            if (player.waitingForStartTime > 0) {
                var uriFragment = player.mediaItem.live && !player.mediaItem.simulcast ? "#r=" : "#t=";
                var adjustedTime = player.timeHelper.unixTimeToStreamTime(player.waitingForStartTime);
                manifestHref += uriFragment + adjustedTime  + "s";
                //waitingForStartTime is cleared by the canPlay event.
            }
            dashEvents.dashPlayer.retrieveManifest(manifestHref, function(manifest) {
                // We don't handle the error here, as dash.js dispatches an error event itself.
                if (manifest && dashEvents.connections) {
                    if (dashEvents.connections.length > 1 && !player.config.disableDashBaseUrlFailover && !manifest.BaseURL) {
                         addAlternateBaseUrls(dashEvents, manifest);
                    }
                    if (Device.requiresDashAVC3CodecHack) {
                        manifest = manifestRewriteDashCodec(manifest);
                    }

                    if (manifest.UTCTiming && manifest.UTCTiming.value=="https://time.akamai.com/?iso") {
                        manifest.UTCTiming.value="https://time.akamai.com/?iso&ms";
                    }

                    if (hasLiveSubtitles(player.mediaItem, player.ui.config.subtitles && player.ui.config.subtitles.supportLiveSubtitles)) {
                        addLiveSubtitlesItem(
                            dashEvents,
                            dashjs.MediaPlayer.events.MEDIA_FRAGMENT_LOADED,
                            player.mediaItem,
                            manifest
                        );
                    }
                    dashEvents.player.timeHelper.setPresentationTimeOffset(getPresentationTimeOffset(manifest) || 0);

                    if (player.mediaItem && player.mediaItem.live) {
                        dashEvents.isLiveWebcast = decideIfLiveWebcast(manifest);
                    }
                    if (dashEvents.isLiveWebcast) {
                        if (parseWebcastAttributes(manifest).ended) {
                            dashEvents.isLiveWebcast = false;
                        }
                    } else {
                        if (player.mediaItem && !player.isAudio && player.mediaItem.live) {
                            manifestRewriteStartNumber(manifest);
                        }
                    }

                    //  XXX surely we only want to do this if there is
                    //  a mediaElement? actually, why would we want to
                    //  do this at all?
                    dashEvents.player.waitingForChange[elType] = false;

                    if (dashEvents.mediaElement) {
                        dashEvents.dashPlayer.setAutoPlay(dashEvents.manuallyFailingOver || dashEvents.mediaElement.autoplay);
                        dashEvents.manuallyFailingOver = false;
                    }
                    dashEvents.dashPlayer.attachSource(manifest);

                    if (!dashEvents.mediaElement) {
                        dashEvents.dashPlayer.preload();
                    }
                }
            });
        },
        reset: function() {
            if (DEBUG_FULL) {
                console.log("calling dash reset");
            }
            var dashEvents = this;
            dashEvents.setup();
            dashEvents.resetSrc();
            if (dashEvents.codecRefresh) {
                clearTimeout(dashEvents.codecRefresh);
                dashEvents.codecRefresh = -1;
            }
            if (dashEvents.dashPlayer) {
                detachEvents(dashEvents);
                dashEvents.dashPlayer.reset();
                dashEvents.dashPlayer = null;
            }
            clearDrmErrorTimeout(dashEvents);
            for (var i in dashEvents.timersClearedOnReset) {
                if (dashEvents.timersClearedOnReset.hasOwnProperty[i]) {
                    clearTimeout(dashEvents.timersClearedOnReset[i]);
                }
            }
            clearWebcastRefresh(dashEvents);
            dashEvents.qualityLimits = null;
        },
        setup: function() {
            var dashEvents = this;
            dashEvents.slowDownloadCount = {video: 0, audio: 0};
            dashEvents.bitrate = {video: {rate:0,index:NaN}, audio: {rate:0,index:NaN}};
            dashEvents.bufferLevel = {};
            dashEvents.streamingBitrate = {video: {rate:0,index:NaN}, audio: {rate:0,index:NaN}};
            dashEvents.streamFragmentErrorSent = false;
            dashEvents.eventsInitialised = false;
            dashEvents.canDispatchFragmentWarning = true;
            dashEvents.isLiveWebcast = false;
            dashEvents.initialBitrate = {};
            dashEvents.timersClearedOnReset = {};
            dashEvents.errorHandler = function() {};
        },
        errorSettingUp: function() {
            var dashEvents = this;
            if (dashEvents.connections && dashEvents.connections.length) {
                dashEvents.errorHandler(dashEvents.player, SMPError.DASH_INIT_TIMEOUT);
                dashEvents.mediaItem = null;
            }
        },
        getHttpRequests: function(type) {
            if (!this.player || !this.dashPlayer) {
                return [];
            }
            var dp = this.dashPlayer;
            var metricsController = dp.getDashMetrics();
            var metrics = dp.getMetricsFor(type);
            return metricsController.getHttpRequests(metrics);
        },
        create : function() {
            // null function to remove complexity in Player.js
            // could probably refactor this more.
        },
        refreshManifest: function(callback){
            var dashEvents = this;
            var dp = dashEvents.dashPlayer;
            if (dp && typeof dp.refreshManifest === 'function') {
                dp.refreshManifest();
                if (callback && !dashEvents.manifestRefreshCallback) {
                    dashEvents.manifestRefreshCallback = callback;
                }
            }
        },
        setMediaElement: function(element) {
            var dashEvents = this;
            dashEvents.mediaElement = element;
            if (dashEvents.dashPlayer) {
                dashEvents.dashPlayer.attachView(dashEvents.mediaElement);
                dashEvents.dashPlayer.updatePortalSize();
            }
        },
        setInitialBitrate: function(bitrate) {
            var dashEvents = this;
            if (!isNaN(bitrate.audio)) {
                dashEvents.initialBitrate.audio = bitrate.audio;
                if (DEBUG_FULL) { console.log("Setting initial dashEvents audio bitrate to " + bitrate.audio); }
            }
            if (!isNaN(bitrate.video)) {
                dashEvents.initialBitrate.video = bitrate.video;
                if (DEBUG_FULL) { console.log("Setting initial dashEvents video bitrate to " + bitrate.video); }
            }
        },
        //errorHandlerFunction should conform to the Utils.callErrorHandler interface
        setErrorHandler: function (errorHandlerFunction) {
            var dashEvents = this;
            dashEvents.errorHandler = errorHandlerFunction;
        },
        delayedErrorHandler: function(player,type,extra,nonPlayer,lowSeverity) {
            var dashEvents = this;
            dashEvents.errorHandler(player,type,extra,nonPlayer,lowSeverity,true);
        },
        getBitrateListFor: function (type) {
            var dashEvents = this;
            var stream = dashEvents.dashPlayer.getActiveStream();
            return stream.getBitrateListFor(type);
        },
        //return the number of connections that can be failed over to.
        dashFailoversRemaining: function () {
            var dashEvents = this;
            if (!dashEvents.connections) {
                return 0;
            }
            var bidi = dashEvents.connections.filter(function(c) {
                return (c.supplier+"").indexOf('bidi') >= 0;
            });
            return dashEvents.connections.length - bidi.length;
        },
        detachView: function() {
            var dashEvents = this;
            dashEvents.dashPlayer.detachView();
        },
        reattachView: function() {
            var dashEvents = this;
            dashEvents.dashPlayer.reattachView(dashEvents.mediaElement);
        }
    };

    return DashEvents;

})();
/**
 * Adds support for event reporting via the RDot System
 *
 */

var RDotReporting = (function() {

                         // XXX This all assumes a single player, this
                         // player specific stuff all needs to be
                         // moved to QoS function and obtained from
                         // there rather than in a static class.

    var baseURL = '//r.test.bbci.co.uk/e';
    var versionString="";
    var player;

    var nonWordRegExp = /\W+/gim;

    var eventCount = 0;

    var errorCounts={ "_1061":97 };


    function getMediaset(player) {
        // XXX This is really not that nice at all, actually.
        var mediasetMatch = (player.config.mediatorHref+'').match(/mediaset\/([^/]+)\//);
        return mediasetMatch ? mediasetMatch[1] : '-';
    }

    /**
     * Constructor for RDotReporting class
     *
     */
    var RDotReporting = function() {
        if (DEBUG_FULL) { console.log('RDotReporting'); }
    };
    
    RDotReporting.params = {};

    RDotReporting.init = function (p, overrideBaseURL) {
        RDotReporting.params = {};
        player = p;
        RDotReporting.ID = Utils.UUID();
        versionString =  p.build;
        if(overrideBaseURL && overrideBaseURL !== '') {
            baseURL = overrideBaseURL.replace(/\/*$/g,'');
        }
    };

    RDotReporting.playlistLoading= function() {
        RDotReporting.ID = Utils.UUID();
    };
    /*
    RDotReporting.dvbUrl = function() {
        var arr = [];
        arr.push(baseURL.replace(/e$/, 'i'));
        arr.push("bbcrd");
        arr.push("-");
        arr.push("smphtml5");
        arr.push(versionString);
        arr.push(player.mediaItem ? player.mediaItem.identifier : "-");
        arr.push(RDotReporting.ID);
        arr.push(player.qos.getMediaType());
        return arr.join("/");
    };
    */

    // XXX temporary for smp-offline until SMP offline passes
    // through a setting saying it's offline.
    var notOffline = ((location.href+'').indexOf('file:')!==0);

    function coreRdot(type,noInfo) {
        eventCount++;
        var arr = [];
        if (type) {
            arr.push(baseURL.replace(/e$/, type));
        } else {
            arr.push(baseURL);
        }
        arr.push("av");
        arr.push("0"); // Format Version
        arr.push("-");
        arr.push("smpj");
        arr.push("1.2.1");
        arr.push(notOffline ? "smphtml5" : "smphtml5offline");
        arr.push(versionString);
        arr.push(RDotReporting.ID);
        arr.push(eventCount);
        arr.push(encodeURIComponent(player.config.counterName));


        var supplierObj = player.mediaConnection || {};
        var supplier = supplierObj.supplier || "-";
        var transferFormat = supplierObj.format || "-";

        arr.push(supplier);
        arr.push(transferFormat);
        arr.push(player.elType);
        var mediaItem = player.mediaItem;
        var liveType = mediaItem ? (player.mediaItem.live ? "live" : "ondemand") : "-";
        arr.push(liveType);

        arr.push( getMediaset(player) );

        var identifier = (player.mediaItem ? player.mediaItem.identifier : "-");
        arr.push(identifier ? identifier :  "-");

        if (!noInfo) {
            arr=arr.concat( player.qos.getInfoData() );
        }
        return arr;
    }

    function assembleURL(extras) {
        var assembledURLArray = coreRdot();
        for (var i=0;i<extras.length;i++) {
            var str=extras[i];
            if (typeof(str) == "object") {
                str = JSON.stringify(str);
            }
            assembledURLArray.push(encodeURIComponent(str));
        }
        return assembledURLArray.join("/");
    }

    function track(url) {
        var img = new Image();
        img.src = url;
    }

    RDotReporting.trackQOSInfo = function(qosInfo, rdotFormat) {
        if (player.config.enableRdotReporting && qosInfo) {
            var arr = coreRdot('i');
            arr.push(rdotFormat);
            arr.push(qosInfo);
            if (DEBUG_FULL) {  console.log( arr.join('/') ); }

            track(arr.join('/'));
        }
    };

    RDotReporting.trackPlayIntent = function() {
        if (player.config.enableRdotReporting) {
            var arr = coreRdot('p',true);
            if (DEBUG_FULL) {  console.log( arr.join('/') ); }
            track(arr.join('/'));
        }
    };

    RDotReporting.trackPlaySuccess = function() {
        if (player.config.enableRdotReporting) {
            var arr = coreRdot('ps',true);
            arr.push(player.mediaItem.mediationTime ? player.qos.player.mediaItem.mediationTime.toFixed(0) : "~");
            arr.push(player.qos.startupTime ? player.qos.startupTime.toFixed(0) : "~");
            if (DEBUG_FULL) {  console.log( arr.join('/') ); }
            track(arr.join('/'));
        }
    };

    RDotReporting.trackError = function(e) {
        if(player.config.enableRdotReporting) {
            if (isNaN( errorCounts['_'+e.code] ) ) {
                errorCounts['_'+e.code] = 0;
            }
            if (errorCounts['_'+e.code]++>=100) {
                return;
            }
            var arr=[e.code+''] ;
            var extra=(e.severity+"").substring(0,1);
            if (e.extra && typeof e.extra=="string") {
                if (e.extra.indexOf('file:')===0) {
                    extra+="~"+e.extra.substring(e.extra.lastIndexOf('/')).replace( nonWordRegExp, "~" );
                } else {
                    extra+="~"+e.extra.replace( nonWordRegExp, "~" );
                }
            }
            arr.push(extra);
            var url = assembleURL(arr);
            track(url);
            return url;
        }
    };

    return RDotReporting;
    
})();
var SWF = (function() {

    var swfId = "p_swfcontainer";
    var DOMID = "htmlSWFPlayer";
    var playWhenHit;
 
    var SUPPORTED_FLASH = 22;
 
    var EDGE_DELAY_TIMEOUT = 10000; // This seems to be an age, but it
                                    // appears to be required, as it
                                    // can take a depressingly long
                                    // time for the event to come out.
 
    // do we need available while setting up UI setting?
    var defaultUIOptions = {
        controls : { enabled:false},
        errorDialog : { enabled:false},
        buffer : { enabled:false},
        cta : { visiblyHidden:true },
        fullscreen : { enabled : false, dblclick : false },
        poster : { enabled:true },
        guidance: { pinRequired : false },
        hideDefaultErrors: true
    };
 
    function getGettersAndSetters(swf) {
        return {
            currentTime: {
                get : function() {
                    return swf._currentTime;
                },
                set : function(time) {
                    swf._currentTime = time;
                    swf.call("currentTime", time);
                }
            },
            volume: {
                get: function() {
                    return swf.player.volume;
                },
                set : function(volume) {
                    swf.call("volume", volume);
                    swf.player.dispatch({type:"volumechange", volume:swf.player._volume,muted:swf.player._muted});
                }
            },
            muted: {
                get: function() {
                    return swf.player.muted;
                },
                set : function(muted) {
                    swf.call("muted", muted);
                    swf.player.dispatch({type:"volumechange", volume:swf.player._volume,muted:swf.player._muted});
                }
            },
            mediaConnection: {
                get: function() {
                    if (swf._mediaConnection) {
                        return swf._mediaConnection;
                    }
                    return { format:'swf' };
                }
            },
            failed: {
                get: function() {
                    return swf._failed;
                },
                set: function(value) {
                    if (!swf.killed) {
                        swf._failed = value;
                        swf.needToPause = false;
                        swf.playOnInitialised = false;
                        Utils.delayedErrorFunction(swf.player,swf._failed,swf._extraFailed);
                    }
                }
            }
        };
    }

    var SWF = function(player) {
        var swf = this;
        swf.player = player;
        swf.style = {};
        swf.timeupdateCount = 0;
        Utils.defineProperties(swf,getGettersAndSetters(swf));
    };
    
    function getPlaylistObject(mediaItem,image) {
        return {
            holdingImageURL: image,
            simulcast:true,
            items:[{
                kind:mediaItem.type == "audio" ? "radioProgramme" : "programme",
                live:mediaItem.live, 
                vpid:mediaItem.identifier,
                samltoken:mediaItem.samltoken,
                ceiling:mediaItem.ceiling
            }]
        };
    }

    function playMediaItem(swf,mediaItem) {
        var options = {};
        var settings = swf.player.config;
        options.noTracking = true;
        options.forceConnectionSupplier = settings.mediator.fck;
        // quality needed in here, or could we just do a default for fallback?
        options.quality = settings.quality;
        options.autoPlay = !swf.noAutoplayBlocked;
        options.loop = settings.loop;
        options.maintainTheLock = settings.maintainTheLock;
        options.mediationUrl = settings.mediatorHref.replace('/format/json/jsfunc/{callback}','/format/xml');
        options.samlMediationUrl = settings.samlMediatorHref.replace('/format/json/jsfunc/{callback}','/format/xml');
    
        options.startTime = settings.startTime;
    
        options.counterName = settings.counterName;
        options.rdotname = "smphtmlflash";
        options.rdotsessionid = RDotReporting.ID;
        options.embedPageURL = settings.embedPageURL;
    
        swf.player.waitingForStartTime = 0;
        swf._currentTime = settings.startTime;
    
        swf._needToSendPlay = true;
    
        if (mediaItem.fallbackPlaylist) {
            options.playlistUrl = mediaItem.fallbackPlaylist;
            if (DEBUG_FULL) {
                console.log("setPlaylistOptions", options);
            }
            swf.call('setPlaylistOptions',options );
        } else {
            var playlistObject = getPlaylistObject(mediaItem,swf.player.ui.getBackgroundImageUrl());
            if (DEBUG_FULL) {
                console.log("setPlaylistObject", playlistObject, options);
            }
            swf.call('setPlaylistObject', { playlist: playlistObject, options : options } );
        }
    }
    
    function getHandleEvent(swf) {
        var count=0;
        return function(domId, event) {
    
            if (DEBUG_FULL) {
                console.log("handleEvent:"+domId, event);
            }
            if (domId!=DOMID) {
                return;
            }
            var firstTime = false;
            if (!swf.seenEvent) {
                swf.seenEvent=true;
                firstTime = true;
            }
            if (!swf._swf) {
                if (count++<20) {
                    setTimeout(getRepeatCaller(domId,event),100);
                } else {
                    swf._extraFailed = "repeat";
                    swf.failed=SMPError.FLASH_NOT_INITIALISED;
                }
                return;
            }
    
            if (firstTime) {
                var version = 0;
                try {
                    var ver = swf._swf.GetVariable("$version");
                    version=parseInt(ver.split(' ')[1],10);
                } catch(e) {
                    if (DEBUG_FULL) {
                        console.log("No version");
                    }
                }
    
                if (version<SUPPORTED_FLASH) {
                    swf._extraFailed = "version_"+version;
                    swf.failed=SMPError.FLASH_NOT_INITIALISED;
                }
            }
    
            var data = event.data || {};
            for (var item in data) {
                if (item!="type") {
                    event[item] = data[item];
                    if (item=="currentDuration") {
                        event.duration = data[item];
                    }
                }
            }
            switch (event.type) {
                case 'initialised': {
                    swf.initialised();
                    return;
                } break;
                case 'mediaItemChanged': {
                    swf.edgeOkay=true;
                    swf.noAutoplayBlocked = false;
                    clearTimeout(swf.edgeReplay);
                    swf.player.mediaItem.subtitleConnections=[];
    
                    // XXX need to deal with thumbnails here too.
                    if (event.captions && event.captions.length>0) {
                        for (var i=0;i<event.captions.length;i++) {
                            var connection = event.captions[i];
                            swf.player.mediaItem.subtitleConnections.push(new SubtitlesItem(
                                     connection.href,
                                     connection.protocol,
                                     connection.identifier));
                        }
                        LoadBalancing.sortSubtitleConnections(swf.player.mediaItem);
                        swf.player.dispatch({type:'mediaItemInfoChanged'});
                    }
                    return;
                } break;
                case 'error':
                {
                    // Pause method failed, so we'll have to stop
                    // happens on live rtmp
                    if (event.code==2009) {
                        swf.call("stop");
                    }
                    if (event.severity == "critical") {
                        if (event.code==1039) {
                            Utils.delayedErrorFunction(swf.player,SMPError.CANNOT_MAINTAIN_LOCK, 1039);
                        } else {
                            Utils.delayedErrorFunction(swf.player,SMPError.FLASH_CRITICAL_ERROR, event.code+"");
                        }
                    }
                    return;
                } break;
                case 'playlistLoaded':
                {
                    if (Device.edge && !swf.edgeOkay && !swf.noAutoplayBlocked) {
                        clearTimeout(swf.edgeReplay);
                        swf.edgeReplay = setTimeout(function() {
                                                    swf.noAutoplayBlocked=true;
                                                    swf.ready=false;
                                                    swf._swf=null;
                                                    document.getElementById(swfId).innerHTML="";
                                                    swf.playItem(swf.player.mediaItem);
                                                },EDGE_DELAY_TIMEOUT);
                    }

                    swf.playlistLoaded = true;
                    swf.applyQuality();
                    return;
                } break;
                case 'playlistLoading':
                case 'playlistEnded':
                case 'uiinfo': 
                case 'showCta':
                case 'tryingToPlay':
                case 'screenReaderAlert': 
                case 'abort': 
                case 'uiactive': 
                case 'volumechange': {
                    return;
                } break;
                case 'pause' : {
                    swf.paused=true;
                } break;
                case 'ended' : {
                    swf.paused=true;
                    swf.ended=true;
                } break;
                case 'playing' : {
                    if (swf._needToSendPlay) {
                        swf._needToSendPlay = false; 
                        swf.player.dispatch({ type: "play" });
                    }
                    if (swf.ended) {
                        swf._currentTime = 0;
                        swf.ended = false;
                        swf.player.dispatch({ type:"timeupdate"});
                    }
                    swf.paused = false;
                } break;
                case 'timeupdate': {
                    swf.timeupdateCount++;
                    if(swf.timeupdateCount==3) {
                        swf.disableMouseUIBypass();
                    }
    
                    swf._currentTime = event.currentTime;
                    if (swf.duration!=event.duration) {
                        swf.duration = event.duration;
                        swf.player.dispatch({ type:"durationchange",duration:swf.duration});
                    }
                    swf.currentTimeInfo = event;
                } break;
                case 'info':{
                    // set it to the current bitrate
                    event.currentBitsPerSecond = swf.mediaConnection.bitrate;
                } break;
                case 'loadedmetadata': {
    
                    swf._mediaConnection = {
                        bitrate:event.bitrate,
                        supplier:event.cdn,
                        format: event.transferFormat
                    };
                    swf.videoWidth = event.width;
                    swf.videoHeight = event.height;
    
                    swf.player.dispatch({ type: "changingsrc", supplier:event.cdn, encoding: event.videoCodec || event.audioCodec || "unknown", format: event.transferFormat });
                }
            }
            swf.player.dispatch(event);
        };
    }

    function getRepeatCaller(domId, event) {
        return function() {
            window.embeddedMedia.handle(domId,event);
        };
    }

    function embed(swf,el) {
        // swf is there to help with debug
        window.embeddedMedia = {
            handle: getHandleEvent(swf),
            swf:swf
        };

        var settings = swf.player.config;

        var vars = {
            domId               : DOMID,
            jsCallbackMethod    : "window.embeddedMedia.handle",
            isBSTime            : settings.isBSTime,
            noTracking          : true,
            bumpVersion         : "no-bump",
            customRdotBaseURL   : settings.customRdotBaseURL,
            enableRdotReporting : settings.enableRdotReporting,
            maintainTheLock : settings.maintainTheLock
        };
       
        swf._swf = embedSwf(swf,swfId,el,vars,settings.swfUrl);

        setTimeout(function() {
           if (!swf.seenEvent) {
               swf._extraFailed = "noeventtimeout";
               swf.failed=SMPError.FLASH_NOT_INITIALISED;
           }
        },10000);
        swf.enableMouseUIBypass();
    }

    function embedSwf(swf, swfId, el, flashvars, url) {
        var params = {
            quality : 'high',
            bgcolor : '000000',
            allowFullScreen : false,
            allowScriptAccess : 'always',
            wmode : 'opaque'
        };
        for (var i in flashvars) {
            if (flashvars.hasOwnProperty(i)) {
                var key=encodeURIComponent(i);
                var value=encodeURIComponent(flashvars[i]);
                if (params.flashvars) {
                    params.flashvars+="&"+key+"="+value;
                } else {
                    params.flashvars = key+"="+value;
                }
            }
        }

        var o = document.createElement('object');
        for (var param in params) {
            if (params.hasOwnProperty(param) && param.toLowerCase() !== "movie") {
                o.appendChild(createObjParam(param, params[param]));
            }
        }
        o.setAttribute("type", "application/x-shockwave-flash");
        o.setAttribute("data", url);
        o.setAttribute("id", swfId);
        o.setAttribute("height","100%");
        o.setAttribute("width","100%");
        
        if (el.parentNode) {
            // SMPHTML-1142: If in minimode and short player, Flash prompt might be hidden, so force swf above everything
            var height = Utils.getOffset(swf.player.mediaContainer, 'height');
            if (height<264) { // Only if the 88px gradientLayer covers > 1/3 of the container
                el.parentNode.setAttribute("style","position: relative; z-index: 999;");
            }
            el.parentNode.replaceChild(o, el);
        }
        return o;
    }


    function createObjParam(name, value) {
        var p = document.createElement("param");
        p.setAttribute("name", name);
        p.setAttribute("value", value);
        return p;
    }


    SWF.prototype = {
        playItem:function(mediaItem) {
            var swf = this;
            swf.killed = false;
            swf.needToPause = false;
            swf.playOnInitialised = false;
            if (swf.ready) {
                playMediaItem(swf,mediaItem);
            } else {
                swf.playOnInitialised = true;
                if (!swf._swf) {
                    var el = document.createElement('div');
                    el.id = swfId+"_player";
                    document.getElementById(swfId).appendChild(el);
                    embed(swf, el);
                } else {
                    if (swf.failed) {
                        Utils.delayedErrorFunction(swf.player,swf.failed);
                    }
                }
            }
            swf.show();
        },
        stop:function() {
            var swf = this;
            swf.playOnInitialised = false;
            swf.needToPause = false;
        },
        hide : function() {
            // if we do IE 11 fallback this will require more complex
            // stuff perhaps due to reset when visibility
            // but maybe not - need to investigate when we do.
             Utils.className(document.body,"flashHidden");
        },
        show : function() {
            Utils.className(document.body,"","flashHidden");
        },
        call:function(str,data) {
            var swf = this;
            if (DEBUG_FULL) {
                console.log("SWF calling:"+str,data);
            }
            if (swf._swf && swf._swf.call) {
                swf._swf.call(str,data);
            }
        },
        initialised : function() {
            var swf = this;
            // XXX need to deal with displayCover / contain
            swf.call("setUIOptions", defaultUIOptions);
            swf.call("volume", swf.player.volume);
            swf.call("muted", swf.player.muted);
            
            swf.ready = true;
            swf.applyQuality();//There's an isReady check in applyQuality.

            if (swf.playOnInitialised) {
                swf.playOnInitialised = false;
                playMediaItem(swf, swf.player.mediaItem);
                if (swf.needToPause) {
                    swf.needToPause = false;
                    swf.call("pause");
                }
            }
        },
        load:function() {
            // do nothing
        },
        kill:function() {
            var swf = this;
            swf.stop();
            swf.call("stop");
            swf.hide();
            swf.duration = undefined;
            swf.killed = true;
            swf.playlistLoaded = false;
        },
        play:function() {
            var swf = this;
            if (swf.playOnInitialised) {
                swf.needToPause = false;
            } else {
                swf.show();
                swf.player.dispatch({type:'play'});
                swf.call("play");
            }
        },
        pause:function() {
            var swf = this;
            if (swf.playOnInitialised) {
                swf.needToPause = true;
            } else {
                swf.call("pause");
            }
        },
        enableMouseUIBypass:function() {
            var swf = this;
            swf.timeupdateCount=0;
            if (Device.edge) {
                playWhenHit=function() {
                    swf._swf.removeEventListener("mouseup",playWhenHit);
                    swf.play();
                };
                swf._swf.addEventListener("mouseup",playWhenHit);
            }
    
            if (Device.edge || window.chrome) {
                swf._swf.style.pointerEvents = "auto";
                Utils.deleteCssRules(swf.player.ui.stylesheet, ["notInteractiveContent"]);
                swf.player.ui.stylesheet.insertRule(".notInteractiveContent { pointer-events:none; }",0);
            }
    
        },
        disableMouseUIBypass:function() {
            var swf = this;
            swf._swf.style.pointerEvents = "none";
            swf._swf.parentNode.removeAttribute("style");
    
            Utils.deleteCssRules(swf.player.ui.stylesheet, ["notInteractiveContent"]);
            if (playWhenHit) {
                swf._swf.removeEventListener("mouseup",playWhenHit);
            }
        },
        applyQuality: function() {
            var swf = this; 
            if (swf.playlistLoaded) { //Oddly you can't set quality without a playlist because it's merging these settings into the playlist (EMPBase.as:1455)
                var quality = swf.player.quality || new Quality();
                //Flash has some understanding of quality:"low" and so on, but just call hd to unrestrict it and then use
                //limitQuality to set a ratio like dash does.
                swf.call("updateQuality", {quality: "hd", limitQuality: quality.getVideoRatio() * 100});
            }
        }
    };
    
    
    return SWF;
})();

var MediaSessionApi = (function () {


	function getCallbackObject(mSa) {
		return {

	    	playing : function(){
	    		if (!mSa.alreadySetFromPlayback) {
	    			mSa.setMetadata(mSa.player.playlist);
	    		}
	    	},

	    	mediaItemInfoChanged : function(){
	    		mSa.alreadySetFromPlayback = false;
	    	},

	    	setMediaSessionAPIdata : function(data){
	    		mSa.setMetadata(data.data);
	    	},

            mediaItemChanged: function() {
                if (mSa.player.ui.config.controls.includeNextButton) {
                    var API = navigator.mediaSession;

                    if (mSa.player.hasNext) {
                        API.setActionHandler('nexttrack', function() {
                            mSa.player.next();
                            mSa.player.trackAction('nextTrack_mediaSessionApi', 'nextTrack');
                        });
                    } else {
                        API.setActionHandler('nexttrack', null);
                    }
                }
            },

            timeupdate: function() {
                if (mSa.player.ui.config.controls.includePreviousButton) {
                    var API = navigator.mediaSession;

                    if (mSa.player.time >= 5) {
                        API.setActionHandler('previoustrack', function() {
                            mSa.player.time = 0;
                            mSa.player.trackAction('previoustrack_mediaSessionApi', 'backToStart');
                        });
                    } else if (mSa.player.time < 5 && !mSa.player.hasPrevious) {
                        API.setActionHandler('previoustrack', null);
                    } else {
                        API.setActionHandler('previoustrack', function() {
                            mSa.player.previous();
                            mSa.player.trackAction('previoustrack_mediaSessionApi', 'previousTrack');
                        });
                    }

                }
            }

   		};
	}


    // Constructor for MediaSessionApi class

    var MediaSessionApi = function(player) {

        var mSa = this;
        mSa.player = player;
        mSa.alreadySetFromPlayback = false;
        mSa.eventCallbacks = getCallbackObject(mSa);

        return mSa;
    };

    MediaSessionApi.prototype = {

    	isSupported : function() {
    		var mSa = this;
            var supported = window.navigator && navigator.mediaSession && navigator.mediaSession.setActionHandler;
    		var enabled = mSa.player.ui.config.mediaSessionAPI.enabled;

    		return supported && enabled;
        },

        setMetadata : function(data) {

        	var mSa = this;
        	var MediaMetadata = window.MediaMetadata;

            if ( !mSa.isSupported() && MediaMetadata ) {
        		return;
        	}
            var API = navigator.mediaSession;

        	mSa.alreadySetFromPlayback = true;

        	mSa.title = data.title || '';
        	mSa.posterURL = data.posterImg || '';
        	mSa.artist = data.artist || '';
        	mSa.album = data.album || '';

            if (mSa.posterURL !== '') {
                mSa.posterURL = Utils.doChef(mSa.posterURL, mSa.player.ui.container, mSa.player.ui.config.poster);
            }

        	API.metadata = new MediaMetadata({
        		title: mSa.title,
        		artist: mSa.artist,
    			album: mSa.album,
			    artwork: [
					{ src: mSa.posterURL, sizes:'512x512',type: 'image/jpg' }
			    ]
        	});

        	if (DEBUG_FULL) { console.log('Media Session API data set'); }

        	mSa.setControls();
        },

        setControls : function(){

        	var mSa = this;
        	var skipTime = mSa.calculateSkipTime();
        	var API = navigator.mediaSession;

			API.setActionHandler('seekforward', function() {
				mSa.player.time = mSa.player.time + skipTime;
				mSa.player.trackAction('seekforward_mediaSessionApi', 'seekforward');
			});

			API.setActionHandler('seekbackward', function() {
				mSa.player.time = mSa.player.time - skipTime;
				mSa.player.trackAction('seekbackward_mediaSessionApi', 'seekbackward');
			});

			API.setActionHandler('play', function() {
				mSa.player.mediaPlayer.play();
				mSa.player.trackAction('play_mediaSessionApi', 'play');
			});

			API.setActionHandler('pause', function() {
				mSa.player.mediaPlayer.pause();
				mSa.player.trackAction('pause_mediaSessionApi', 'pause');
			});

            // previoustrack and nexttrack cases will be set up with mediaItemChanged and timeupdate events,
            // as they need to react to the availability of the buttons matching audioUI behaviours
        },

        calculateSkipTime : function(){
        	var mSa = this;
        	var duration = mSa.player.duration;
        	var skipTime;

        	if (mSa.player.isLive) {
        		// 20 seconds if is live
        		skipTime = 20;
        	} else {
        		// 3 percent of duration if VOD
        		skipTime = (3 * duration)/100;
        	}

        	if ( skipTime === 0 || isNaN(skipTime) ) {
        		skipTime = 10;
        	}

        	return skipTime;
        }

    };

    MediaSessionApi.isSupported = window.navigator && navigator.mediaSession && navigator.mediaSession.setActionHandler;

	return MediaSessionApi;

})();var Player = (function() {

    var experimentalDash;
    var _isUK="";

    var loadPlaylistCount = 0;

    var BLANK_MEDIA = {
        video : "//emp.bbci.co.uk/emp/media/blankv2.mp4",
        "360" : "//emp.bbci.co.uk/emp/media/blankv2.mp4",
        audio : "//emp.bbci.co.uk/emp/media/blank.mp3"
    };

    var BLANK_MEDIA_WITH_NOISE = {
        video : "//emp.bbci.co.uk/emp/media/noise.mp4",
        "360" : "//emp.bbci.co.uk/emp/media/noise.mp4",
        audio : "//emp.bbci.co.uk/emp/media/noise.mp3"
    };

    var CURRENT_BLANK_MEDIA = BLANK_MEDIA;

    var PRELOAD_TIME = 15;

    var defaultConfig = {
        autoplay : false,
        bitrateFloor : {
            plain : 0
        },
        bitrateCeiling : {
            plain : 1200
        },
        isBSTime : false,
        suppressItemKind : [],
        suppressType : [],
        embedPageURL : '',
        mediatorHref : '',
        samlMediatorHref : '',
        counterName : 'smp.player.page',
        enableRdotReporting : true,
        enableStatsReporting : true,
        loop : false,
        startTime : 0,
        customRdotBaseURL : '',
        playVideoExternally : false,
        supportLiveRewindOnMobile : true,
        offlineAllowanceDelay : 60000,
        hibernationTime : 360,
        guidance : {
            isGuidanceLocked : false,
            hasGuidancePassword : false,
            hasGuidancePIN : false,
            guidanceSkipped : false
        },
        ui : {}
    };


    function flashAvailable() {
        if (window.navigator && navigator.plugins) {
            for (var i=0;i<navigator.plugins.length;i++) {
                // show flash fallback error message
                if (navigator.plugins[i].name=="Shockwave Flash") {
                    if (DEBUG_FULL) {
                        console.log('flash installed via navigator.plugins');
                    }
                    return true;
                }
            }
        }
        return false;
    }


    function addPrefetch(href) {
        var re = new RegExp('^((http[s]{0,1}):)?//([^\\?\\&#:/]*)','gi');
        if (re.test(href)) {
            var domain=RegExp.$3;
            if (domain) {
                var l=document.createElement('link');
                l.rel="dns-prefetch";
                l.href="https://"+domain;
                document.head.appendChild(l);
            }
        }
    }

    function playWithPromise(player) {
        var promise = player.mediaPlayer.play();
        if (promise && promise.then) {
            if (DEBUG_FULL) {
                console.log("Creating Promise for playback");
            }
            player.discardPromise = false;
            promise.then(function() {
                             player.playCalled=false;
                             if (DEBUG_FULL) {
                                 console.log("Promise reports playback started");
                             }
                         },
                         function() {
                             if (DEBUG_FULL) {
                                 console.log("Promise reports playback failed, still trying to play:",player.tryingToPlay, player.discardPromise);
                             }
                             //override state without doing other things.
                             if (player.tryingToPlay && !player.discardPromise) {
                                 if (player.mediaItem.live) {
                                     // XXX ideally we want to
                                     // stop DASH
                                     // scheduling here
                                     // and ensure that a
                                     // subsequent play
                                     // seeks to the live
                                     // edge, however that
                                     // is not currently
                                     // feasible.
                                     player.stop();
                                     if (player.config.oldStartTime) {
                                         player.config.startTime = player.config.oldStartTime;
                                     }

                                     //LiveSubtitles get added on dashEvents.go() - If we're shutting this down, we need
                                     //to get rid of the liveSubtitlesItem we generated.
                                     player.mediaItem.subtitleConnections = [];
                                     player.Subtitles.clearSubtitles();
                                 } else {
                                     player.dispatch({type: "pause"});
                                     player.playCalled=false;
                                     player._state = '';
                                     player.tryingToPlay = false;
                                     player.autoPlayNextItem = false;
                                     player.ui.resetGuidance();
                                     player.dispatch({type:"notPlayingState"});
                                     player.ui.showCta();
                                     player.ui.showPoster();
                                     player.ui.hideAllControls();
                                 }
                             }
                         }
                         );
        }
    }



    function hidePlayer(player,elType,pause) {
        // if element is in the DOM - pause it and move off screen.
        if (player.els[elType] && player.els[elType].parentNode) {
            if (pause) {
                player.els[elType].pause();
            }
            player.els[elType].style.left = HIDDEN_PLAYER;
        }
        player.swf.hide();
        if (pause) {
            player.swf.pause();
        }

        player.threeSixty.hideCanvas();
        if (player.Subtitles) {
            player.Subtitles.clearSubtitles();
        }
    }

    function distributeEvent(player,event,internal) {
        if (!internal) {
            getMediaEventFunction(player).apply(player, [event]);
        } else {
            if (allMediaEvents[player.uid]) {
                for (var i=0;i<allMediaEvents[player.uid].length;i++) {
                    allMediaEvents[player.uid][i](event);
                }
            }
        }
    }

    var mediaEventFunctions = {};
    var allMediaEvents = {};
    function getMediaEventFunction(player) {
        var uid = player.uid;

        if(!mediaEventFunctions[uid]) {
            mediaEventFunctions[uid] = {};
        }

        if (!mediaEventFunctions[uid].func) {
            // if (cbs) {
            //     mediaEventFunctions[uid] = { callbacks: cbs };
            // }
            var func = function(event) {

                var elType = getElementType(event.target,player);

                // Set player
                event._ = player;

                // queuedActions can be an array of functions to execute
                // once this event has been full distributed.
                // This prevents events coming out in weird orders, for example
                // due to failing over syncronously while processing an error
                // which can mess up metadata
                event._queuedActions = event._queuedActions || [];

                // Check event type
                var eventType = (event.type || 'unknown');

                // if we don't have control of the audio or video elements, return
                if (elType !== "unknown" && player.outOfControl) {
                    if (DEBUG_FULL) { console.log("Not in control",event); }
                    // XXX should we have more?
                    if (eventType!="webkitendfullscreen" && eventType!="volumechange") {
                        return;
                    }
                }

                var callbacks = [];
                if (mediaEventFunctions[uid].callbacks) {
                    callbacks = mediaEventFunctions[uid].callbacks;
                }

                // XXX we need to capture these rules somewhere more
                // sanely where they can be described and tested.
                // Probably sensible to move the core event bus into
                // its own helper class

                // some listeners will not be interested in the
                // unwanted events, use blockUnwanted in the event
                // object.  unwanted events are events from the wrong
                // player, or events while waiting for change.

                // if it's from the actual underlying player when it
                // has a src of the blank media, discard it then too.
                var unwanted = player.waitingForChange[elType] || (elType!="unknown" && (elType!=player.elType || (Utils.eventFieldData[eventType] && isPlayingBlankMedia(player))));

                // XXX only mediaplayer events should be blocked for failing over, and not ones that come from the event bus.
                unwanted = unwanted || (player.failingOver && event.type!="error" && event.type!="waiting" && event.type!="loadedmetadata" && event.type!="canplay" && event.type!="beforeErrorDisplay");

                // XXX we don't want timeupdate events to come out
                // when paused (e.g. before start SMPHTML-554 )
                unwanted = unwanted || (eventType=="timeupdate" && ((!player.isPlaying360 && player.mediaPlayer.style.left==HIDDEN_PLAYER) || (player.isPlaying360 && !player.threeSixty.showingCanvas)));

                // XXX volumechanges need to go through as UI needs to
                // update etc.
                if (eventType=="volumechange" || eventType=="SonarUserActionEvent" || eventType=="SonarErrorEvent" || eventType=="changingsrc") {
                    unwanted = false;
                }

                event.unwanted = unwanted;

                if (player.playbackMightRestartLater[elType] && eventType=="play") {
                    player.willAutoplayWhenPlayCalled[elType]=true;
                    player.autoplayTimeoutRetryAttempted = false;
                    player.mediaItemIndex = 0;
                    player.tryingToPlay = true;
                    unwanted = false;
                    player.playbackMightRestartLater={};
                    Utils.delayedErrorFunction(player, SMPError.PLAYING_STARTED_AFTER_NO_INTENT );
                }

                // fire the relevant callback if we have one for this
                // event type
                var cbl = callbacks.length;
                for (var i = 0; i < cbl; i++) {
                    var cbi = callbacks[i] || {};
                    if (typeof cbi[eventType] === 'function') {
                        if (!cbi.blockUnwanted || !unwanted) {
                            var eventReturn = cbi[eventType](event); // This line calls the registered event callback
                            if (eventReturn) {
                                if (DEBUG_FULL) { console.log("getMediaEventFunction: mutated event",event,eventReturn); }
                                // could the old event have queued actions?
                                // that need concatting on?
                                event = eventReturn;
                            }
                        }
                    }
                }

                // We don't want to send these out to the page etc
                var queuedActions = event._queuedActions;
                delete event._queuedActions;

                // if the event is handled or that video element is in a
                // fake autoplay state, just return;
                if (unwanted) {
                    if (DEBUG_FULL) { console.log("Shortcutting... event.type:" + event.type); }
                } else {
                    event = Utils.annotateEvent(event,player);

                    if (allMediaEvents[player.uid]) {
                        for (i = 0; i < allMediaEvents[uid].length; i++) {
                            allMediaEvents[uid][i](event);
                        }
                    }

                    if (DEBUG_FULL) {
                        var a = "__" + event.type;
                        if (!window[a]) {
                            window[a] = 0;
                        }
                        if (window[a]++ < 100) {
                            console.log(" event.type:" + event.type, event);
                        }
                    }

                    player.jsapiFunc(event);
                }
                player.lastEventType=eventType;
                if (queuedActions) {
                    for (i = 0; i < queuedActions.length; i++) {
                        queuedActions[i]();
                    }
                }
            };
            // if no callbacks or player set then this is an error or
            // something to be sent up to the parent page.
            // if (!cbs) {
            //     return func;
            // }
            mediaEventFunctions[uid].func = func;
        }
        return mediaEventFunctions[uid].func;
    }

    function addEventListeners(player,fields,callbackFunc) {
        for (var key in fields) {
            if (fields.hasOwnProperty(key)) {
                player.addEventListener(key,callbackFunc);
            }
        }
    }

    function addFullscreenEvent(player,insideIframe) {
        var fullscreenEvent = function(event) {
            if (DEBUG_FULL) { console.log("fullscreenEvent - event fired from the browser (type: " + event.type + ")", event); }
            if (player.ignoringFullscreenChanges) {
                if (DEBUG_FULL) { console.log("fullscreenEvent - ignoringFullscreenChanges is : " + player.ignoringFullscreenChanges); }
                return;
            }
            if (Device.isBrowserFullscreen(event)) {
                if (DEBUG_FULL) { console.log("fullscreenEvent - browser is fullscreen"); }
                player.maximise(true);
            } else {
                if (DEBUG_FULL) { console.log("fullscreenEvent - browser is not fullscreen"); }
                player.minimise(true);
            }
        };


        player.addedFullscreenListener = true;
        Device.bindToFullscreenChange(document, fullscreenEvent);
        if (insideIframe) {
            if (!Device.fullscreenEnabled(document)) {
                console.log("XXX can't take the iframe fullscreen so disabling button");
                player.config.ui.fullscreen={enabled:false,dblclick:false};
            }
        }

        try {
            Device.bindToFullscreenChange(top.document, fullscreenEvent);
            player.addedFullscreenListenerTop = true;
            if (DEBUG_FULL) { console.log("addedFullscreenListenerTop is true, fullscreenchange bound on top.document"); }
        } catch (e) {
            if (DEBUG_FULL) { console.log("addedFullscreenListenerTop is false, fullscreenchange bound on document"); }
        }
    }

    function preventDefault(e) {
        e.preventDefault();
    }

    function setBlankMedia(player, mediaState) {
        if (DEBUG_FULL) { console.log("setBlankMedia, player.willAutoplayWhenPlayCalled[mediaState]: " + player.willAutoplayWhenPlayCalled[mediaState]+", mediaState:"+mediaState);}
        if (!player.willAutoplayWhenPlayCalled[mediaState]) {
            var mediaElement = player.els[mediaState];
            var src=mediaElement.src;
            if (!src) {
                player.waitingForChange[mediaState] = true;
                mediaElement.src = CURRENT_BLANK_MEDIA[mediaState]; // set audio or video blank media
                if (mediaElement.load) {
                    mediaElement.load();
                }
            }
            if (DEBUG_FULL) {
                console.log("setBlankMedia: " + player.els[mediaState].src + ", player.waitingForChange[mediaState]" +player.waitingForChange[mediaState] + ", player.els[mediaState]: " +player.els[mediaState]);
                console.log("setBlankMedia, player.willAutoplayWhenPlayCalled: " + player.willAutoplayWhenPlayCalled[mediaState] + ", mediaState: " + mediaState);
            }
            if (Device.requiresFakePlayEvent) {
                mediaElement.play();
            }
            player.willAutoplayWhenPlayCalled[mediaState] = true;
        }
    }

    function initPlayerComponents(player) {
        if (DEBUG_FULL) { console.log('initPlayerComponents'); }

        player.pushMediaEventFunctions(mediaEventCallbacks);

        //Without this, it can cause the scrolling event on ipads to get lost.
        var expDashPercentage = player.config.experimentalDashPercentage;
        if (!isNaN(expDashPercentage) && expDashPercentage>0 && expDashPercentage<1) {
            experimentalDash = Math.random()<expDashPercentage;
        } else {
            experimentalDash = false;
        }

        if (player.config._demiIsUK===true) {
            _isUK = ".u";
        }

        if (player.config._demiIsUK===false) {
            _isUK = ".r";
        }


        Device.init(navigator.userAgent, player.config.supportHls);

        if (player.config.allowFakeFullscreenScroll && Device.allowFakeFullscreenScroll) {
            document.body.style.position = "fixed";
            document.body.style.width = "100%";
            document.body.style.height = "100%";
        }

        var istats = new IStats(player);
        RDotReporting.init(player, player.config.customRdotBaseURL);

        player.qos = new QOS(player);
        var subs = new Subtitles(player);

        player.Subtitles = subs;

        player.Chromecast = new Chromecast(player);

        if(player.config.ui.skin == 'audio') {
            player.ui = new AudioUI(player, player.config.ui);
            Utils.className(document.body,"audioUI");
        } else {
            player.ui = new UI(player, player.config.ui);
            Utils.className(document.body,"classicUI");
        }


        player.thumbScrub = new ThumbnailScrub(player);

        player.timeHelper = new TimeHelper(player);

        Language.init(player.ui.config.locale,function() {
                          SMPError.init();
                          player.dispatch({type:"languageUpdated"});
                      });

        SMPError.init();

        player.ui.initialise();


        if (player.config.threeSixty) {
            if (DEBUG_FULL) { console.log("Creating three sixty immediately"); }
            player.threeSixty.create(function() {});
        }

        PluginManager.init(player);

        player.api = new API(player);

        // have a stub dash events so we don't need to endlessly
        // check if it's defined
        player.dashEvents = {
            create : function() {
                player.dashEvents = new DashEvents(player, experimentalDash, Utils.callErrorFunction);
            },
            updatePortalSize:function() {},
            reset:function() {},
            resetSrc:function() {},
            applyQuality :function() {}
        };



        var callbackObjects = [
            player.qos.eventCallbacks].concat(player.ui.eventArray).concat([
                subs.eventCallbacks,
                istats.eventCallbacks,
                DebugConsole.eventCallbacks,
                player.Chromecast.eventCallbacks,
                player.threeSixtyEventCallbacks
            ]);


        // NARRATIVE SUBS WIP
        // probably will need to add a check to detect if the browser supports it,
        // and add a fallback mechanism before we arrive at this point
        if (player.ui.config.subtitles.useNarrative) {
            var narrSubs = new NarrSubtitles(player);
            callbackObjects.push(narrSubs.eventCallbacks);
        }

        if ( MediaSessionApi.isSupported ) {
            var mediaSessionApi = new MediaSessionApi(player);
            callbackObjects.push(mediaSessionApi.eventCallbacks);
        }

        for(var i = 0; i< callbackObjects.length; i++) {
            player.pushMediaEventFunctions(callbackObjects[i]);
        }

        var mefunc = getMediaEventFunction(player);
        addEventListeners(player.els.video, Utils.eventFieldData, mefunc);
        addEventListeners(player.els.audio, Utils.eventFieldData, mefunc);
        addEventListeners(player.els['360'], Utils.eventFieldData, mefunc);

        player.elType = "unknown";

        // XXX temporary for smp-offline until SMP offline passes
        // through a setting saying it's offline.
        var willAutoplay = ((location.href+'').indexOf('file:')===0);
        player.willAutoplayWhenPlayCalled = { video: willAutoplay, audio: willAutoplay,'360':willAutoplay };

        var previousH=window.innerHeight;
        var previousW=window.innerWidth;
        var resizeTimer;
        Utils.multiAddEventListener(window,"resize orientationchange", function() {
          var go=function() {
              previousH=window.innerHeight; previousW=window.innerWidth;
              player.fixSize(!player.isFullScreen);
          };
          clearTimeout(resizeTimer);
          if ((Math.abs(previousH-window.innerHeight)<3) && (Math.abs(previousW-window.innerWidth)<3)) {
              resizeTimer = setTimeout(go,100);
          } else {
              go();
          }
        });
        Utils.multiAddEventListener(window,"online offline", function() {
                                        Utils.setOrUnsetClass(document.body,"offline", !navigator.onLine);
                                    });
        player.els.video.addEventListener("loadedmetadata", function() {
            player.ui.displayCover();
        });


        player.onlineDetected = function() {
            player.endOnlineDetection();
            if ((new Date().valueOf()-player.onlineDetectionStart)>(player.config.hibernationTime*1000)) {
                if (DEBUG_FULL) { console.log("Back online, but calling STOP because "+((new Date().valueOf()-player.onlineDetectionStart)/1000)+"s have elapsed since we started"); }
                player.stop();
            } else {
                if (DEBUG_FULL) { console.log("Back online, retrying the media connections");}
                LoadBalancing.switchMediaConnection(player,false,true);
            }
        };
        player.startOnlineDetection=function() {
            player.onlineDetectionStart = new Date().valueOf();
            clearTimeout(player.offlineTimeout);
            window.addEventListener("online",player.onlineDetected);
            player.offlineTimeout = setTimeout(function() {
                                                   player.endOnlineDetection();
                                                   Utils.delayedErrorFunction(player, SMPError.NETWORK_UNAVAILABLE );
                                               },player.config.offlineAllowanceDelay);

        };
        player.endOnlineDetection=function() {
            clearTimeout(player.offlineTimeout);
            window.removeEventListener("online",player.onlineDetected);
        };


        xd.on('jsapi', getJSAPIFunc(player));
    }

    function getJSAPIFunc(player) {
        return function(data) {
            if (typeof data.call !== 'undefined') {
                var functionName = data.call;
                if (typeof data.params  !== 'undefined') {
                    var params = data.params;
                } else {
                    params = [];
                }
                if (!(params instanceof Array)) {
                    params = [params];
                }
                if (typeof player.api[functionName] === 'function') {
                    if (DEBUG_FULL) { console.log('JSAPI calling in API', data); }
                    params.push(true);
                    player.api[functionName].apply(player.api, params);
                    return;
                }
                // XXX if all the external API is implemented in
                // API.js this can be removed, although can be useful
                // for debugging
                if (typeof player[functionName] === 'function') {
                    if (DEBUG_FULL) { console.error('JSAPI calling in Player', data); }
                    player[functionName].apply(player, params);
                    return;
                }
            }
            if (DEBUG_FULL) { console.error('JSAPI error - failed to call', data); }
        };
    }


    function reMediateDueToError(player,mediaItem) {
        if (DEBUG_FULL) { console.log('re-mediating due to error'); }
        Utils.asyncDelay(function() {
            mediaItem.mediationAttempted = false;
            mediaItem.mediationRequested = false;
            LoadBalancing.mediate(mediaItem, player.consideredMobileConnection, getAfterMediationFn(player));
        });
    }

    function playFlash(player) {
        if (DEBUG_FULL) {
            console.log("playing flash, player.swf is:"+player.swf);
        }
        if (player.swf.fake) {
            player.swf = new SWF(player);
        }
        player.els.video.style.left = HIDDEN_PLAYER_SWF;
        player.els.audio.style.left = HIDDEN_PLAYER_SWF;
        player.els['360'].style.left = HIDDEN_PLAYER_SWF;
        player.mediaPlayer = player.swf;
        player.swf.playItem(player.mediaItem);
        return;
    }

    function getAfterMediationFn(player, preload) {

        var continuePlaying=function(mi) {
            player.dispatch({type:'mediaItemInfoChanged'});
            if (mi.kind=="360") {
                //MediaSelection may have changed it.
                if (!player.config.deviceSupports360) {
                    Utils.delayedErrorFunction(player, SMPError.DEVICE_NOT_SUPPORTED );
                    return;
                }
                if (player.threeSixty.fake && !player.threeSixty.failed) {
                    player.elType="360";
                    player.selectMediaPlayer("360");
                    player.mediaPlayer.autoplay = true;
                    player.threeSixty.create(function() {
                                                 pickInitialConnection(player);
                                             });
                    return;
                }
            }
            pickInitialConnection(player);
        };

        if (preload) {
            return function(mi) {
                if (player.mediaItem !== mi) {
                    if (canPreload(mi,player.mediaItem)) {
                        setupPreloadForNextItem(player, mi);
                    }
                } else { //We've already moved onto the item we tried to preload. Proceed as normal.
                    continuePlaying(mi);
                }
            };
        } else {
            return function(mi) {
                if (player.mediaItem == mi) {
                    continuePlaying(mi);
                }
            };
        }
    }

    function mediateNextItem(player, preload) {
        if (player.mediaItemIndex + 1 < player.playlist.items.length) {
            var nextMediaItem = player.playlist.getNextItem(player.mediaItemIndex);
            if (nextMediaItem && !nextMediaItem.mediationAttempted) {
                LoadBalancing.mediate(nextMediaItem, player.consideredMobileConnection, getAfterMediationFn(player, preload));
            }
        } else {
            if (player.playlist.queuedPlaylist) {
                // XXX this needs to cope with adverts, not just
                // mediating first item if it's not an advert
                if (player.playlist.queuedPlaylist.items && player.playlist.queuedPlaylist.items[0] && player.playlist.queuedPlaylist.items[0].kind!=='advert') {
                    var queuedPlaylistFirstItem = player.playlist.createMediaItem(player.playlist.queuedPlaylist, 0, player.config);
                    if (!queuedPlaylistFirstItem.mediationAttempted) {
                        player.playlist.queuedPlaylist.items[0].createdItem = queuedPlaylistFirstItem;
                        LoadBalancing.mediate(queuedPlaylistFirstItem, player.consideredMobileConnection, getAfterMediationFn(player, preload));
                    }
                }
            }
        }
    }

    function canPreload(mi,currentItem) {
        // XXX should we consider doing the filter here, rather than
        // here so loadbalancing selects/rejects the options?
        if (mi && mi.connections.length > 0 && !mi.live) {
            // XXX this isn't set anywhere?
            // wouldn't the whole canPreload be better as a MediaItem getter?
            if (!mi.noPreload) {
                if (!currentItem || currentItem.type!=mi.type) {
                    return false;
                }
                var validConnection = LoadBalancing.filter(mi);
                if (validConnection && mi.connections[0].format === 'dash') {
                    return true;
                }
            }
        }

        return false;
    }

    function isPlayingBlankMedia(player) {
        var elType = getElementType(player.mediaPlayer, player);
        var srcArr = player.mediaPlayer.src.split("//");
        if (srcArr.length == 2) {
            return "//" + srcArr[1] === CURRENT_BLANK_MEDIA[elType];
        }

        return false;
    }
    function setupPreloadForNextItem(player, mediaItem) {
        //Duration not available. Wait for metadata loaded event. Either mediation or metadataloaded will fire first, need to wait for both to be complete.
        if (player.duration > 0 && !isPlayingBlankMedia(player)) {
            if (!player.preloadDashEvents) {
                if (player.ended || ((player.duration - player.time) <= PRELOAD_TIME)) {
                    preloadNextItem(player,mediaItem);
                } else {
                    if (!player.preloadCallback) {
                        var preloadTime = Math.max(player.duration - PRELOAD_TIME, 0.1);
                        if (DEBUG_FULL) { console.log("Next media item scheduled for preload at " + preloadTime); }
                        player.preloadCallback = player.timeHelper.setPlaybackTimeout(preloadNextItem.bind(null, player, mediaItem), preloadTime, true);
                    }
                }
            }
        }
    }

    function preloadDashErrorHandler(player,type/*,extra,nonPlayer,lowSeverity,delay*/) {
        var error = SMPError.getError(type);
        if (DEBUG_FULL) {
            console.log("Dash preload stored error " + error.code + " - " + error.detail);
        }
        if (error.severity === "critical" || error.severity === "error") {
            if (player.preloadDashEvents) {
                if (DEBUG_FULL) {
                    console.log("Dash preload error terminal, aborting preload, will retry without preload");
                }
                player.preloadDashEvents.reset();
                player.preloadDashEvents = null;
            }
        }
        if (!player.preloadStoredErrors) {
            player.preloadStoredErrors = [];
        }

        //It's a little complicated to transmit stats for errors when we're already playing something else,
        //so save the errors and wait for the mediaSrc to change, then stats them off all at once.
        player.preloadStoredErrors.push(error);
    }

    function getMaxBitrate(bitrateList) {
        return (bitrateList && bitrateList.length>0) ? bitrateList.reduce(function (a, b) { return a.bitrate > b.bitrate ? a : b; }) : NaN;
    }

    function getNextItemBitrates(player) {
        var maxVideo = getMaxBitrate(player.dashEvents.getBitrateListFor('video'));
        var maxAudio = getMaxBitrate(player.dashEvents.getBitrateListFor('audio'));
        var currentVideo = player.dashEvents.streamingBitrate.video.rate;
        var currentAudio = player.dashEvents.streamingBitrate.audio.rate;

        return {
            video: maxVideo.bitrate !== currentVideo && currentVideo !== 0 ? currentVideo : NaN,
            audio: maxAudio.bitrate !== currentAudio && currentAudio !== 0 ? currentAudio : NaN
        };
    }

    function preloadNextItem(player, mediaItem) {
        player.preloadCallback = null;
        var pde = new DashEvents(player, experimentalDash, preloadDashErrorHandler);
        player.preloadDashEvents = pde;
        pde.setSrc(mediaItem.connections);
        if (DEBUG_FULL) {
            console.log("Beginning preload of next item with:",mediaItem.connections);
        }
        if (player.isPlayingDash) {
            pde.setInitialBitrate(getNextItemBitrates(player));
        }
    }

    function pickInitialConnection(player) {
        if (DEBUG_FULL) { console.log('Player.pickInitialConnection'); }
        var mediaItem = player.mediaItem;

        Device.filterDash = player.playlist && player.playlist.hasAds && PluginManager.pluginArray.length && !Device.supportsMultipleMediaElements;

        if (!player.quality) {
            player.quality = new Quality(player.config.quality, player.mediaItem);
        }

        // XXX why not unify filter and pickInitial into a pick
        // function remove the duplication here?
        // XXX this results in an error when suppressItemKind is used.
        // needs moving out of LoadBalancing and no mediaItemChanged etc.
        var validConnection = LoadBalancing.filter(mediaItem);

        if (!validConnection) {
            if (Utils.checkNotAvailableReason(player, mediaItem)) {
                reMediateDueToError(player,mediaItem);
            }
            return;
        }

        var initialConnection=mediaItem.connections[0];

        if (!initialConnection){
            // XXX this should be impossible hence the unifying comment above.
            if (Utils.checkNotAvailableReason(player, mediaItem)) {
                reMediateDueToError(player,mediaItem);
            }
            return;
        }
        // if it's audio, and there's no MSE support, or they prefer video flash go straight to flash
        if (player.config.preferVideoInFlash && (mediaItem.type == "video" || (!Device.supportsAudioDash && !Device.supportsHls)) && player.supportFallbackPrefer && flashAvailable()) {
            player.fallbackAsAppropriate();
            return;
        }
        if (mediaItem.type == "video") {
            if (player.config.playVideoExternally) {
                player.waitingForChange.video = false;
                if (player.tryingToPlay) {
                    player.requestGuidanceAndPlay();
                }
                return;
            }
        }
        if (setElementType(player,mediaItem.type)) {
            if (player.mediaPlayer.currentSrc !== initialConnection.href) {
                player.mediaSrc(initialConnection.href);
            } else {
                player.mediaPlayer.load();
            }
        }
        player.failedOver = false;
        player.timeHelper.reset();
        player.clearFakeTimer();

        player.mediaPlayer.loop = player.config.loop;
        player.mediaPlayer.title = player.playlist.title;

        Utils.asyncDelay(mediateNextItem,[player, !player.config.disablePreload]);
    }

    function processQueued(player,autoplay) {
        if (player.playlist.queuedPlaylist) {
            var options={autoplay:autoplay};
            if (player.playlist.queuedOptions) {
                options = player.playlist.queuedOptions;
                options.autoplay=autoplay;
            }
            player.resetStatsObject();
            player.updateConfig(options);
            player.loadPlaylist(player.playlist.queuedPlaylist, true, true);
            if (options.webcastData) {
                player.api.setData({name:"SMP.webcastData",data:options.webcastData});
            }
        }
    }

    function processPrevious(player,autoplay) {
        // XXX should we make the current playlist become the queued
        // playlist, or do we force the page to decide what happens,
        // by calling queuePlaylist ?
        if (player.playlist.previousPlaylist) {
            var options={autoplay:autoplay};
            if (player.playlist.previousOptions) {
                options = player.playlist.previousOptions;
                options.autoplay=autoplay;
            }
            player.resetStatsObject();
            player.updateConfig(options);
            player.loadPlaylist(player.playlist.previousPlaylist, true, true);
        }
    }

    var mediaEventCallbacks = {
        tryingToPlay: function(event) {

            var player = event._;

            player.playingState = 'playing';
            player.dispatch({type:"playingState"});

        },
        play: function(event) {
            var player = event._;
            var elType = getElementType(event.target, player);
            if (!player.waitingForChange[elType]) {
                player.playingState = 'playing';
                player.dispatch({type:"playingState"});
            }
        },
        notPlayingState: function(event) {
            var player = event._;
            player.playingState = 'notplaying';
        },
        durationchange: function(event) {
            var player = event._;
            var elType = getElementType(event.target, player);
            if (!player.waitingForChange[elType]) {
                var duration = player.duration;
                if (duration>1) {
                    player._duration = duration;
                }
                // only update the duration
                player.timeHelper.update(NaN, duration);
            }
        },
        canplay : function(event) {
            var player = event._;

            clearTimeout(player.noCanplayEventTimeout);

            if (DEBUG_FULL) { console.log('canplay waitingForStartTime:'+ player.waitingForStartTime+" / ", player.waitingForChange); }

            var elType = getElementType(event.target, player);

            if (player.failingOver) {
                player.failingOver = false;
                player.streamFailing = false;
            }
            player.needHlsStartTime = false;
            if (!player.mediaItem) {
                // there's no media item, so do nothing
                return;
            }
            if (!player.waitingForChange[elType] && player.mediaItem) {
                if (player.mediaItem.live && player.config.supportLiveRewindOnMobile && player.mediaItem && player.ui.config.controls.enableLiveRewind) {
                    if (!player.isPlayingDash) {
                        // XXX should we just have this dispatch a
                        // durationchange event rather than call UI
                        // directly here?
                        if (DEBUG_FULL) { console.log('delaying seek because of no hls info'); }
                        if (Device.useStartDateInHls && player.mediaPlayer.getStartDate && player.mediaPlayer.getStartDate()) {
                            if (!player.mediaItem._startTime) {
                                player.isUsingGetStartDate = true;
                                player.mediaItem._startTime = new Date(player.mediaPlayer.getStartDate()).valueOf() / 1000;
                                player.timeHelper.setStartTimeAvailable(true);
                                player.ui.checkIfCanDisplaySeekBar();
                                if ( player.mediaItem.simulcast && !player.isAudio && player.ui.config.subtitles && player.ui.config.subtitles.supportLiveSubtitles ) {
                                    player.mediaItem.startLiveHLSsubs(player);
                                }
                            }
                        } else {
                            player.needHlsStartTime = true;
                            player.mediaItem.getRewindWindow(function() {
                              player.timeHelper.setStartTimeAvailable(true);
                              player.ui.checkIfCanDisplaySeekBar();
                            });
                        }
                    }
                }
                if (player.waitingForStartTime && !player.needHlsStartTime && (player.timeHelper.startTimeAvailable || !player.mediaItem.live)) {
                    if (!player.isPlayingDash) { //If playing dash, we set the start time in dashEvents.go(), so just clear the start time.
                        if (DEBUG_FULL) { console.log('attempting to seek to startTime'); }
                        player.time = player.waitingForStartTime;
                    }
                    player.waitingForStartTime = 0;
                    player.config.oldStartTime = player.config.startTime;
                    player.config.startTime = 0;
                }


                if (Device.supportsAutoplay && player.mediaPlayer.paused && !player.playCalled && player.tryingToPlay) {
                    player.playCalled=true;

                    if (DEBUG_FULL) { console.log( "pauseCheck for time 0 in promise:"+player.pauseTimes[0]); }
                    if (player.pauseTimes[0] === 0) {
                        if (DEBUG_FULL) { console.log( "pauseCheck stopped playback, special case pauseAt[0] pauses immediately"); }
                        player.mediaPlayer.autoplay=false;
                        player.mediaPlayer.pause();
                        player.pauseTimes.splice(0,1);
                        player.delayedDispatch({type: "playing", fakePlaying:true,pauseatzero:true});
                        return;
                    }
                    playWithPromise(player);
                }
            }


            // SMPHTML-852: If people turn off autoplay, then we need
            // to do the same thing as on iOS, which is ensure the intent
            // is passed through. Detect a failure to play and reset.
            // Also improves the experience when a page has its own UI
            // but doesn't properly pass through the intent
            // !lowLatencyMode is questionable - but some of the test streams sit and 404 on the live edge sometimes for a few seconds
            // It's only an experiment so let it be for now
            if (!player.autoplayTimeoutRetryAttempted && !player.config.lowLatencyMode) {
                var delay = 10000*(Device.consideredForMobileLiveRewind ? 2 : 1);
                var expireAutoplay = function () {
                    if (!player.mediaItem) {
                        // new playlists have happened.
                        // we should pr
                        return;
                    }
                    // if we're still mediating wait a bit longer
                    if (player.mediaItem.mediationRequested) {
                        if (DEBUG_FULL) {
                            console.log('Tried to autoplay, but we are still mediating, this is slow, wait longer though.');
                        }
                        player.playingTimer = setTimeout(expireAutoplay, delay);
                        return;
                    }
                    if (player.tryingToPlay && player.mediaPlayer.paused) {
                        if (DEBUG_FULL) {
                            console.log('Tried to autoplay, but it did not work.');
                        }
                        // if we're Device.iPhoneOutOfPagePlayback and
                        // we are fullscreen, then we can detect here
                        // if we just need to wait longer or not.  so
                        // check here if
                        if (Device.iPhoneOutOfPagePlayback && player.mediaPlayer.webkitIsFullscreen) {
                            player.playingTimer = setTimeout(expireAutoplay, delay);
                            return;
                        }

                        Utils.delayedErrorFunction(player, SMPError.PLAYING_FAILED_NO_INTENT );

                        player.playbackMightRestartLater[elType]=true;

                        //override state without doing other things.
                        pretendWeNeverTriedAutoplay(player);
                    }
                };

                player.playingTimer = setTimeout(expireAutoplay, delay);
            }
        },
        // SMPHTML-1413
        canplaythrough : function(){
            var player = event._;
            if(Device.iosRequiresFakePlayingEventAfterSeeked && player.isPlayingHls && !player.mediaPlayer.paused) {
                player.delayedDispatch({type: "playing", fakePlaying:true});
            }
        },
        pause : function(event) {
            var player = event._;
            player.dispatch({type:"notPlayingState"});
            if (!event.unwanted) {
                player.tryingToPlay = false;
            }
        },
        timeupdate : function(event) {
            var player = event._;
            var time = player.time;
            var duration = player.duration;
            var webcastData = player.webcastData;
            player.timeHelper.update(time, duration);

            if ((webcastData && webcastData.accurateEndTime) && (player.timeHelper.time > webcastData.accurateEndTime)) {

                if (!player.timeHelper.restartedWebcast && (player.timeHelper.joinTime > webcastData.accurateEndTime)) {
                    player.timeHelper.restartedWebcast = true;
                } else {
                    if (!player.mediaPlayer.paused) {
                        // XXX this doesn't return to the CTA?
                        player.pause();
                        player.dispatch({ type: player.config.ondemandWebcastData ? "playlistEnded" : "playlistStopped"});
                        player.timeHelper.restartedWebcast = true;
                    }
                }
            }

            // XXX review the need for this, and move into a
            // conditional check etc.
            // WORKAROUND : Safari's ended event is flakey (doesn't
            // always fire) fake ended event if the video is not
            // already ended
            if (Device.requiresFakeEnded && duration > 1 && time >= duration) {
                // fake ended event
                if (DEBUG_FULL) {
                    console.log('Sending fake ended (1)');
                }
                player.delayedDispatch({type: "ended", fakeEnded:true});
            }

            if (!player.paused) {
                for (var i = 0; i < player.pauseTimes.length; i++) {
                    if (DEBUG_FULL) { console.log( "pauseCheck:" + time + " / " + player.pauseTimes[i]); }
                    if (time >= player.pauseTimes[i] && time < player.pauseTimes[i] + 0.33) {
                        player.mediaPlayer.pause();
                        player.pauseTimes.splice(i,1);
                    }
                }
            }

        },
        seeking : function(event) {
            var player = event._;
            var th = player.timeHelper;
            var time = player.mediaPlayer.currentTime + th.presentationTimeOffset;

            if (DEBUG_FULL) {
                console.log("Seeking to:"+time+" should clamp to:"+ player.timeHelper.checkIfTimeIsAvailable(time,true), player.timeHelper);
            }
            if (player.isPlayingDash && player.mediaItem && player.mediaItem.live && player.mediaPlayer.readyState==4) {
                var clampTime = player.timeHelper.checkIfTimeIsAvailable(time,true);
                if (time!=clampTime) {
                    player.mediaPlayer.currentTime = clampTime - th.presentationTimeOffset;
                }
            } else {
                player.timeHelper.update(player.time, player.duration);
            }
        },
        seeked : function(event) {
            var player = event._;
            if (Device.requiresFakePlayingEventAfterSeekedWhenDash && player.isPlayingDash && !player.mediaPlayer.paused) {
                player.delayedDispatch({type: "playing", fakePlaying:true});
            }
        },
        playing : function(event) {
            var player = event._;

            player.playingState = 'playing';
            player.dispatch({type:"playingState"});
            player.waiting = false;
            player.mediaEnded = false;
            player.playCalled = false;

            if (!event.fakePlaying) {
                // Workaround for SMPHTML-1091
                if (player.isPlayingDash && player.isAudio && Device.macSafari) {
                    player.mediaPlayer.currentTime += 0.1;
                }
            }

            var elType = getElementType(event.target, player);

            if (DEBUG_FULL) { console.log("Playing:"+elType); }

            player.willAutoplayWhenPlayCalled[elType] = true;

            // Set the volume on the new media player
            player.mediaPlayer.volume = player.volume;
            player.mediaPlayer.muted = player.muted;

            player.state = '';

            clearTimeout(player.playingTimer);

            if (player.waitingForChange[elType]) {
                event.target.pause();
            } else {
                player.mediaItem.hasSeenPlaying = true;
                if (DEBUG_FULL) { console.log( "pauseCheck for time 0:"+player.pauseTimes[0]); }


                // XXX audio lock craziness!
                player.mediaPlayer.autoplay = false;


                if (player.pauseTimes[0] === 0) {
                    if (DEBUG_FULL) { console.log( "pauseCheck stopped playback, special case pauseAt[0] pauses immediately"); }
                    player.mediaPlayer.pause();
                    player.pauseTimes.splice(0,1);
                }
                if (event.pauseatzero) {
                    if (DEBUG_FULL) { console.log( "pauseCheck stopped playback by not starting in canplay, dispatching fake paused",player.mediaPlayer.paused); }
                    player.delayedDispatch({type:"pause"});
                }

                // XXX or should we check to see if mediaplayer == swf here?
                if (player.mediaItem.useFlash) {
                    player.swf.show();
                } else if (player.mediaItem.kind == '360') {
                    player.threeSixty.showCanvas();
                } else if (player.ui.config.skin == 'audio' || (player.ui.config.skin == 'classic' && player.ui.miniModeEnabled)) {
                    player.mediaPlayer.style.left = HIDDEN_PLAYER_MINIMODE;
                } else {
                    player.mediaPlayer.style.left = "0px";
                }

            }
        },
        ended : function(event) {
            var player = event._;

            player.dispatch({type:"notPlayingState"});

            if (DEBUG_FULL) { console.log('ended (' + (event.type ? event.type : 'none') + ')', player.mediaItem); }

            if (player.lastEventType=="ended") {
                // XXX chrome can spit out two ended events in
                // succession in some weird seek scenarios, discard
                // the second.
                return;
            }

            player.tryingToPlay = false;
            player.discardPromise = true;

            if (!player.mediaPlayer.ended && !event.fakeEnded) {
                // Chrome appears to occasionally emit this during a
                // dash reset particularly after a failed seek.
                return;
            }

            // cue next media item and start playback (if there is
            // another media item to play)
            var previousElType = player.elType;
            if (player.cueNextMediaItem()) {
                // don't know the types reliably?
                // XXX this will set even if it's mediating and we
                player.autoPlayNextItem = (previousElType === player.elType);
            } else {
                if (event.fakeEnded) {
                    player.reloadToStart = true;
                }
            }
            hidePlayer(player,player.elType);
        },

        fullscreenEnter: function(event) {
            var player = event._;
            if (!player.config.allowFakeFullscreenScroll || !Device.allowFakeFullscreenScroll) {
                //Plugins attempting to use overflow-y:scroll can't do so when we're doing preventDefault
                //but put behind a flag because, when not preventing, white bars can be scrolled into view from the right on ipads.
                document.documentElement.addEventListener('touchmove', preventDefault, {passive: false});
            }
            event._.isFullScreen = true;
        },

        fullscreenExit: function(event) {
            var player = event._;
            if (!player.config.allowFakeFullscreenScroll || !Device.allowFakeFullscreenScroll) {
                document.documentElement.removeEventListener('touchmove', preventDefault, {passive: false});
            }
            event._.isFullScreen = false;
        },

        playlistLoading : function(event) {
            var player = event._;

            player.mediaEnded = false;
            player.dispatch({type:"notPlayingState"});
            player.webcastData = null;
            player.ui.markerData = [];
            player.inErrorState = false;
            player.threeSixtyLoadingFn = null;
            RDotReporting.playlistLoading();
            player.resetAfterOutOfControl = false;
            player.timeHelper.reset();
        },

        playlistLoaded : function(event) {
            var player = event._;
            player.timeHelper.reset();

        },

        playlistEnded : function(event) {
            var player = event._;

            player.mediaEnded = true;
            if (player.config.noAutomaticNextQueued || !player.queueNextPlaylist(true)) {
                if (player.playlist && player.mediaItem) {
                    player.resettingIndexInPlaylistEnd = true;
                    Utils.asyncDelay(function() {
                       if (player.resettingIndexInPlaylistEnd) {
                          // if no queued, and it's an ident, change it
                          if (player.mediaItem.isIdent && player.playlist.items.length>1) {
                              var index=player.playlist.firstProgramme;
                              player.mediaItemIndex=index-1;
                              player.cueNextMediaItem(true);
                              player.pauseTimes=[0];
                          }
                       }
                    });
                }
            }
        },
        playlistStopped : function(event) {
            var player = event._;
            player.tryingToPlay = false;
        },
        playerDisconnected : function(event) {
            var player = event._;
            player.inErrorState = false;
            player.dispatch({type:"notPlayingState"});
        },
        waiting : function(event) {
            var player = event._;
            player.waiting = true;
            if (player.endOnWaiting) {
                player.endOnWaiting = false;
                player.reloadToStart = true;

                player.delayedDispatch({type: "ended",fakeEnded:true});
            }
            // SMPHTML-414
            if (player.streamFailing) {
                player.streamFailing = false;
                //Needs to be async or else you'll have a world of SMPHTML-485
                // erm...hmm is this still being used?
                player.tryingToPlay = false;
                player.autoPlayNextItem = false;


                if (player.tryReconnect) {
                    player.tryReconnect = false;
                    if (navigator.onLine===false) {
                        player.startOnlineDetection();
                    } else {
                        player.onlineDetected();
                    }
                } else {
                    Utils.delayedErrorFunction(player, SMPError.LOAD_FAILED_BUFFERING);
                }
            }
        },
        loadedmetadata: function(event) {
            var player = event._;
            var elType = getElementType(event.target, player);
            if (player.playlist && !player.waitingForChange[elType]) {
                var mediaItem = player.playlist.items[player.mediaItemIndex + 1];
                if (mediaItem && !player.config.disablePreload && canPreload(mediaItem, player.mediaItem)) {
                    setupPreloadForNextItem(player, mediaItem);
                }
            }
        },
        error : function(event) {
            var player = event._;
            var target = event.target;
            var switchConnection = false;
            var switchConnectionFilter;

            if (event.handled) {

                if (event.nonPlayer) {
                    // plugin events don't go through here
                    return;
                }

                //This is an SMPError
                // NO_INTENT shouldn't continue onto the next thing.
                // should we do more with this.
                if ( event.code!=SMPError.PLAYING_FAILED_NO_INTENT &&  event.severity==CRITICAL && player.continueAfterError) {
                    event.severity = 'error';
                    event.morphed = true;
                    if (DEBUG_FULL) {
                        console.log("Morphing critical Error into Normal as there are more playable items and an ignoreErrors");
                    }
                    Utils.asyncDelay(player.cueNextMediaItem,[],player);
                    return;
                }

                var fail = false;
                var delayRetry = false;

                var reason = player.failedOver ? SMPError.NO_ALTERNATIVE_MEDIA_AFTER_FAILOVER :  SMPError.NO_ALTERNATIVE_MEDIA;
                var curSupplier = player.mediaConnection ? player.mediaConnection.supplier : '';
                switch (event.code) {
                    case SMPError.MPD_GENERIC:
                    case SMPError.MPD_LOAD_FAIL:
                    case SMPError.MPD_PARSE_ERROR:
                        switchConnectionFilter = false;
                        switchConnection = !!LoadBalancing.getAlternateMediaConnections(player, switchConnectionFilter,curSupplier);
                        fail = !switchConnection;
                        break;

                    case SMPError.MPD_NO_STREAMS:
                    case SMPError.PLAYING_DASH_WHEN_NOT_SUPPORTED:
                    case SMPError.DASH_EXCEPTION:
                        switchConnectionFilter = true;
                        switchConnection = !!LoadBalancing.getAlternateMediaConnections(player, switchConnectionFilter,curSupplier);
                        fail = !switchConnection;
                        if (fail && player.supportFallback) {
                            Utils.asyncDelay(player.fallbackAsAppropriate, [],player);
                            fail=false;
                        }
                        break;
                    case SMPError.INIT_FRAGMENT_LOAD_FAIL:
                    case SMPError.STREAM_FRAGMENT_LOAD_FAIL:
                        if (!player.streamFailing) {
                            var canDashFailover = player.mediaItem.dashAlternates && player.dashEvents && !player.config.disableDashBaseUrlFailover && player.dashEvents.dashFailoversRemaining() > 0;

                            // XXX this needs to be cleverer to do same protocol format
                            var originallyMore = player.dashEvents.connections.length < player.mediaItem.originalConnections.length;

                            switchConnectionFilter = false;
                            var couldSwitch =  !!LoadBalancing.getAlternateMediaConnections(player, switchConnectionFilter,curSupplier);
                            switchConnection = couldSwitch && !canDashFailover;

                            if (navigator.onLine===false && (couldSwitch || originallyMore)) {
                                delayRetry = true;
                                player.tryReconnect = true;
                                player.streamFailing = true;
                                player.onlineDetectionStart = new Date().valueOf();
                            } else {
                                player.tryReconnect = false;
                                player.streamFailing =  !switchConnection;
                            }
                            // Fail straight away if we're buffering,
                            // otherwise let this play out and the
                            // error will come out later.
                            fail = (player.streamFailing && (player.mediaPlayer.paused || player.mediaPlayer.playbackRate === 0 || player.buffered===0));
                            if (fail && delayRetry) {
                                fail=false;
                                delayRetry = false;
                                player.startOnlineDetection();
                            }
                            reason = SMPError.LOAD_FAILED_BUFFERING;
                            if (player.dashEvents) {
                                player.dashEvents.manuallyFailingOver = true;
                            }
                        }
                        break;
                    case SMPError.INIT_FRAGMENT_DOWNLOAD_INFORMATION:
                    case SMPError.FRAGMENT_DOWNLOAD_INFORMATION:
                        if (player.dashEvents.removedList) {
                            player.mediaItem.connections = player.mediaItem.connections.filter(function(a) {
                                return player.dashEvents.removedList.indexOf(a) < 0;
                            });
                            player.dashEvents.removedList = null;
                        }
                        break;
                    case SMPError.NO_ALTERNATIVE_MEDIA:
                    case SMPError.NO_ALTERNATIVE_MEDIA_AFTER_FAILOVER:
                        player.tryingToPlay = false;
                        player.dashEvents.reset();
                        break;
                    case SMPError.LOAD_FAILED_BUFFERING:
                    case SMPError.CONTENT_NOT_AVAILABLE_PRE_START:
                    case SMPError.PLAYING_FAILED_NO_INTENT:
                    case SMPError.PLAYING_STARTED_AFTER_NO_INTENT:
                    case SMPError.FRAGMENT_DOWNLOAD_INFORMATION:
                    case SMPError.UNHANDLED_INTERNAL_ERROR:
                    case SMPError.DOWNLOAD_WAS_SLOW:
                    case SMPError.DASH_INIT_TIMEOUT:
                    case SMPError.DOWNLOADS_OFTEN_SLOW:
                    case SMPError.NO_SUPPORTED_CODECS:
                    case SMPError.NO_SUPPORTED_CODECS_FAILOVER:
                    case SMPError.DASH_MEDIASOURCE_ERROR:
                    case SMPError.NETWORK_UNAVAILABLE:
                        break;
                    default:

                        if (event.severity!=CRITICAL && !event.morphed) {
                            if (DEBUG_FULL) {
                                console.log("Handled event, but with no action in switch.", event);
                            }
                            Utils.delayedErrorFunction(player, SMPError.UNHANDLED_INTERNAL_ERROR, event.code);
                        }
                        break;
                }

                if (fail) {
                    player.tryingToPlay = false;
                    player.autoPlayNextItem = false;
                    Utils.delayedErrorFunction(player, reason);
                }
                if (switchConnection && !delayRetry) {
                    var con = player.mediaConnection;
                    if (con) {
                        player.mediaItem.addFailedConnection(con.supplier);
                    }
                    event._queuedActions.push(function() {
                        if (!LoadBalancing.switchMediaConnection(player, switchConnectionFilter)) {
                            Utils.delayedErrorFunction(player, SMPError.NO_ALTERNATIVE_MEDIA_AFTER_FAILOVER);
                        }
                    });
                } else {
                    if (event.severity==CRITICAL) {
                        player.tryingToPlay = false;
                        player.autoPlayNextItem = false;
                    }
                }

            } else if (target == player.mediaPlayer) {
                // Ignore errors not for the current player
                var elType = getElementType(target,player);

                // XXX event.handled can't be true here as it's in an else...
                if (event.handled || player.waitingForChange[elType]) {
                    // e.g. Failed to load blank media, error will not be
                    // propagated, so we report it here
                    if (!event.code) {
                        event.code = player.mediaPlayer.error && player.mediaPlayer.error.code;
                    }
                    player.qos.reportError(event);
                    return;
                }

                var error = player.mediaPlayer.error;

                // no error code and no error in the mediaplayer
                // consider this the same as the handled scenario
                if (typeof event.code == "undefined" && !error) {
                    return;
                }

                // assume critical and unknown defaults for the error initially
                var critical = true;
                var type = 'unknown';

                // XXX is this the opposite of the previous if that returned?
                if (error && typeof error.code!='undefined') {
                    if (DEBUG_FULL) { console.log("Player ERROR:" + error.code); }

                    event.code = error.code;
                    event.connection = player.mediaConnection;

                    // aborted
                    if (error.code == error.MEDIA_ERR_ABORTED) { // 1
                        if (DEBUG_FULL) { console.log('mediaError : error.code 1 - MEDIA_ERR_ABORTED - Playback aborted (' + elType + ')', error); }
                        type = SMPError.MEDIA_ERR_ABORTED;
                        switchConnectionFilter = false;
                        if (LoadBalancing.getAlternateMediaConnections(player, switchConnectionFilter)) {
                            switchConnection = true;
                            critical = false;
                        }
                    }
                    // network error
                    if (error.code == error.MEDIA_ERR_NETWORK) { // 2
                        if (DEBUG_FULL) { console.log('mediaError : error.code 2 - MEDIA_ERR_NETWORK - Network error (' + elType + ')', error); }
                        type = SMPError.MEDIA_ERR_NETWORK;
                        switchConnectionFilter = false;
                        if (LoadBalancing.getAlternateMediaConnections(player, switchConnectionFilter)) {
                            switchConnection = true;
                            critical = false;
                        }
                    }
                    // corruption/encoding
                    if (error.code == error.MEDIA_ERR_DECODE) { // 3
                        if (DEBUG_FULL) { console.log('mediaError : error.code 3 - MEDIA_ERR_DECODE - Media could not be decoded (' + elType + ')', error); }
                        type = SMPError.FORMAT_NOT_DECODED;
                        switchConnectionFilter = false;
                        if (LoadBalancing.getAlternateMediaConnections(player, switchConnectionFilter)) {
                            switchConnection = true;
                            critical = false;
                        } else {
                            if (Device.fallbackAfterDashDecodeError && player.isPlayingDash) {
                                if (player.supportFallback) {
                                    Utils.asyncDelay(player.fallbackAsAppropriate, [],player);
                                    critical=false;
                                }
                            }
                        }
                    }
                    // format not supported
                    if (error.code == error.MEDIA_ERR_SRC_NOT_SUPPORTED) { // 4
                        if (DEBUG_FULL) { console.log('mediaError : error.code 4 - MEDIA_ERR_SRC_NOT_SUPPORTED - Media source is not supported (' + elType + ')', error); }
                        // Not an error if the src is being set to '', which sometimes resolves to the iframe's url.
                        if (player.mediaPlayer.src === '' || player.mediaPlayer.src === window.location.href) {
                            if (DEBUG_FULL) { console.log('Not an error.'); }
                            return;
                        }
                        // SMPHTML-482: This is sometimes a lie with HLS content
                        switchConnectionFilter = true;
                        if (Device.supportsHls && player.mediaConnection && player.mediaConnection.format == "hls") {
                            switchConnectionFilter = false;
                        }

                        type = SMPError.FORMAT_NOT_SUITABLE;
                        if (LoadBalancing.getAlternateMediaConnections(player, switchConnectionFilter)) {
                            switchConnection = true;
                            critical = false;
                        }
                    }
                } else { // else we have no error on the element
                    if (DEBUG_FULL) { console.log('mediaError : unknown - there was an error event but no error on the element (' + elType + ') or code was not set', error); }
                    type = SMPError.MEDIA_ERR_WEIRD;
                    critical = false;
                }

                // if the event was deemed to be a critical error
                if (critical) {
                    // XXX need to investigate this a bit more, why is
                    // it here, what scenario is it for?
                    if (!player.continueAfterError) {
                        player.tryingToPlay = false;
                        player.autoPlayNextItem = false;
                    }
                    Utils.delayedErrorFunction(player, SMPError.NO_ALTERNATIVE_MEDIA);
                }
                if (type == 'unknown') {
                    if (critical) {
                        type = 'unknownCritical';
                    }
                } else {
                    if (elType != 'video') {
                        // add one to convert Video errors
                        // into their Audio counterparts;
                        type += 1;
                    }
                }

                var responseError = new SMPError(type, { connection: event.connection, playerError: error, networkState: player.mediaPlayer.networkState, mediaItem:player.mediaItem});
                if (switchConnection) {
                    responseError._queuedActions = [function() {
                        LoadBalancing.switchMediaConnection(player, switchConnectionFilter);
                    }];
                }
                return responseError;
            }
        }
    };

    function getElementType(mp, player) {
        if (mp == player.els.video) {
            return "video";
        }
        if (mp == player.els.audio) {
            return "audio";
        }
        if (mp == player.els['360']) {
            return "360";
        }
        return "unknown";
    }

    function setElementType(player,elType) {
        if ( player.elType === "unknown" ) {
            player.elType = player.mediaPlayer.localName || "unknown";
        }
        if ( elType != player.elType && player.autoPlayNextItem && !player.willAutoplayWhenPlayCalled[elType] && !Device.supportsAutoplay) {
            player.autoPlayNextItem = false; // This needs to be set to false because it does not match latest loadplaylist?
            // recall the playlistLoaded event due to the autoplay change.
            if (DEBUG_FULL) { console.log("*** can't autoplay as willAutoplayWhenPlayCalled:"+player.willAutoplayWhenPlayCalled[elType]+", autoplay:"+player.autoPlayNextItem+", elType:"+(elType!=player.elType)+" Player.js, setPlayerType player.ui.eventCallbacks.playlistLoaded();"); }
            player.tryingToPlay = false;
            player.autoPlayNextItem = false;
            player.mediaItemIndex = -1;
            player.dispatch({type:'resetUiToPlaylistLoaded'});
            // XXX should this be an error so we could find it?
            return false;
        }

        player.elType = elType;
        //        player.waitingForChange[elType] = false;
        player.mediaPlayer.autoplay = false;
        player.mediaPlayer.loop = false;

        if ( (elType === "audio") || (elType === "video") || (elType === "360") ) {
            player.selectMediaPlayer(elType);
            player.mediaPlayer.autoplay = !Device.supportsAutoplay;
            return true;
        }


        player.tryingToPlay = false;
        player.autoPlayNextItem = false;
        if (DEBUG_FULL) {  console.log("setPlayerType: handling who knows what"); }
        hidePlayer(player,"audio");
        hidePlayer(player,"video");
        Utils.delayedErrorFunction(player, SMPError.CONTENT_NOT_AV);

        return false;
    }

    function setLoadPlaylistCallbacks(player, url, playlistObject, fromQueue) {
        var playlist;
        if (DEBUG_FULL) { console.log('loadPlaylist : ' + url); }
        var playlistLoadedEvent = {type:"playlistLoaded", url:url, fromQueue : fromQueue};

        var successFunc = function() {
            if (!playlist.embedRight && player.ui && player.ui.config.embedded.enabled === true) {
                errorFunc( SMPError.getError(SMPError.EMBED_NOT_ALLOWED) );
            } else {
                if (player.loadingPlaylistURL == url) {
                    loadPlaylistComplete(player, playlistLoadedEvent);
                } else {
                    if (DEBUG_FULL) { console.log("Suppressing loaded event for old playlist"); }
                }
            }
        };
        // XXX this doesn't appear to make sense to me?  Why is it doing this?
        var errorFunc = function(error) {
            playlist.noItemsReason="ErrorLoadingPlaylist";
            player.playlist.loading = false;

            if (!PluginManager.isPluginLoading(playlistLoadedEvent)){
                distributeEvent(player,playlistLoadedEvent);
            }

            distributeEvent(player,error);
        };

        playlist = player.playlist = new Playlist(url, successFunc, errorFunc, playlistObject, player.config);
        player.mediationIndex = 0;
    }

    function loadPlaylistCompleteFinal(player,playlistLoadedEvent) {
        if (player.playlist) {
            var firstProg = player.playlist.items[player.playlist.firstProgramme];
            if (firstProg && firstProg.kind=='360' && player.config.deviceSupports360) {
                // XXX we could show poster here?
                if (player.threeSixty.fake && !player.threeSixty.failed) {
                    player.threeSixty.create(function() {
                                                 loadPlaylistCompleteFinal(player,playlistLoadedEvent);
                                             });
                    return;
                }
            }
        }

        player.state = '';
        player.autoPlayNextItem = false;
        player.mediaItemIndex = -1;
        if (player.config.autoplay && player.guidanceOk) {
            player.autoPlayNextItem = true;
        }
        try {
            distributeEvent(player,playlistLoadedEvent);
        } catch (e) {

            // this is very fatal error if there's a bind
            // to playlistLoaded which errors, so catch it
            // to enable user playback.
            console.error("%cplaylistLoadEvent errored","color:red;background-color:#ccc");
            if (DEBUG_FULL) { console.log("Error in distributing playlistLoad event", e); }
        }

        if (Utils.checkForItemsErrors(player,player.playlist)) {
            if (DEBUG_FULL) { console.log("Error no items errors, not doing anything else."); }
            return;
        }

        if (DEBUG_FULL) { console.info('dispatched load playlist, autoplay is:' + player.autoPlayNextItem); }
        if (player.autoPlayNextItem) {
            if (!player.tryingToPlay) {

                player.clearFakeTimer();

                player.tryingToPlay = true;
                player.waitingForStartTime = player.config.startTime;

                player.cueNextMediaItem();
            }
        } else {
            if (player.config.autoplay && player.config.promptGuidanceWhenAutoplay) {
                player.mediaPlayer.autoplay = false;
                if (DEBUG_FULL) { console.log('Requesting guidance'); }
                player.guidanceShow(false);
            }
        }
    }

    /**
     * Called when loadplaylist has successfully completed.
     * Sets up player media items.
     *
     */
    function loadPlaylistComplete(player, playlistLoadedEvent) {
        if (!PluginManager.isPluginLoading()){
            if (DEBUG_FULL) { console.log('loadPlaylistComplete',player.playlist); }
            var playlist = player.playlist;
            playlist.loading = false;
            // Write tests to cover multiple loadplaylists() scenario -
            // what should be final playlistLoaded
            playlistLoadedEvent.playlist = playlist;
            Utils.asyncDelay(loadPlaylistCompleteFinal,[player,playlistLoadedEvent]);
            PluginManager.playlistLoadedEvent = null;
        } else {
            if (!player.config.autoplay) {
                if (DEBUG_FULL) { console.log("showed poster early as we're waitin on plugin load, and there's no autoplay"); }
                player.ui.showPoster();
            }
            PluginManager.playlistLoadedEvent = playlistLoadedEvent;
        }
    }

    function getGettersAndSetters(player) {

        function supportFallbackByType(type,alsoSilent) {
            return Device.supportPlayerFallback && !player.config.noFallback && player.mediaItem && player.mediaItem[type] && !player.isPlaying360 && (alsoSilent || !player.mediaItem.failSilent);
        }

        return {
            state : {
                get: function () {
                    return player._state;
                },
                set: function(newState){
                    var oldState = player._state;
                    if (oldState !== newState){
                        player._state = newState;
                        if (oldState == 'busy' && newState === ''){
                            if (player.actionFnObjAfterWaiting){
                                var fnObj = player.actionFnObjAfterWaiting;
                                player.actionFnObjAfterWaiting = null;
                                fnObj.fn.apply(player, fnObj.args || []);
                            }
                        }
                        // dispatch event?
                    }
                }
            },
            mediaItem : {
                get : function() {
                    if (player.playlist && player.playlist.items) {
                        return player.playlist.items[player.mediaItemIndex];
                    }
                    return null;
                }
            },
            isPlaying360 : {
                get : function() {
                    return player.mediaItem && (player.mediaItem.kind == '360');
                }
            },
            isNextItemPlayable : {
                get : function() {
                    if (player.playlist) {
                        return player.playlist.getNextItem(Math.max(player.mediaItemIndex,0))!=null;
                    }
                    return false;
                }
            },
            continueAfterError : {
                get : function() {
                    // XXX we should always continue after any error
                    // if there are more items in the current playlist
                    // to play, or if there is a queued up element and
                    // the behaviour is for SILENT errors
                    if (player.playlist) {
                        if (player.playlist.getNextItem(Math.max(player.mediaItemIndex,0))!=null) {
                            return true;
                        }
                        // there is a queued up playlist
                        if (player.playlist.queuedPlaylist && player.mediaItem && player.mediaItem.failSilent) {
                            return true;
                        }
                    }
                    return false;
                }
            },
            shouldReport : {
                get : function() {
                    return (player.mediaItem && !player.mediaItem.isIdentOrWarning);
                }
            },
            mediaConnection : {
                get : function() {
                    var mediaItem = player.mediaItem;

                    if (mediaItem && mediaItem.useFlash) {
                        return player.swf.mediaConnection;
                    }

                    var mediaConnections = (mediaItem && mediaItem.connections ? mediaItem.connections : []);
                    return mediaConnections[0];
                }
            },
            isPlayingDash : {
                get : function() {
                    var mediaConnection = player.mediaConnection;
                    return mediaConnection && mediaConnection.format === 'dash';
                }
            },
            isPlayingHls : {
                get : function() {
                    var mediaConnection = player.mediaConnection;
                    return mediaConnection && mediaConnection.format === 'hls';
                }
            },
            isPlayingFlash : {
                get : function() {
                    var mediaConnection = player.mediaConnection;
                    return mediaConnection && (mediaConnection.format === 'swf' || mediaConnection.format === 'HDS');
                }
            },
            time : {
                get : function() {
                    var chromecast = player.Chromecast;
                    var time = parseFloat(player.mediaPlayer.currentTime + player.timeHelper.presentationTimeOffset);
                    time = player.timeHelper.streamTimeToUnixTime(time);
                    if (chromecast.isCasting) {
                        time = chromecast.fakeTime;
                    }
                    return  (isNaN(time) ? 0 : time);
                },
                set : function(time) {
                    if (player.outOfControl) {
                        if (DEBUG_FULL) { console.log("not seeking... out of control"); }
                        return;
                    }
                    if (player.inErrorState) {
                        if (DEBUG_FULL) { console.log("not seeking... in error state"); }
                        return;
                    }

                    if (!player.mediaItem) {
                        // XXX there's no mediaItem yet, reset the currentTime
                        player.config.startTime = time;
                        return;
                    }

                    if ( player.Chromecast.ccSeek(time) ) {
                        return;
                    }

                    if (!player.timeHelper.canSeek()) {
                        if (DEBUG_FULL) { console.log("player can not seek, failing trying to set the time"); }
                        return;
                    }

                    var setTimeFn = function() {

                        time = player.timeHelper.checkIfTimeIsAvailable(time);

                        time = player.timeHelper.unixTimeToStreamTime(time);

                        // SMPHTML-1025 - Fixes seeking to the end of some HLS streams on iPad
                        if (time == player.timeHelper.latestSeek) {
                            time = time - 0.001;
                        }

                        var mp = player.mediaPlayer;
                        var ct = parseFloat(mp.currentTime) || 0;

                        time -= player.timeHelper.presentationTimeOffset;
                        if (DEBUG_FULL) { console.log("setting time to: " + time + " dur: " + parseFloat(mp.duration) + " / ct:" + ct ); }

                        try {
                            mp.currentTime = time;
                        } catch(e) {
                            if (DEBUG_FULL) { console.log("set failed setting it back to: " + mp); }
                            try {
                                mp.currentTime = ct;
                            } catch (f) {
                                // XXX what's the point of this?
                            }
                        }
                        player.timeHelper.update(player.time, player.duration);
                        player.timeHelper.forcedTime = null;
                    };

                    var th = player.timeHelper;
                    if (player.isPlayingDash &&
                        player.dashEvents.isLiveWebcast &&
                        th.latestSeek - time < 90 &&
                        time > player.mediaPlayer.currentTime)
                    {
                        //TODO: There's a more intelligent time from live edge condition that could be used here.
                        player.timeHelper.forcedTime = th.latestSeek;
                        player.dashEvents.refreshManifest(setTimeFn);
                    } else {
                        setTimeFn();
                    }
                }
            },
            duration : {
                get : function() {
                    var mediaItem = player.mediaItem;
                    if (!mediaItem) {
                        return 0;
                    }

                    // XXX would like to get rid of chromecast from here.
                    var chromecast = player.Chromecast;
                    var duration = 0;
                    if (chromecast.isCasting) {
                        duration = chromecast.duration;
                    } else {
                        duration = (!player.isLive ? parseFloat(player.mediaPlayer.duration) : Infinity);
                    }

                    if (duration < 1) {
                        duration = player._duration;
                    }
                    return (isNaN(duration) ? 0 : duration);
                }
            },
            isLive : {
                get : function() {
                    var mediaItem = player.mediaItem;
                    if (!mediaItem) {
                        return false;
                    }
                    return (mediaItem.live);
                }
            },
            isAudio : {
                get : function() {
                    var mediaItem = player.mediaItem;
                    if (!mediaItem) {
                        return false;
                    }
                    return mediaItem.type == 'audio';
                }
            },
            isThreeSixty: {
                get : function() {
                    var mediaItem = player.mediaItem;
                    if (!mediaItem) {
                        return false;
                    }
                    return mediaItem.type == '360';
                }
            },
            playlistHasAudio : {
                get : function() {
                    var items = [];
                    if (player.playlist && player.playlist.items) {
                        items = player.playlist.items;
                    }
                    for (var i = 0; i < items.length; i++) {
                        if (items[i].type == "audio") {
                            return true;
                        }
                    }
                    return false;
                }
            },
            /**
             * Get the buffered range end time nearest the currentTime
             *
             */
            buffered : {
                get : function() {
                    var pto = player.timeHelper.presentationTimeOffset;
                    var mediaPlayer = player.mediaPlayer;
                    var buff = mediaPlayer.buffered;
                    if (!buff) {
                        return 0;
                    }
                    // return the end time of the range that is buffered
                    for (var i=0;i<buff.length;i++) {
                        var start = buff.start(i) + pto;
                        var end = buff.end(i) + pto;
                        if (start <= mediaPlayer.currentTime + pto && mediaPlayer.currentTime + pto < end) {
                            return end;
                        }
                    }
                    return 0;
                }
            },
            /**
             * Get the buffered range end time nearest the currentTime
             * XXX we should reconsider this existing, should only be used for live and doesn't make sense with DASH.
             */
            seekable : {
                get : function() {
                    var mediaPlayer = player.mediaPlayer;
                    var seek = mediaPlayer.seekable;
                    if (!seek) {
                        return {
                            start: 0,
                            end: 0
                        };
                    }
                    var start = Infinity;
                    var end = 0;

                    // return the end time of the range that is seeked
                    for (var i = 0; i < seek.length; i++) {
                        if (seek.start(i) < start) {
                            start = seek.start(i);
                        }
                        if (seek.end(i) > end) {
                            end = seek.end(i);
                        }
                    }

                    return {
                        start: start,
                        end: end
                    };
                }
            },
            paused : {
                get : function() {
                    // XXX should consider how this is used and if it
                    // should be about the intention of being paused
                    // rather than the actual mediaplayer
                    return player.mediaPlayer.paused;
                }
            },
            ended : {
                get : function() {
                    return player.mediaPlayer.ended;
                }
            },
            volume : {
                get : function() {
                    return player._volume;
                },
                set: function(vol) {
                    if (vol > 1) {
                        vol = 1;
                    }
                    if (vol < 0) {
                        vol = 0;
                    }
                    if (vol === 0) {
                        player.muted = true;
                    } else {
                        if (player._volume!=vol) {
                            player._volume = vol;
                            if (player.mediaPlayer) {
                                // this will dispatch a volumechange,
                                player.mediaPlayer.volume = player._volume;
                                player.mediaPlayer.muted = false;
                                player._muted = false;
                            } else {
                                player._volume = vol;
                                player._muted = false;
                                player.dispatch({type:"volumechange", volume:player._volume,muted:player._muted});
                            }
                        }
                    }
                }
            },
            muted : {
                get : function() {
                    return player._muted;
                },
                set: function(mute) {
                    if ((mute===true || mute===false) && mute!=player._muted) {
                        player._muted = mute;
                        if (player.mediaPlayer && player.willAutoplayWhenPlayCalled[ getElementType(player.mediaPlayer,player)]) {
                            // this will dispatch a volumechange,
                            player.mediaPlayer.muted = player._muted;
                        } else {
                            player.dispatch({type:"volumechange", volume:player._volume,muted:player._muted});
                        }
                    }
                }
            },
            guidanceOk : {
                get : function() {
                    return ( player.hasGuidancePassed || !player.playlist || player.playlist.guidance === "" || !player.ui.config.guidance.pinRequired );
                }
            },
            supportFallback : {
                get : function() {
                    return supportFallbackByType("flashAvailable");
                }
            },
            supportFallbackPrefer : {
                get : function() {
                    return supportFallbackByType("flashAvailable",true);
                }
            },
            supportFallbackLocked : {
                get : function() {
                    return supportFallbackByType("flashAvailableUnlocked");
                }
            },
            version : {
                get : function() {
                    return '2.24.0.SMPHTML5';
                }
            },
            build : {
                get : function() {
                    return '2.24.0.4d14091'+_isUK+(experimentalDash? '.x' : '');
                }
            },
            hasGuidancePassed : {
                get : function() {
                    var g = player.config.guidance;
                    return (g.guidanceSkipped || g.guidancePINPassed) && !g.isGuidanceLocked && (!player.config.under16 || (player.config.under16 && player.under16permissionConfirmed));
                }
            },
            under16permissionConfirmed : {
                get : function() {
                    var g = player.config.guidance;
                    return g.under16permissionConfirmed;
                }
            },
            consideredMobileConnection : {
                get : function() {
                    // should we consider a wifi with low throughput
                    // or something here as mobile.

                    if (player.config.mobileNetwork) {
                        if (navigator.connection && navigator.connection.effectiveType=="4g") {
                            return false;
                        }
                        return true;
                    }
                    return false;
                }
            },
            ratio : {
                get : function() {
                    var ratio = player.mediaPlayer.videoHeight/player.mediaPlayer.videoWidth;
                    if (isNaN(ratio)) {
                        ratio = 9/16;
                    }
                    return ratio;
                }
            },
            quality: {
                get: function() {
                    return player._quality;
                },
                set: function(quality) {
                    player._quality = quality;

                    player.swf.applyQuality();
                    player.dashEvents.applyQuality();
                }
            },
            hasNext: {
                get: function() {
                    return player.isNextItemPlayable || (player.playlist && player.playlist.queuedPlaylist);
                }
            },
            hasPrevious: {
                get: function() {
                    return (player.playlist.getPreviousItemIndex(player.mediaItemIndex) != null) || (player.playlist && player.playlist.previousPlaylist);
                }
            }
        };
    }

    /**
     * Constructor for Player class
     *
     */
    var _uidCount=0;
    var Player = function() {
        var player = this;

        player.jsapiFunc = function() { };
        player.threeSixty = {
            fake:true,
            failed:false,
            showCompass: function() {},
            hideCompass: function() {},
            hideCanvas: function() {},
            showCanvas: function() {},
            create:function(fn) {
                player.threeSixtyLoadingFn = fn;
                if (!player.threeSixty.loading) {
                    var html360ComponentUrl = DEBUG_FULL ? '/emp/html360Component/1.1.4' + '/html360Component.js' : '/emp/html360Component/1.1.4' + '/html360Component.min.js';
                    player.threeSixty.loading = true;
                    player.dispatch({type:"loadingThreeSixty"});
                    if (DEBUG_FULL) { console.log("Requiring three sixty:"+html360ComponentUrl); }
                    // XXX what happens if it fails?
                    require([html360ComponentUrl], function() {
                            clearTimeout(player.threeSixtyTimer);
                            if (DEBUG_FULL) { console.log("Required three sixty loaded"); }
                            player.threeSixty = new ThreeSixty(player);
                            for (var ev in player.threeSixty.eventCallbacks) {
                                if (player.threeSixty.eventCallbacks.hasOwnProperty(ev)) {
                                    player.threeSixtyEventCallbacks[ev] = player.threeSixty.eventCallbacks[ev];
                                }
                            }
                            player.threeSixtyLoadingFn();
                        });
                     player.threeSixtyTimer = setTimeout(function() {
                                   if (DEBUG_FULL) {
                                       console.log('Three Sixty Loading Failed');
                                   }
                                   player.threeSixty.failed = true;
                                   player.threeSixty.loading = false;
                                   Utils.delayedErrorFunction(player, SMPError.THREE_SIXTY_FAILED );
                                   if (player.threeSixtyLoadingFn) {
                                       player.threeSixtyLoadingFn();
                                   }
                               },30000);
                }
            }
        };
        player.threeSixtyEventCallbacks={};
        player.swf = {
            fake:true,
            hide:function() {},
            pause:function() {},
            kill:function() {},
            enableMouseUIBypass: function() {},
            disableMouseUIBypass: function() {},
            applyQuality: function() {}
        };

        // currently playing media item index
        player.mediaItemIndex = -1;

        // volume and mute of player
        player._volume = 1;
        player._muted = false;

        player.isSeeking = false;

        player._state="";

        player.config = defaultConfig;

        // Playlist object
        player.playlist = null;

        // references to player elements
        player.els = {};

        player.pauseTimes = [];

        player.tryingToPlay = false;

        player.isFullScreen = false;

        player.waitingForChange = {
            video: false,
            '360':false,
            audio: false
        };

        player.uid = "player_"+(_uidCount++);

        player.mediaContainer = document.getElementById('mediaContainer');

        // add audio/video elements inside media container
        player.mediaPlayer = player.els.video = player.mediaContainer.firstChild;
        player.els.video.id="p_v_"+player.uid;
        player.els.video.setAttribute("aria-hidden", true);
        player.els.audio = document.createElement('audio');
        player.els.audio.id="p_a_"+player.uid;
        player.els.audio.preload="metadata";
        player.els.audio.setAttribute("aria-hidden", true);

        player.els['360'] = document.createElement('video');
        player.els['360'].id="p_360_"+player.uid;
        player.els['360'].preload="metadata";
        player.els['360'].setAttribute("crossorigin","anonymous");
        player.els['360'].setAttribute("webkit-playsinline","webkit-playsinline");
        player.els['360'].setAttribute("playsinline","playsinline");
        player.els['360'].setAttribute("aria-hidden", true);
        player.els['360'].style.left=HIDDEN_PLAYER;

        player.mediaContainer.insertBefore(player.els['360'], player.mediaContainer.firstChild);

        hidePlayer(player,"video");

        // The following prevent play/pause issue on Android Browsers
        player.els.video.addEventListener('click', preventDefault, false);
        player.els['360'].addEventListener('click', preventDefault, false);

        Utils.defineProperties(player,getGettersAndSetters(player));

        return player;
    };

    function attemptToSetJSAPI(id, player) {
        var func;
        try {
            func = parent.embeddedMedia.playerInstances[id].getHandleJSAPI();
            if (DEBUG_FULL) { console.log("Using shortcut jsapi"); }
        } catch (e) {
            func = function(ev) {
                xd.fire('jsapi',ev);
            };
            if (DEBUG_FULL) { console.log("Using xd jsapi"); }
        }
        player.jsapiFunc = function(event) {
            var ev = {};
            for (var i in event) { // jshint ignore:line
                // XXX This is a lint warning, but it's
                // right... what's the lint exclusion syntax for a
                // single rule?
                var typeOF = typeof(event[i]);
                if ((typeOF != "object" && typeOF != "function") || event.hasOwnProperty(i)) {
                    // XXX let's rethink how we do these, there must
                    // be a better way of not exposing anything we
                    // shouldn't?  Need to come up with something as
                    // this can also cause circular errors on
                    // stringify
                    if (i != "_" && i != "srcElement" && i != "target"  && i != "currentTarget" && i != "path" && i != "unwanted") {
                        ev[i] = event[i];
                    }
                }
            }
            try {
                func(ev);
            } catch (e) {
                console.error("%cError calling out to page: "+e.message,"color:red;background-color:#ccc");
                if (DEBUG_FULL) {
                    console.error("Error calling out to page:"+e.stack);
                }
            }
        };
    }

    function pretendWeNeverTriedAutoplay(player){
        player._state = '';
        player.willAutoplayWhenPlayCalled.video = false;
        player.willAutoplayWhenPlayCalled.audio = false;
        player.willAutoplayWhenPlayCalled['360'] = false;
        player.tryingToPlay = false;
        player.autoPlayNextItem = false;
        player.mediaItemIndex = -1;
        player.autoplayTimeoutRetryAttempted = true;
        Device.requiresFakePlayEvent = true;
        player.dispatch({type:'resetUiToPlaylistLoaded'});
    }

    Player.prototype = {
        init : function(data) {
            var passedConfig = data.player.vars;
            var domId = data.id;
            if (DEBUG_FULL) {  console.log('Player.init', passedConfig, domId); }
            var player = this;
            player.playbackMightRestartLater = {};
            attemptToSetJSAPI(domId, player);

            if (!passedConfig.bitrateCeiling && (passedConfig.mediatorHref+'').indexOf('/mediaset/pc/')>0) {
                defaultConfig.bitrateCeiling.plain = 1800;
                player.config.bitrateCeiling.plain = 1800;
            }

            player.updateConfig(passedConfig, true);

            addFullscreenEvent(player,passedConfig.insideIframe);

            initPlayerComponents(player);

            addPrefetch(player.config.mediatorHref);
            addPrefetch(player.config.samlMediatorHref);

            player.firstPlaylist = true;
            distributeEvent(player,{type: "initialised", version: player.version});
            return player;
        },
        /**
         * Cue and return next media item
         */
        cueNextMediaItem : function(doNotPlay) {
            if (DEBUG_FULL) { console.log('Player.cueNextMediaItem'); }

            var player = this;

            player.playbackMightRestartLater={};

            if (player.mediaItemIndex<0) {
                player.mediaItemIndex = 0;
            } else {
                player.mediaItemIndex++;
            }
            var mediaItem = player.mediaItem;
            if (DEBUG_FULL) { console.log('New mediaItem',mediaItem); }
            if (!mediaItem) {
                // XXX set the mediaitem back to the previous so it
                // can replayed, this feels a bit yucky.
                player.mediaItemIndex -= 1;

                if (player.mediaConnection && (player.mediaPlayer.currentSrc == player.mediaConnection.href )) {
                    player.reloadToStart = true;
                }

                var willAutomaticPlayQueuedItem = !!(player.playlist && player.playlist.queuedPlaylist) && !player.config.noAutomaticNextQueued;

                player.delayedDispatch({type:"playlistEnded", willAutomaticPlayQueuedItem : willAutomaticPlayQueuedItem});
                return;
            }

            if (mediaItem.kind == "advert") {
                if (DEBUG_FULL) { console.log('advert cueing another'); }
                player.autoPlayNextItem = true; // Skipping ads so start playing the main item.
                return player.cueNextMediaItem();
            }

            player.reset(true);
            player.delayedDispatch(mediaItem.changeEvent);
            player.thumbScrub.newMediaItem(mediaItem);

            if (!doNotPlay) {
                player.tryingToPlay = true;
                player.delayedDispatch({type:"tryingToPlay"});
            }

            if (player.config.alwaysUseFlashPlayer) {
                mediaItem.useFlash = true;
            }

            if (mediaItem.kind == "360" && !player.config.deviceSupports360) {
                    Utils.delayedErrorFunction(player, SMPError.DEVICE_NOT_SUPPORTED );
                    return;
            }

            if (mediaItem.useFlash) {
                player.autoPlayNextItem = !doNotPlay;
                Utils.asyncDelay(playFlash,[player]);
                return;
            }

            if (mediaItem.mediationAttempted) {
                if (DEBUG_FULL) { console.log('no mediation needed'); }
                player.autoPlayNextItem = !doNotPlay;
                Utils.asyncDelay(getAfterMediationFn(player),[mediaItem]);
                return;
            }
            if (DEBUG_FULL) { console.log('Mediating...'); }
            if (mediaItem.kind == 'ad'){
                player.dispatch({type:'requestAd'});
                return mediaItem;
            }
            Utils.asyncDelay( LoadBalancing.mediate,[mediaItem, player.consideredMobileConnection, getAfterMediationFn(player)],LoadBalancing);

            return mediaItem;
        },
        mediaSrc : function(src) {
            var player = this;
            var item = player.mediaItem.connections[0];
            // XXX consider moving the changingsrc event somewhere
            // that copies more of the connection items.
            distributeEvent(player,{ type: "changingsrc", supplier: item.supplier, encoding: item.encoding, format: item.format });
            if (DEBUG_FULL) { console.log('set mediaSrc : ' + src + " (" + item.supplier + "), player.mediaPlayer: " + player.mediaPlayer); }
            player.streamFailing = false;

            // XXX we need to change the src to something else
            // immediately, otherwise the previous source is
            // remembered...
            if (player.isPlayingDash) {
                if (player.isAudio ? Device.supportsAudioDash : Device.supportsVideoDash) {
                    if (player.preloadDashEvents) {
                        player.dashEvents.reset();//Kill the old.
                        player.dashEvents = player.preloadDashEvents;//Switch to the new.
                        player.preloadDashEvents = null;

                        player.dashEvents.setErrorHandler(Utils.callErrorFunction);
                        player.dashEvents.setMediaElement(player.mediaPlayer);
                    } else {
                        player.dashEvents.create();
                        player.dashEvents.reset();
                        player.dashEvents.setErrorHandler(Utils.callErrorFunction);
                        player.dashEvents.setMediaElement(player.mediaPlayer);
                        player.dashEvents.setSrc(player.mediaItem.connections);
                    }

                    player.dashEvents.applyQuality();

                } else {
                    if (!LoadBalancing.getAlternateMediaConnections(player, true) ) {
                        player.tryingToPlay = false;
                        player.autoPlayNextItem = false;
                        Utils.callErrorFunction(player, SMPError.PLAYING_DASH_WHEN_NOT_SUPPORTED);
                    }
                }
            } else {
                player.dashEvents.resetSrc();
                var elType = getElementType(player.mediaPlayer,player);
                player.waitingForChange[elType] = false;
                player.mediaPlayer.src = src;
                if (DEBUG_FULL) { console.log('set mediaSrc, calling load..'); }
                player.mediaPlayer.load();

                //SMPHTML-1394
                if (Device.cannotDetectAutoplayFailure) {
                    var delay = 20000;

                    if (DEBUG_FULL) { console.log('this device cannot detect a potential autoplay failure... will possibly show CTA in '+(delay/1000)+' seconds'); }

                    clearTimeout(player.noCanplayEventTimeout);
                    player.noCanplayEventTimeout = setTimeout(function() {
                                    pretendWeNeverTriedAutoplay(player);
                               },delay);
                }


                if (Device.requiresFakePlayEvent) {
                    if (DEBUG_FULL) { console.log('..and also requires play'); }
                    playWithPromise(player);
                }
                player._duration = 0;
            }

            if (player.preloadStoredErrors) {
                for (var i = 0; i < player.preloadStoredErrors.length; i++) {
                    var err = player.preloadStoredErrors[i];
                    player.qos.reportError(err);
                }
                player.preloadStoredErrors = null;
            }
        },
        startPlayback : function(nonUserBypass) {
            if (DEBUG_FULL) { console.log('startPlayback'); }
            var player = this;

            if (player.outOfControl) {
                if (DEBUG_FULL) { console.log("not playing... out of control"); }
                return;
            }
            if (player.inErrorState) {
                if (DEBUG_FULL) { console.log("not playing... in error state"); }
                return;
            }
            if (player.tryingToPlay) {
                if (DEBUG_FULL) {  console.log("not playing... already trying to play"); }
                return;
            }

            if (player.Chromecast.setCastPlayState()) {
                if (DEBUG_FULL) {  console.log("not playing... currently casting"); }
                return;
            }

            if (!player.playlist) {
                if (DEBUG_FULL) { console.log("refusing to play because there is no playlist"); }
                return;
            }

            player.clearFakeTimer();

            // Anything you put here needs to be considered for the
            // autoplay version in loadCompleteFinal, can we refactor
            // into single call?
            player.tryingToPlay = true;
            player.playCalled=false;

            player.state = 'busy';

            var playlist = player.playlist;

            if (!nonUserBypass && playlist) {
                // As we mediate after play intent, need to capture intent with blank media here, the other will be loadplaylist with autoplay
                setBlankMedia(player,playlist.mediaType);
            }

            player.waitingForStartTime = isNaN(player.config.startTime) ? 0 : player.config.startTime;

            if (player.mediaItemIndex == -1 && playlist && playlist.items.length > 0) {
                if (DEBUG_FULL) { console.log('not ready to play'); }
                if (player.cueNextMediaItem()) {
                    if (DEBUG_FULL) { console.log('setting autoPlayNextItem'); }
                    player.autoPlayNextItem = true;
                }
                return;
            }

            var mediaPlayer = player.mediaPlayer;
            if (DEBUG_FULL) { console.log('html5 play method called'); }

            if (player.reloadToStart) {
                player.reloadToStart=false;
                mediaPlayer.load();
                // shouldn't be able to get here without a media item,
                // but you know, Lloyd did.
                if (player.mediaItem) {
                    player.mediaItem.gotWindow = false;
                }
                player.mediaItemIndex = player.mediaItemIndex - 1;
                if (player.cueNextMediaItem()) {
                    if (DEBUG_FULL) { console.log('setting autoPlayNextItem'); }
                    player.autoPlayNextItem = true;
                }
                return;

            }

            // Certain videos go crazy when they have fully played and
            // you try to replay, this fixes it for ipad.
            if (Device.requiresRestartAdjustmentAtEnd && mediaPlayer.currentTime == mediaPlayer.duration) {
                if (DEBUG_FULL) { console.log('StartAdjustment at end being done.'); }
                mediaPlayer.currentTime = 0.1;
            }

            if (DEBUG_FULL) { console.log('play called on src: ' + mediaPlayer.src + ", \nplayer.mediaConnection ", player.mediaConnection + ", mediaPlayer: " +mediaPlayer); }

            // XXX we can get here when there is no mediaConnection,
            // that would be nonsense I'm sure?  What does this
            // actually do?  XXX need to think about the promise here
            // too, need to understand more about how we can get here.
            if (player.mediaConnection) {
                playWithPromise(player);
            } else {
                player.tryingToPlay = true;
                player.autoPlayNextItem = true;
                Utils.asyncDelay(pickInitialConnection,[player]);
            }

            return true;
        },
        previous : function(andPlay) {
            var player = this;
            var autoplay = andPlay || !player.ui.inPrePlayState;
            var item = player.playlist.getPreviousItemIndex(player.mediaItemIndex);
            if (item!=null) {
                player.mediaItemIndex = item-1;
                player.cueNextMediaItem(!autoplay);
             } else {
                player.queuePreviousPlaylist(autoplay);
            }
        },
        next : function(andPlay) {
            var player = this;
            var autoplay = andPlay || !player.ui.inPrePlayState;
            if (player.isNextItemPlayable) {
                if (player.mediaItemIndex < 0)  {
                    player.mediaItemIndex = 0;
                }
                player.cueNextMediaItem(!autoplay);
             } else {
                player.queueNextPlaylist(autoplay);
            }
        },
        /**
         * Pause the video
         */
        pause : function() {

            var player = this;

            if (player.Chromecast.setCastPlayState()) {
                return;
            }

            if (player.state == 'busy'){
                player.actionFnObjAfterWaiting = {fn:player.pause, args:null};
                return;
            }

            if (!player.timeHelper.canSeek()) {
                player.stop();
                return;
            }

            if (DEBUG_FULL) { console.log('Player.pause'); }

            player.tryingToPlay = false;
            player.autoPlayNextItem = false;
            player.mediaPlayer.pause();

            if (player.timeHelper.hasRewindWindow()) {
                player.clearFakeTimer();
                player.fakeTimeupdateTimer = setInterval(function() {
                    distributeEvent(player,{type:"timeupdate", fake:true});
                    // XXX Should we rely on setInterval for this, could
                    // be throttled?
                    // should use Performance timer for the delta
                },1000);
            }
        },
        seekToPercent : function(destination) {

            var player = this;

            var destinationReal = player.timeHelper.percentToTime(destination);

            player.time = destinationReal;

        },
        seekForward : function(amount) {

            var player = this;

            player.time += amount;

        },
        seekBackward : function(amount) {

            var player = this;

            player.time -= amount;

        },
        suspend : function() {
            if (DEBUG_FULL) { console.log('Player.suspend'); }
            var player = this;
            if (player.mediaItem) {
                if (player.mediaItem.useFlash && player.swf.ready) {
                    player.swf.call('suspend');
                } else {
                    player.pause();
                    // XXX do we actually want this?
                    // don't we just want pause() stop DASH scheduling?
                    // does this stop give us anything in the suspend case?
                    Utils.asyncDelay(player.stop,[],player);
                }
            }
        },
        /**
         * Stop the video
         */
        stop : function() {
            if (DEBUG_FULL) { console.log('Player.stop'); }
            var player = this;

            player.tryingToPlay = false;
            player.autoPlayNextItem = false;
            player.waitingForChange[player.elType] = false;

            // XXX need to manage playing dash restart conditions, or
            // does the dash events reset work okay?  Needed for live
            // dash with no rewind window, otherwise can't play after
            // pause.

            player.reloadToStart = true;


            player.clearFakeTimer();
            player.timeHelper.reset(); // mainly to avoid a seeking bar flickering
            player.timeHelper.setStartTimeAvailable(false);

            if (!player.destroying) {
                // XXX Strange name, should this not just be stop?
                distributeEvent(player,{type:"playerDisconnected"});
            } else {
                distributeEvent(player,{type:"playerDestroying"});
            }
            hidePlayer(player,player.elType,true);

            // XXX can we change this to just stop all scheduling
            // until the next play or something, rather than fully
            // reset?
            player.dashEvents.reset();
        },
        hidePlayer : function(type,pause) {
            var player = this;
            if (!type) {
                type = player.elType;
            }
            hidePlayer(player,type,pause);
        },
        /**
         * Toggle between maximise and minimise states
         */
        toggleFullscreen : function() {
            if (DEBUG_FULL) { console.log('Player.toggleFullscreen'); }
            var player = this;
            if (player.isFullScreen) {
                player.minimise();
            } else {
                player.maximise();
            }
        },
        // This API is also used by the PluginManager
        selectMediaPlayer : function(elType) {
            var player=this;
            if (DEBUG_FULL) { console.log("handling " +elType); }

            // re-assign mediaPlayer to current media tag
            player.mediaPlayer = player.els[elType];

            // Set the volume on the new media player
            player.mediaPlayer.volume = player.volume;
            player.mediaPlayer.muted = player.muted;

            // if selected element is not in the DOM - add it
            if (!player.els[elType].parentNode) {
                player.mediaContainer.insertBefore(player.els[elType], player.mediaContainer.firstChild);
            }
            if (elType!=="video") {
                hidePlayer(player,"video");
            }
            if (elType!=="audio") {
                hidePlayer(player,"audio");
            }
            if (elType!=="360") {
                hidePlayer(player,"360");
            }
        },
        /**
         * Send the player into browser full screen, or make the player as large
         * as will fit in the available window while preserving aspect ratio
         */
        maximise : function(fromEvent) {
            if (DEBUG_FULL) { console.log('Player.maximise, fromEvent is ' + fromEvent); }
            var player = this;

            player.ui.enabled = false;
            // if there's no resize, ensure that it's re-enabled
            setTimeout(function() {
                           player.ui.enabled = true;
                       },2000);

            player.ignoringFullscreenChanges = true;
            setTimeout(function() {
                           player.ignoringFullscreenChanges = false;
                       },400);
            var maximiseResize = function () {
                if (DEBUG_FULL) { console.log('Player.maximise - in maximiseResize'); }
                player.pageFullScreenStylesNeeded = true;
                distributeEvent(player,{type:"beforeFullscreenEnter", applyPageFullScreen: player.pageFullScreenStylesNeeded });

                if (Device.requiresFullscreenResizeDelay) {
                    player.mediaContainer.style.height = "0px";
                    player.mediaContainer.style.width = "0px";
                }

            };

            if (!player.isFullScreen && player.ui.config.fullscreen.enabled) {
                if (!fromEvent) {
                    if (DEBUG_FULL) { console.log('Player.maximise - not from event'); }
                    if (DEBUG_FULL) { console.log('Player.maximise - addedFullscreenListenerTop is true'); }
                    // check if we can send the iframe fullscreen
                    if (Device.fullscreenEnabled(document)) {
                        if (DEBUG_FULL) { console.log('Player.maximise - requesting the iframe go full screen'); }
                        player.pageFullScreenStylesNeeded = Device.requiresPageFullScreenStyles;
                        distributeEvent(player,{type:"beforeFullscreenEnter", applyPageFullScreen:player.pageFullScreenStylesNeeded });
                        Device.requestFullscreen(document.documentElement);
                        player.iframeFullscreen = true;
                    } else { // otherwise check if we can send the parent document fullscreen
                        maximiseResize();
                        if (player.addedFullscreenListenerTop) {
                            if (Device.fullscreenEnabled(top.document)) {
                                if (DEBUG_FULL) { console.log('Player.maximise - requesting the parent document go full screen'); }
                                Device.requestFullscreen(top.document.documentElement);
                            }
                        }
                    }
                } else {
                    if (DEBUG_FULL) { console.log('Player.maximise - from event'); }
                    // this asumes we don't need to do any in-page sizing - is this correct?
                    distributeEvent(player,{type:"beforeFullscreenEnter"});
                }
                distributeEvent(player,{type:"fullscreenEnter"});
            }
        },
        /**
         * Restore maximised player to its original dimensions
         */
        minimise : function(fromEvent) {
            if (DEBUG_FULL) { console.log('Player.minimise - fromEvent is ' + fromEvent); }
            var player = this;

            if (!player.isFullScreen) {
                return;
            }

            player.ui.enabled = false;
            player.ignoringFullscreenChanges = true;
            setTimeout(function() {
                           player.ignoringFullscreenChanges = false;
                       },400);

            // there is some commonality with the function defined in
            // maximise - we can probably put this somewhere more
            // sensible and reuse
            var minimiseResize = function () {
                if (DEBUG_FULL) { console.log('Player.minimise - in minimiseResize'); }

                distributeEvent(player,{type:"beforeFullscreenExit", applyPageFullScreen:player.pageFullScreenStylesNeeded});
                player.pageFullScreenStylesNeeded = false;


                player.els.video.style.height = "";
                player.els.video.style.top = "";

                if (Device.requiresFullscreenResizeDelay) {
                    player.mediaContainer.style.height = "0px";
                    player.mediaContainer.style.width = "0px";

                    clearTimeout(player.fsTimeout);
                    player.fsTimeout = setTimeout(function() {
                                       player.mediaContainer.style.height = "";
                                       player.mediaContainer.style.width = "";
                                   },500);
                } else {
                    player.mediaContainer.style.height = "";
                    player.mediaContainer.style.width = "";
                }
            };

            if (!fromEvent) {
                if (DEBUG_FULL) { console.log('Player.minimise - not from event'); }
                // if the iframe can be made fullscreen, we need
                // to call exit on the document
                if (Device.fullscreenEnabled(document)) {
                    if (DEBUG_FULL) { console.log('Player.minimise - requesting the iframe exit full screen'); }
                    minimiseResize();
                    Device.exitFullscreen(document);
                    player.iframeFullscreen = false;
                } else {
                    // otherwise we should call exit on the parent document
                    minimiseResize();
                    if (player.addedFullscreenListenerTop) {
                        if (Device.fullscreenEnabled(top.document)) {
                            if (DEBUG_FULL) { console.log('Player.minimise - requesting the parent document exit full screen'); }
                            Device.exitFullscreen(top.document);
                        }
                    }
                }
            } else {
                if (DEBUG_FULL) { console.log('Player.minimise - from event'); }
                if (DEBUG_FULL) { console.log('Player.minimise - pageFullScreenStylesNeeded is ' + player.pageFullScreenStylesNeeded); }
                minimiseResize();
            }

            distributeEvent(player,{type:"fullscreenExit"});

            // in Player Parental Guidance:
            // if leaving fullscreen when Player guidance is showed
            // and container is too small, then call bump guidance
            setTimeout(function() {
                           // if there's no resize then the ui never
                           // gets re-enabled it, ensure that it does.
                player.ui.enabled = true;
                if ( (player.ui.pGuidance.nowShowing) && (player.mediaContainer.clientWidth < 400 || player.mediaContainer.clientHeight < 400) ) {
                    player.ui.pGuidance.close();
                    player.guidanceShow(false);
                }
            },500);


        },
        requestGuidanceAndPlay : function(nonUserBypass) {
            var player = this;

            if (player.guidanceOk) {

                // XXX don't like inPrepPlayState being a UI feature
                // here but it's used similarly elsewhere and likely
                // needs rationalising properly as a larger refactor.
                if (!nonUserBypass && player.ui.inPrePlayState) {
                    player.dispatch({type:"userPlay"});
                }

                player.dispatch({type:"playRequested"}, true);

                if (player.config.playVideoExternally && !player.playlistHasAudio) {
                    player.playInBump();
                    return;
                }

                player.startPlayback(nonUserBypass);
                return;
            }
            player.mediaPlayer.autoplay = false;
            if (DEBUG_FULL) { console.log('Requesting guidance'); }
            player.guidanceShow(false);
        },

        guidanceShow : function(lockClicked) {

            var player = this;

            distributeEvent(player,{type:"guidanceShown"});

            var guidanceObject = {type:"guidanceShow", guidance:player.playlist.guidance,title:player.playlist.title,  lockClicked : lockClicked };

            if ( (player.mediaContainer.clientWidth < 400 || player.mediaContainer.clientHeight < 400) || !player.ui.config.useInPlayerGuidance ) {
                if (player.iframeFullscreen) {
                    player.minimise();
                }
                distributeEvent(player,guidanceObject);
            } else {
                player.ui.pGuidance.showInPlayerGuidance( guidanceObject, player.mediaContainer);
            }
        },
        loadPlaylistUrl : function(playlistUrl, xdCall) {
            var player = this;
            if (!Utils.isValidUrl(playlistUrl)) {
                Utils.callErrorFunction(player, SMPError.NON_BBC_PLAYLIST);
                return;
            }
            if (player.loadingPlaylistURL == playlistUrl && player.playlist.loading) {
                if (DEBUG_FULL) { console.log("Not Loading Playlist as it's the same as the currently loading one"); }
                return;
            }
            player.loadPlaylist(playlistUrl, xdCall);
        },
        loadPlaylistObject : function(playlistObject, xdCall) {
            var player = this;
            player.loadPlaylist(playlistObject, xdCall);
        },
        loadPlaylist : function(playlist, xdCall, fromQueue) {
            var player = this;
            var playlistInfo = playlist;
            var playlistObject = null;
            var validPlaylist = false;

            if (typeof playlist == 'object') {
                playlistInfo = "playlist_" + (loadPlaylistCount++);
                playlistObject = playlist;
                validPlaylist = true;
            } else {
                if ((playlist + '').match(/(^[a-zA-Z]+\:)?\/\//)) {
                    validPlaylist = true;
                }
            }

            player.loadingPlaylistURL = playlistInfo;

            distributeEvent(player, {type: "playlistLoading", url: playlistInfo, statsObject:player.config.statsObject});

            player.reset(fromQueue);
            player.actionFnObjAfterWaiting = null;
            player.state = 'busy';

            if (validPlaylist) {
                setLoadPlaylistCallbacks(player, playlistInfo, playlistObject, fromQueue);
                if (DEBUG_FULL) { console.log("xdCall is:"+xdCall); }
                if (xdCall) {
                    if (!player.willAutoplayWhenPlayCalled[player.playlist.mediaType]) {
                        if (player.firstPlaylist && Device.notWorthTryingAutoplay) {
                            if (DEBUG_FULL) { console.log("Setting autoplay to false in the config as nonUserBypass true and we can't autoplay "); }

                            player.config.autoplay = false;
                        }
                    }
                } else {
                    if (player.config.autoplay) {
                        // only attempt to set the blank media if we have a
                        // valid user click and aren't coming through XD
                        setBlankMedia(player, player.playlist.mediaType); // For autoplay on loadplaylist
                        player.dispatch({type:"playRequested"}, true);
                    }
                }
            } else {
                player.delayedDispatch( SMPError.getError(SMPError.NO_ITEMS) );
                Utils.asyncDelay(function() {
                    // If someone loads a playlist in response to the error
                    // we shouldn't then say the first playlist has finished loading
                    // so if loadingPlaylistURL has a different value, something has tried to do something
                    // and we should stop trying to do something
                    if (player.loadingPlaylistURL === playlistInfo) {
                        distributeEvent(player, {type: "playlistLoaded", url: playlistInfo, fromQueue: fromQueue, playlist: playlist});
                    }
                });
            }

            if (!fromQueue) {
                player.unsetGuidanceSkippedIfUnder16();
            }
            player.firstPlaylist = false;
        },
        reset : function(noPreloadReset) {
            var player = this;


            if (DEBUG_FULL) { console.log("Player.reset()"); }

            player.swf.kill();

            player.resettingIndexInPlaylistEnd = false;
            player.streamFailing = false;
            player.autoplayTimeoutRetryAttempted = false;
            player.failingOver = false;
            player.failedOver = false;
            player.inErrorState = false;
            player.reloadToStart = false;
            player.endOnWaiting = false;

            player.clearFakeTimer();
            clearTimeout(player.playingTimer);

            hidePlayer(player, player.elType, true);
            // Reset playbackRate and dash
            player.mediaPlayer.playbackRate = 1;
            player.dashEvents.reset();
            player.elType = "unknown";
            player.tryingToPlay = false;

            player.timeHelper.reset();

            Utils.clearPendingReqs();

            if (!noPreloadReset) {
                if (player.preloadDashEvents) {
                    player.preloadDashEvents.reset();
                    player.preloadDashEvents = null;
                }
                if (player.preloadStoredErrors) {
                    //We're losing this data for the moment if !noPreloadReset - only gets transmitted if we do move on to the next media item.
                    player.preloadStoredErrors = null;
                }
            }

            if (player.preloadCallback) {
                player.timeHelper.clearPlaybackTimeout(player.preloadCallback);
                player.preloadCallback = null;
            }

            clearTimeout(player.noCanplayEventTimeout);

        },
        playWithUserCheck : function(xdCall) {
            var player = this;
            if (xdCall && player.playlist && !player.willAutoplayWhenPlayCalled[player.playlist.mediaType] && Device.notWorthTryingAutoplay) {
                if (DEBUG_FULL) { console.log("refusing to play because it came via XD"); }
                return;
            }
            player.requestGuidanceAndPlay(xdCall);
        },
        queueNextPlaylist : function(autoplay) {
            var player = this;
            if (player.playlist && player.playlist.queuedPlaylist) {
                Utils.asyncDelay(processQueued,[player,autoplay]);
                return true;
            }
            return false;
        },
        queuePreviousPlaylist : function(autoplay) {
            var player = this;
            if (player.playlist && player.playlist.previousPlaylist) {
                Utils.asyncDelay(processPrevious,[player,autoplay]);
                return true;
            }
            return false;
        },
        resetStatsObject : function() {
            var player = this;
            // XXX reset statsObject for new item this is
            // copied code around a bunch of places across
            // players and bump...  risky
            var statsObj = player.config.statsObject;
            if (statsObj) {
                statsObj.parentPID = undefined;
                statsObj.parentPIDType = undefined;
                statsObj.episodePID = undefined;
                statsObj.clipPID = undefined;
                statsObj.playlistLabels = undefined;
            }
        },
        fallbackAsAppropriate: function() {
            var player = this;
            if (DEBUG_FULL) {
                console.log('fallback as appropriate');
            }
            if (Device.android || Device.kindle) {
                Utils.callErrorFunction(player, SMPError.CANT_PLAY_IN_ANDROID_BROWSER);
                return;
            }
            if (flashAvailable()) {
                if (player.mediaItem) {
                    player.mediaItem.useFlash = true;
                    Utils.asyncDelay(playFlash,[player]);
                }
                return;
            }
            // show flash fallback error message don't
            // store as plugins can be enabled/disabled
            // during runtime
            // show flash fallback error message
            if (DEBUG_FULL) {
                console.log('no flash installed dispatching generic error for now');
            }
            Utils.callErrorFunction(player,SMPError.FLASH_NOT_INSTALLED);
        },
        requestAllEvents : function(eventFunc) {
            if (!allMediaEvents[this.uid]) {
                allMediaEvents[this.uid]=[];
            }
            allMediaEvents[this.uid].push(eventFunc);
        },
        pushMediaEventFunctions : function(eventObject) {

            if(!mediaEventFunctions[this.uid]) {
                mediaEventFunctions[this.uid] = {};
            }

            if(!mediaEventFunctions[this.uid].callbacks) {
                mediaEventFunctions[this.uid].callbacks = [];
            }

            mediaEventFunctions[this.uid].callbacks.push(eventObject);

        },
        trackAction : function(controlId, actionType, additionalParams) {
            this.dispatch({type: "SonarUserActionEvent", controlId: controlId, actionType: actionType, labels: additionalParams });
        },
        dispatch : function(event,internal) {
            distributeEvent(this,event,internal);
        },
        delayedDispatch : function(event,internal){
            var player = this;
            Utils.asyncDelay(distributeEvent,[player,event,internal]);
        },
        clearFakeTimer : function() {
            var player = this;
            if (player.fakeTimeupdateTimer) {
                clearInterval(player.fakeTimeupdateTimer);
                player.fakeTimeupdateTimer = null;
            }
        },
        onAdsProcessed : function(data){
            LoadBalancing.onAdsProcessed(this.mediaItem, data);
            pickInitialConnection(this);
        },
        captureIntent : function(type) {
            if (type!=="audio") {
                type = "video";
            }
            setBlankMedia(this, type);
        },
        updateConfig : function(settings, suppressEvent, suppressConfigDistribution) {
            var player = this;
            var previousUiClass = player.config.uiClass;
            var configToSendToBump = {};

            // should this be configChanged and chuck out the whole config event?
            // currently this is just picked up by bump sonarreporter and doesnt get written to the settings object exposed by bump
            if (settings.counterName !== player.config.counterName){
                if (!suppressEvent) {
                    distributeEvent(player,{
                        type:"statsConfigChanged",
                        counterName: settings.counterName
                    });
                }
            }

            if ( (settings.continuousPlay !== undefined) && (settings.continuousPlay !== player.config.continuousPlay) && !suppressEvent ) {
                this.dispatch({type:'continuousPlayChange', status: settings.continuousPlay});
                configToSendToBump.continuousPlay = settings.continuousPlay;
            }

            player.config = Utils.merge(player.config, settings);
            player.pauseTimes = [];
            // suppress item kind, defaults to an array, but atm we allow
            // users to pass in strings too.
            if (player.config.suppressItemKind && player.config.suppressItemKind.length) {
                if (typeof player.config.suppressItemKind === 'string') {
                    player.config.suppressItemKind = player.config.suppressItemKind.replace(/\s+/gim, '').split(',');
                }
            }

            if (player.config.noTracking) {
                player.config.enableStatsReporting = false;
                player.config.enableRdotReporting = false;
            }

            if (player.config.autoplay=="false") {
                player.config.autoplay = false;
            }

            if (player.config.forceAutoplayAttempt) {
                player.willAutoplayWhenPlayCalled = { video: true, audio: true };
            }

            if (player.config.uiClass && player.config.uiClass!=previousUiClass) {
                Utils.className(document.body, player.config.uiClass, previousUiClass);
            }

            if (!(player.config.preferPlainOverDash && Device.possiblyPreferPlainOverDash) && !Device.preferHls && (Device.supportsAudioDash || Device.supportsVideoDash) && !player.config.delayEmbed) {
                player.dashEvents.create();
            }

            player.config.startTime = player.config.startTime || 0;

            if (!player.config.preferProtocol) {
                var preferHttpsPercentage = player.config.preferHttpsPercentage;
                if (isNaN(preferHttpsPercentage) || preferHttpsPercentage<0 || preferHttpsPercentage>1) {
                    preferHttpsPercentage = 0;
                }
                if (DEBUG_FULL) {
                    console.info('prefer HTTPS percentage is:' + preferHttpsPercentage);
                }
                if (Math.random()<=preferHttpsPercentage) {
                    if (DEBUG_FULL) {
                        console.info('setting preferProtocol https due to preferHttpsPercentage');
                    }
                    player.config.preferProtocol = 'https';
                } else {
                    player.config.preferProtocol = ((location.protocol + '').toLowerCase() === 'https:' ? 'https' : 'http');
                }
            }

            LoadBalancing.setConfig(player.config);


            if (player.config.liveEnvironment) {
                CURRENT_BLANK_MEDIA=BLANK_MEDIA;
            } else {
                CURRENT_BLANK_MEDIA=BLANK_MEDIA_WITH_NOISE;
            }

            if (!suppressEvent) {
                distributeEvent(player,{type:"configUpdated"});
            }

            if (!suppressEvent && !suppressConfigDistribution && !Utils.isObjectEmpty(configToSendToBump)) {
                distributeEvent(player, {
                    type: "configFromPlayer",
                    config: configToSendToBump
                });
            }
        },
        playInBump : function() {
            var player = this;
            // XXX is this now right to change to video when we now
            // fallback everything to bump - need to test audio
            // fallback well here?
            player.elType="video";
            player.waitingForChange.video = false;
            player.dispatch({type:"playInBump"});
            setTimeout(function() {
                           player.dispatch({type:"playlistStopped", target:player.mediaPlayer});
                       },1000);
        },
        fixSize : function(never) {
            if (DEBUG_FULL) { console.log('Player.fixSize never is ' + never); }
            var player = this;

            var html = document.getElementsByTagName('html')[0];
            html.style.backgroundColor="black";

            clearTimeout(player.resizeTimer);

            if (!never && Device.requiresFullscreenResizeDelay) {
                player.ui.enabled = false;
                PluginManager.resizeFix();
                player.Subtitles.resizeFix();
                player.mediaContainer.style.width = "0px";
                player.mediaContainer.style.height = "0px";
                player.resizeTimer = setTimeout(function() {
                    var h = window.innerHeight;
                    var w = window.innerWidth;
                    player.ui.enabled = true;
                    player.mediaContainer.style.height = h + "px";
                    player.mediaContainer.style.width = w + "px";
                    PluginManager.resizeFixEnd();
                    Utils.deleteCssRules(player.ui.stylesheet, [".fullscreen #p_playerControls"]);

                    var newHeight = Math.round(player.ratio * w);
                    if (newHeight > h) {
                        newHeight = h;
                    }

                    if (w > h && player.ui.controls) {
                        var padding = w * (1.5625/100);
                        var bottomOfVideo = Math.round((h - newHeight) / 2 + newHeight - padding);
                        var index = player.ui.stylesheet.cssRules.length;
                        // XXX isn't clientHeight unsafe to use due to
                        // IE11 thing? see needSizingFix ??
                        player.ui.stylesheet.insertRule(".fullscreen #p_playerControls { top: " + (bottomOfVideo - (player.ui.controls.clientHeight)) + "px; }",index);
                    }

                    player.els.video.style.height = newHeight + "px";
                    player.els.video.style.top = Math.round((window.innerHeight - newHeight) / 2) + "px";
                    player.ui.resizeFixEnd(window.innerWidth);
                    PluginManager.resizeFixComplete();
                    player.dashEvents.updatePortalSize();
                    html.style.backgroundColor="transparent";
                }, Device.requiresShortFullscreenResizeDelay ? 200 : 1000);
            } else {
                player.ui.enabled = true;
                PluginManager.resizeFixEnd();

            if (DEBUG_FULL) { console.log('Calling:'+window.innerWidth); }
                player.ui.resizeFixEnd(window.innerWidth);
                player.ui.displayCover();
                PluginManager.resizeFixComplete();
                player.dashEvents.updatePortalSize();
                html.style.backgroundColor="transparent";
            }

            player.dispatch({type:"fixSize"});
        },
        loadPluginCompleted : function(playlistLoadedEvent){
            loadPlaylistComplete(this, playlistLoadedEvent);
        },
        setProtectionData : function(protectionData) {
            var player = this;
            player.storedProtectionData = protectionData;
            if (player.dashEvents && player.dashEvents.src && player.dashEvents.dashPlayer) {
                player.dashEvents.go();
            }
        },
        setQueuedItem : function(data) {
            var player = this;
            player.playlist.queuedPlaylist = data.playlist;
            player.playlist.queuedOptions = data.options;
            if (player.ended || player.playing) {
                Utils.asyncDelay(mediateNextItem,[player, !player.config.disablePreload]);
            }
        },
        setPreviousItem : function(data) {
            var player = this;
            player.playlist.previousPlaylist = data.playlist;
            player.playlist.previousOptions = data.options;
        },
        unsetGuidanceSkippedIfUnder16 : function(){
            var player = this;
            if (player.config.under16) {
                if (!player.config.guidance.hasGuidancePIN) {
                    player.dispatch({type:'setGuidanceSkipped', skipped:false});
                }
                player.dispatch({type:'setUnder16Permission', hasPermission:false});
            }
        },
        updateQuality : function(config) {
            var player = this;
            player.updateConfig(config);

            if (config.lowBandwidth) { //For backwards compatibility, lowBandwidth maps to "low"
                config.quality = "low";
            }

            player.quality = new Quality(config.quality);
        }
    };
    return Player;
})();


/*
 * Sonic 0.1
 * --
 * https://github.com/jamespadolsey/Sonic
 * --
 * This program is free software. It comes without any warranty, to
 * the extent permitted by applicable law. You can redistribute it
 * and/or modify it under the terms of the Do What The Fuck You Want
 * To Public License, Version 2, as published by Sam Hocevar. See
 * http://sam.zoy.org/wtfpl/COPYING for more details. */

function Sonic(canvas) {
    this.canvas = canvas;
}

Sonic.prototype = {
    draw: function() {
        var canvas = this.canvas.getContext('2d');
        this.padding = 2*(Math.ceil(this.thickness / 2) + 1); 
        var w = this.canvas.width = this.canvas.height = this.width + this.padding;
        canvas.clearRect(0, 0, w, w);
        canvas.lineWidth = this.thickness;

        var mid = w/2;
        var r =  Math.floor((w - this.thickness) / 2) - 1;
        var delta = Math.PI/22.5;
        
        var arr=this.colourArray;
        if (arr && arr.length>0) {
            for (var i=0;i<40;i++) {
                canvas.beginPath();
                canvas.globalAlpha = i/40;
                canvas.arc(mid,mid,r,(i+1)*delta,i*delta,true);
                canvas.strokeStyle=arr[i%arr.length];
                canvas.stroke();
            }
        } else {
            canvas.strokeStyle = this.colour;
            for (i=0;i<25;i++) {
                canvas.beginPath();
                canvas.globalAlpha = i/250;
                canvas.arc(mid,mid,r,0,i*delta,true);
                canvas.stroke();
            }
        }
    }
};

// set the document domain to just bbc.co.uk doesn't help with
// embedding on other domains but it allows outside the frame
// controls to work if hosted on *.bbc.co.uk
// could also manage this more dynamically in case hosted elsewhere?

//document.domain can't be set in sandboxed iframe
try {
    var hosts=['bbc.co.uk','bbc.com','britbox.com','bbcrewind.co.uk','bbcconnectedstudio.co.uk'];

    for (var i=0;i<hosts.length;i++) {
        var host=hosts[i];
        if (location.host.indexOf(host) !== -1) {
            document.domain = host;
        }
    }
} catch(e) {}

// Block drag/drop in iframe
document.addEventListener('dragover', function(e) {
    e.preventDefault();
    e.stopPropagation();
});

document.addEventListener('drop', function(e) {
    e.preventDefault();
    e.stopPropagation();
});

xd = new XD();

window.bootstrap = function(data) {
        xd.detach('bootstrap');

        if (!data.requireMap) {
            data.requireMap = {};
        } else {
            try {
                require( { paths : data.requireMap });
            } catch (e) {}
        }
        // XXX still only a single Player possible, and a single
        // DebugConsole
        // refactor this to not require global var.
        window.publicApi = new Player();
        DebugConsole.player(window.publicApi);

        window.publicApi.init(data);
    };

xd.on('bootstrap', window.bootstrap);

</script>
<style></style><link rel="dns-prefetch" href="https://open.stage.bbc.co.uk/"><script type="text/javascript" charset="utf-8" async="" data-requirecontext="_" data-requiremodule="//emp.stage.bbci.co.uk/plugins/onwardJourneyHTML/2.4.0/js/onwardJourney.js" src="./onwardJourney.js"></script><link type="text/css" rel="stylesheet" href="./en.css"></head><body class="news nonPointerFocus font-family-sans classicUI svg video displayCover cta" style="cursor: default;">
<div id="p_background"></div>
<div id="p_alert" role="alert"></div>
<!-- be sure that DOM elements are positioned after the flash container -->
<div id="mediaContainer" class="mediaContainer controlsFadedOut noSeekingBar" style="background-image: url(&quot;http://ichef.bbci.co.uk/images/ic/976x549/p06dh5nw.jpg&quot;);"><video id="p_360_player_0" preload="metadata" crossorigin="anonymous" webkit-playsinline="webkit-playsinline" playsinline="playsinline" aria-hidden="true" style="left: -9999px;"></video><video webkit-playsinline="" playsinline="" preload="metadata" id="p_v_player_0" aria-hidden="true" style="left: -9999px;"></video><div class="p_gradientLayer" style="display: block;"></div><div class="p_gradientBottomfiller" style="display: block;"></div><div id="p_swfcontainer"></div><ul class="p_contextMenu" style="display: none;"><li><a class="p_contextMenuItem" title="2.24.0.4d14091">2.24.0.4d14091</a></li><li><a class="p_contextMenuItem"> <br> </a></li><li><a class="p_contextMenuItem"></a></li><li><a class="p_contextMenuItem"></a></li><li><a class="p_contextMenuItem"></a></li><li><a class="p_contextMenuItem">OnwardJourneyPluginHTML.2.4.0</a></li></ul><div aria-live="polite" role="region" class="p_subtitlesContainer" style="width: 0px; height: 0px; margin-left: 0px; margin-top: 0px; opacity: 0.8;"></div><div class="p_spinner" style="display: none; height: 62px; width: 62px; margin-left: -31px; margin-top: -31px; top: 50%; left: 50%;"><canvas height="62" width="62"></canvas></div><button class="p_button p_cta p_hasDuration font-family-sans" style="display: block; visibility: visible;" title="Play , This is GUIDANCE seperate to the CP CP CP CP CP CP &#24179;&#20206;&#21517;, &#12402;&#12425;&#12364;&#12394; &#24179;&#20206;&#21517;, &#12402;&#12425;&#12364;&#12394;" aria-label="Play , This is GUIDANCE seperate to the CP CP CP CP CP CP &#24179;&#20206;&#21517;, &#12402;&#12425;&#12364;&#12394; &#24179;&#20206;&#21517;, &#12402;&#12425;&#12364;&#12394;"><span class="p_hiddenElement">Play</span><span class="p_ctaDuration">00:03</span><div class="p_iconHolder" style="display: block;"><svg focusable="false" viewBox="0 0 44 44" class="p_svg p_ctaIcon p_playIcon"><use xlink:href="#play"></use></svg></div></button><div class="p_accessibleHitArea notInteractiveContent" role="img" aria-hidden="false" aria-label=" Media"></div><div class="p_playerControls" style="display: none; clip: rect(1px, 1px, 1px, 1px);"><div class="p_playerControlBarHolder" style="display: block;"><button class="p_button p_controlBarButton p_playButton" role="button" aria-live="polite" aria-label="Play" title="Play"><span class="p_hiddenElement" aria-hidden="true">Play</span><div class="p_iconHolder" style="display: block;"><svg focusable="false" viewBox="0 0 44 44" class="p_svg  p_playIcon"><use xlink:href="#play"></use></svg></div></button><div class="p_closed p_volumeControls" aria-hidden="false"><div class="p_sliderContainer" tabindex="-1"><div class="p_sliderControls"><div class="p_volumeBarHolder" style="left: 11px;"><div class="p_volumeBar p_beforeVolume"></div></div><div class="p_volumeBarHolder" style="left: 20px;"><div class="p_volumeBar p_beforeVolume"></div></div><div class="p_volumeBarHolder" style="left: 29px;"><div class="p_volumeBar p_beforeVolume"></div></div><div class="p_volumeBarHolder" style="left: 38px;"><div class="p_volumeBar p_beforeVolume"></div></div><div class="p_volumeBarHolder" style="left: 47px;"><div class="p_volumeBar p_beforeVolume"></div></div><div class="p_volumeBarHolder" style="left: 56px;"><div class="p_volumeBar p_beforeVolume"></div></div><div class="p_volumeBarHolder" style="left: 65px;"><div class="p_volumeBar p_beforeVolume"></div></div><div class="p_volumeBarHolder" style="left: 74px;"><div class="p_volumeBar p_selectedVolume"></div></div><div class="p_volumeBarHolder" style="left: 83px;"><div class="p_volumeBar p_afterVolume"></div></div><div class="p_volumeBarHolder" style="left: 92px;"><div class="p_volumeBar p_afterVolume"></div></div><div class="p_volumeBarHolder" style="left: 101px;"><div class="p_volumeBar p_afterVolume"></div></div><div class="p_volumeLevel" aria-hidden="true">8</div></div><div id="p_volumeHelpText" style="display: none;">Use the arrow keys to increase and decrease the volume</div></div><button class="p_button p_controlBarButton p_volumeButton audio" role="slider" aria-live="polite" aria-label="Mute" title="Mute" aria-describedby="p_volumeHelpText" aria-valuemin="0" aria-valuemax="11" aria-valuetext="Volume level 8" aria-valuenow="8"><span class="p_hiddenElement" aria-hidden="true">Mute</span><div class="p_iconHolder" style="display: block;"><svg focusable="false" viewBox="0 0 44 44" class="p_svg  p_audioIcon"><use xlink:href="#audio"></use></svg></div></button></div><div class="p_controlBarFiller" style="width: 1468px;"><div class="p_timeDisplay" aria-hidden="true" aria-live="off" aria-role="timer" style="display: block;"><span class="p_time"></span><span class="p_timeSeparator" style="display: none;">/</span><span class="p_time p_duration"></span></div></div><button class="p_button p_controlBarButton p_fullscreenButton" role="button" aria-live="polite" aria-label="Enter full screen" title="Enter full screen"><span class="p_hiddenElement" aria-hidden="true">Enter full screen</span><div class="p_iconHolder"><svg focusable="false" viewBox="0 0 44 44" class="p_svg  p_fullscreen-enterIcon"><use xlink:href="#fullscreen-enter"></use></svg></div></button><button class="p_button p_controlBarButton p_subtitleButton p_dontCloseSettingsPanel" role="button" aria-live="polite" aria-label="Turn subtitles on and open subtitles settings menu" title="Turn subtitles on and open subtitles settings menu"><span class="p_hiddenElement" aria-hidden="true">Turn subtitles on and open subtitles settings menu</span><div class="p_selected_background"><div class="p_selected_indicator"></div></div><div class="p_iconHolder"><svg focusable="false" viewBox="0 0 44 44" class="p_svg  p_accessibilityIcon"><use xlink:href="#accessibility"></use></svg></div></button><div id="p_subtitleSettingsContainer" class="p_dontCloseSettingsPanel"><div class="p_subtitleSettingsMask"></div><div class="p_subtitleSettingsBox"><div class="p_subsToggleLabel">Subtitles</div><div class="p_toggle p_subsToggle" role="checkbox" aria-checked="false" aria-label="Subtitles" tabindex="0"><div class="p_toggleText">OFF</div><div class="p_toggleSlot"><div class="p_toggleSlider"><div class="p_tick"></div></div></div></div><div class="p_sizingButtonsContainer"><button id="p_subtitleSizeButton_useSmallestFontSize" class="p_subtitleSizeButton p_button font-family-sans" disabled="" aria-pressed="false" data-sizename="useSmallestFontSize" aria-label="Use font size: Smallest" data-size="0.5"><div>Aa</div></button><button id="p_subtitleSizeButton_useSmallFontSize" class="p_subtitleSizeButton p_button font-family-sans" disabled="" aria-pressed="true" data-sizename="useSmallFontSize" aria-label="Use font size: Small" data-size="0.6"><div>Aa</div></button><button id="p_subtitleSizeButton_useMediumFontSize" class="p_subtitleSizeButton p_button font-family-sans" disabled="" aria-pressed="false" data-sizename="useMediumFontSize" aria-label="Use font size: Medium" data-size="0.67"><div>Aa</div></button><button id="p_subtitleSizeButton_useLargeFontSize" class="p_subtitleSizeButton p_button font-family-sans" disabled="" aria-pressed="false" data-sizename="useLargeFontSize" aria-label="Use font size: Large" data-size="0.82"><div>Aa</div></button><button id="p_subtitleSizeButton_useLargestFontSize" class="p_subtitleSizeButton p_button font-family-sans" disabled="" aria-pressed="false" data-sizename="useLargestFontSize" aria-label="Use font size: Largest" data-size="1"><div>Aa</div></button></div><div id="p_subtitleSizeIndicator" style="left: 50px; display: block;"></div></div><div class="p_downArrow"></div></div><button class="p_button p_controlBarButton p_playbackSettingsButton p_dontCloseSettingsPanel" role="button" aria-live="polite" aria-label="Open playback settings menu for autoplay and video quality settings" title="Open playback settings menu for autoplay and video quality settings"><span class="p_hiddenElement" aria-hidden="true">Open playback settings menu for autoplay and video quality settings</span><div class="p_iconHolder"><svg focusable="false" viewBox="0 0 44 44" class="p_svg  p_playback-settingsIcon"><use xlink:href="#playback-settings"></use></svg></div></button><div id="p_playbackSettingsContainer" class="p_dontCloseSettingsPanel"><div id="p_playbackSettingsMask"></div><div id="p_playbackSettingsBox"><div id="p_playbackSettingsHeading">Playback settings</div><div id="p_panel1"><div id="p_autoplayRow" class="p_settingsRow" style="display: none;"><div id="p_autoplayText" class="p_settingsTextBox"><div id="p_autoplayTitle" class="p_settingsTitle">Autoplay</div><div id="p_autoplaySubtitle" class="p_settingsSubtitle">Play next item automatically</div></div><div id="p_autoplayToggle" class="p_toggle p_toggleOn" role="checkbox" aria-checked="true" aria-label="Autoplay. Play next item automatically" tabindex="0"><div class="p_toggleText">ON</div><div class="p_toggleSlot"><div class="p_toggleSlider"><div class="p_tick"></div></div></div></div></div><div id="p_qualityRow" class="p_settingsRow" aria-label="Video quality. Highest available is currently selected. Open video quality settings" tabindex="0"><div id="p_qualityText" class="p_settingsTextBox"><div id="p_qualityTitle" class="p_settingsTitle"><span>Video quality</span><div id="p_chevronPlaceholder" tabindex="-1"><div class="p_chevronBorder"><div class="p_chevronInside"></div></div></div></div><div id="p_qualitySubtitle" class="p_settingsSubtitle">Highest available</div><div id="p_qualitySubtitleUnavailable" class="p_settingsSubtitleUnavailable">Currently unavailable</div></div></div><ul id="p_qualityListWrap" aria-label="Video quality options"><li id="p_qualityPanelFirstRow" class="p_qualityPanelRow" aria-label="Low quality" tabindex="0"><div id="p_qualityPanelLowRowHeading" class="p_qualityPanelRowHeading"><span>Low</span><div class="p_qualityTick"></div></div></li><li id="p_qualityPanelMediumRow" class="p_qualityPanelRow" aria-label="Medium quality" tabindex="0"><div id="p_qualityPanelMediumRowHeading" class="p_qualityPanelRowHeading"><span>Medium</span><div class="p_qualityTick"></div></div></li><li id="p_qualityPanelHighRow" class="p_qualityPanelRow p_qualitySettingOn" aria-label="Highest quality available selected" tabindex="0"><div id="p_qualityPanelHighRowHeading" class="p_qualityPanelRowHeading"><span>Highest available</span><div class="p_qualityTick"></div></div><div aria-hidden="true" id="p_qualityPanelHighRowSubtitle" class="p_qualityPanelRowSubtitle"><span>Automatically selects the best quality available</span></div></li></ul></div></div><div class="p_downArrow"></div></div><button class="p_button p_controlBarButton p_chromecastButton" role="button" aria-live="polite" aria-label="Cast this programme" title="Cast this programme"><span class="p_hiddenElement" aria-hidden="true">Cast this programme</span><div class="p_selected_background"><div class="p_selected_indicator"></div></div><div class="p_iconHolder"><svg focusable="false" viewBox="0 0 44 44" class="p_svg  p_chromecastIcon"><use xlink:href="#chromecast"></use></svg></div></button><button class="p_button p_controlBarButton p_picInPicButton" role="button" aria-live="polite" aria-label="Open Picture in Picture mode" title="Open Picture in Picture mode"><span class="p_hiddenElement" aria-hidden="true">Open Picture in Picture mode</span><div class="p_selected_background"><div class="p_selected_indicator"></div></div><div class="p_iconHolder"><svg focusable="false" viewBox="0 0 44 44" class="p_svg  p_picInPicIcon"><use xlink:href="#picInPic"></use></svg></div></button><button class="p_button p_controlBarButton p_embedButton" role="button" aria-live="polite" aria-label="Get embed code" title="Get embed code"><span class="p_hiddenElement" aria-hidden="true">Get embed code</span><div class="p_iconHolder"><svg focusable="false" viewBox="0 0 44 44" class="p_svg  p_embedIcon"><use xlink:href="#embed"></use></svg></div></button></div><div class="p_chapterMarkersHolder"><div class="p_chapterTip"><span></span><div class="p_timeTipTriangle"></div></div></div><div class="p_playerSeekBarHolder" aria-hidden="false"><div class="p_bar p_seekBar"><div class="p_seekBarPositionLine"></div><div id="p_seekHelpText" style="display: none;">Use the arrow keys to forward and rewind</div></div><div class="p_bar p_progressBar p_progressBarAvailable"></div><div class="p_bar p_progressBar"></div><button class="p_button p_seekThumb" title="Seek bar" aria-label="Seek bar" role="slider" aria-control="video" aria-valuemin="0" aria-valuemax="100" aria-valuetext="Playback time is 00:00 of 00:00" aria-describedby="p_seekHelpText" style="display: none;"><div class="p_seekThumbLine"></div><div class="p_seekThumbHalo"></div></button></div><div class="p_thumbnail"></div><div class="p_timeTip" aria-hidden="true"><span class="p_timeTipText"></span><div class="p_timeTipTriangle"></div></div></div><div id="p_pluginContainer" class="notInteractiveContent  helper_carouselFadedOut  gcp_nextItemPanelClosed helper_leftGradientFadedIn" style="width: 1603px; height: 902px;"><div class="svgHolder"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="display: none;">

    <symbol id="close" viewBox="0 0 44 44">
        <rect x="20.281" y="8.162" transform="matrix(0.7073 0.7069 -0.7069 0.7073 21.9906 -9.1127)" fill="#FFFFFF" style="fill: inherit" width="3.437" height="27.676"></rect>
        <rect x="20.281" y="8.162" transform="matrix(0.7071 -0.7071 0.7071 0.7071 -9.1127 22)" fill="#FFFFFF" style="fill: inherit" width="3.437" height="27.675"></rect>
    </symbol>
    <symbol id="continuous-play" viewBox="0 0 44 44">
            <path fill="#FFFFFF" style="fill: inherit" d="M27.5,11H11v16.5h16.5V11z M25.438,25.438H13.062V13.062h12.375V25.438z"></path>
            <polygon fill="#FFFFFF" style="fill: inherit" points="30.25,14.438 28.875,14.438 28.875,28.875 14.438,28.875 14.438,30.25 30.25,30.25 "></polygon>
            <polygon fill="#FFFFFF" style="fill: inherit" points="31.625,16.5 31.625,31.625 16.5,31.625 16.5,33 33,33 33,16.5 "></polygon>
            <polygon fill="#FFFFFF" style="fill: inherit" points="16.5,15.125 16.5,23.375 23.114,19.25 "></polygon>
    </symbol>
    <symbol id="duration-clock" viewBox="0 0 25 25">
        <path fill="#FFFFFF" style="fill: inherit" d="M12.5,6C8.91,6,6,8.909,6,12.5c0,3.59,2.91,6.5,6.5,6.5s6.5-2.91,6.5-6.5C19,8.909,16.09,6,12.5,6z M12.5,17.5 c-2.758,0-5-2.243-5-5c0-2.758,2.242-5,5-5c2.757,0,5,2.242,5,5C17.5,15.257,15.257,17.5,12.5,17.5z"></path>
        <polygon fill="#FFFFFF" style="fill: inherit" points="13,9.067 12,9.067 12,12.696 15.227,14.574 15.555,14.005 13,12.117"></polygon>
    </symbol>
    <symbol id="play" viewBox="0 0 44 44">
        <polygon fill="#FFFFFF" style="fill: inherit" points="14.4,33 32.3,22 14.4,11"></polygon>
    </symbol>
    <symbol id="replay" viewBox="0 0 44 44">
        <path fill="#FFFFFF" style="fill: inherit" d="M28.188,23.719c0,3.602-2.93,6.531-6.531,6.531s-6.531-2.93-6.531-6.531c0-3.601,2.93-6.531,6.531-6.531
	c0.115,0,0.229-0.006,0.344,0v-2.75c-0.115-0.004-0.229,0-0.344,0c-5.126,0-9.281,4.156-9.281,9.281
	c0,5.126,4.155,9.281,9.281,9.281s9.281-4.155,9.281-9.281c0-0.116,0.004-0.228,0-0.344h-2.75
	C28.193,23.49,28.188,23.603,28.188,23.719"></path>
        <polygon fill="#FFFFFF" style="fill: inherit" points="23.375,11 23.375,20.625 31.625,15.812 "></polygon>
    </symbol>
    <symbol id="next" viewBox="0 0 44 44">
        <polygon points="35,22 9,6 9,13.2 23.6,22 9,30.8 9,38 "></polygon>
    </symbol>
    <symbol id="previous" viewBox="0 0 44 44">
        <polygon points="9,22 35,6 35,13.2 20.4,22 35,30.8 35,38 "></polygon>
    </symbol>
    <symbol id="tick">
        <polygon points="8.52434955 14.1394665 15.2404 6.13496161 13.8884821 5 8.3073933 11.6518491 5.13348571 8.99155223 4 10.3434701"></polygon>
    </symbol>

</svg></div><div class="gcp_inpageCountdownItem  fadedOut" style="pointer-events: none;"><div class="gcp_inpageCountdownHeader"></div><div class="gcp_inpageCountdownItemContent backgroundFadedOut"></div><div class="gcp_spinnerCountdown" id="gcp_spinnerCountdown"></div></div><ul class="gcp_carouselContainer  fadedOut" style="position: absolute; width: 3302px; pointer-events: none; left: 0px;"><li class="gcp_carouselItem" style="margin-right: 16px;"><div role="&quot;button&quot;" class="gcp_item" href="#" aria-label="Play item 2 of 7 Audio Clip Audio Clip Audio Clip Audio Clip Duration 01:40" title="Audio Clip Audio Clip Audio Clip Audio Clip" tabindex="0" aria-hidden="false">
    <div class="gcp_itemContainer">
        <div class="gcp_itemWrap">
            <div class="gcp_itemCta">
                <svg class="gcp_itemCtaIcon" focusable="false" tabindex="-1">
                     <use xlink:href="#play" width="100%" height="100%"></use>
                </svg>
                <h4 class="gcp_itemDuration backgroundFadedOut" aria-label="Duration 01:40">01:40</h4>
            </div>
            <img src="./p0602lky.jpg" class="gcp_itemImg" aria-hidden="true">
            <div class="gcp_itemImgGradient"></div>
        </div>

        <div class="gcp_infoWrap">
            <h3 class="gcp_itemTitle">Audio Clip Audio Clip Audio Clip Audio Clip</h3>
            <p class="gcp_itemDescription">Here is a description of AUDIO</p>
            <div class="gcp_itemDateHolder">
                <svg class="icon-clock" focusable="false">
                    <use xlink:href="#duration-clock" width="100%" height="100%"></use>
                </svg>
                <h4 class="gcp_itemDate">28 February 2018</h4>
            </div>
        </div>
    </div>
</div></li><li class="gcp_carouselItem" style="margin-right: 16px;"><div role="&quot;button&quot;" class="gcp_item" href="#" aria-label="Play item 1 of 7 Trump baby blimp ready to take first steps Duration 00:03" title="Trump baby blimp ready to take first steps" tabindex="0" aria-hidden="false">
    <div class="gcp_itemContainer">
        <div class="gcp_itemWrap">
            <div class="gcp_itemCta">
                <svg class="gcp_itemCtaIcon" focusable="false" tabindex="-1">
                     <use xlink:href="#play" width="100%" height="100%"></use>
                </svg>
                <h4 class="gcp_itemDuration backgroundFadedOut" aria-label="Duration 00:03">00:03</h4>
            </div>
            <img src="./p06dh5nw.jpg" class="gcp_itemImg" aria-hidden="true">
            <div class="gcp_itemImgGradient"></div>
        </div>

        <div class="gcp_infoWrap">
            <h3 class="gcp_itemTitle">Trump baby blimp ready to take first steps</h3>
            <p class="gcp_itemDescription">Here is a description of TRUMP</p>
            <div class="gcp_itemDateHolder">
                <svg class="icon-clock" focusable="false">
                    <use xlink:href="#duration-clock" width="100%" height="100%"></use>
                </svg>
                <h4 class="gcp_itemDate">123123 DATE</h4>
            </div>
        </div>
    </div>
</div></li><li class="gcp_carouselItem" style="margin-right: 16px;"><div role="&quot;button&quot;" class="gcp_item" href="#" aria-label="Play item 3 of 7 Why the US-China trade war will hit most of our pockets Duration 20:33" title="Why the US-China trade war will hit most of our pockets" tabindex="0" aria-hidden="false">
    <div class="gcp_itemContainer">
        <div class="gcp_itemWrap">
            <div class="gcp_itemCta">
                <svg class="gcp_itemCtaIcon" focusable="false" tabindex="-1">
                     <use xlink:href="#play" width="100%" height="100%"></use>
                </svg>
                <h4 class="gcp_itemDuration backgroundFadedOut" aria-label="Duration 20:33">20:33</h4>
            </div>
            <img src="./p06cvx3j.jpg" class="gcp_itemImg" aria-hidden="true">
            <div class="gcp_itemImgGradient"></div>
        </div>

        <div class="gcp_infoWrap">
            <h3 class="gcp_itemTitle">Why the US-China trade war will hit most of our pockets</h3>
            <p class="gcp_itemDescription">Here is a description of CHINA</p>
            <div class="gcp_itemDateHolder">
                <svg class="icon-clock" focusable="false">
                    <use xlink:href="#duration-clock" width="100%" height="100%"></use>
                </svg>
                <h4 class="gcp_itemDate">NO DATE LOL</h4>
            </div>
        </div>
    </div>
</div></li><li class="gcp_carouselItem" style="margin-right: 16px;"><div role="&quot;button&quot;" class="gcp_item" href="#" aria-label="Play item 4 of 7 WATCH: How to hide your Gmails from prying eyes Duration 04:50" title="WATCH: How to hide your Gmails from prying eyes" tabindex="0" aria-hidden="false">
    <div class="gcp_itemContainer">
        <div class="gcp_itemWrap">
            <div class="gcp_itemCta">
                <svg class="gcp_itemCtaIcon" focusable="false" tabindex="-1">
                     <use xlink:href="#play" width="100%" height="100%"></use>
                </svg>
                <h4 class="gcp_itemDuration backgroundFadedOut" aria-label="Duration 04:50">04:50</h4>
            </div>
            <img src="./p06cvf0m.jpg" class="gcp_itemImg" aria-hidden="true">
            <div class="gcp_itemImgGradient"></div>
        </div>

        <div class="gcp_infoWrap">
            <h3 class="gcp_itemTitle">WATCH: How to hide your Gmails from prying eyes</h3>
            <p class="gcp_itemDescription">Here is a description of 360 video</p>
            <div class="gcp_itemDateHolder">
                <svg class="icon-clock" focusable="false">
                    <use xlink:href="#duration-clock" width="100%" height="100%"></use>
                </svg>
                <h4 class="gcp_itemDate">DATE !@$%^&amp;*()</h4>
            </div>
        </div>
    </div>
</div></li><li class="gcp_carouselItem" style="margin-right: 16px;"><div role="&quot;button&quot;" class="gcp_item" href="#" aria-label="Play item 5 of 7 AUDIO 2 AUDIO 2 AUDIO 2 AUDIO 2 AUDIO 2 AUDIO 2 Duration 2:46:40" title="AUDIO 2 AUDIO 2 AUDIO 2 AUDIO 2 AUDIO 2 AUDIO 2" tabindex="0" aria-hidden="false">
    <div class="gcp_itemContainer">
        <div class="gcp_itemWrap">
            <div class="gcp_itemCta">
                <svg class="gcp_itemCtaIcon" focusable="false" tabindex="-1">
                     <use xlink:href="#play" width="100%" height="100%"></use>
                </svg>
                <h4 class="gcp_itemDuration backgroundFadedOut" aria-label="Duration 2:46:40">2:46:40</h4>
            </div>
            <img src="./p05lfpn8.jpg" class="gcp_itemImg" aria-hidden="true">
            <div class="gcp_itemImgGradient"></div>
        </div>

        <div class="gcp_infoWrap">
            <h3 class="gcp_itemTitle">AUDIO 2 AUDIO 2 AUDIO 2 AUDIO 2 AUDIO 2 AUDIO 2</h3>
            <p class="gcp_itemDescription">Here is a description of GMAIL</p>
            <div class="gcp_itemDateHolder">
                <svg class="icon-clock" focusable="false">
                    <use xlink:href="#duration-clock" width="100%" height="100%"></use>
                </svg>
                <h4 class="gcp_itemDate">DATE XXXX</h4>
            </div>
        </div>
    </div>
</div></li><li class="gcp_carouselItem" style="margin-right: 16px;"><div role="&quot;button&quot;" class="gcp_item" href="#" aria-label="Play item 6 of 7 DINO DINO DINOs " title="DINO DINO DINOs" tabindex="0" aria-hidden="false">
    <div class="gcp_itemContainer">
        <div class="gcp_itemWrap">
            <div class="gcp_itemCta">
                <svg class="gcp_itemCtaIcon" focusable="false" tabindex="-1">
                     <use xlink:href="#play" width="100%" height="100%"></use>
                </svg>
                <h4 class="gcp_itemDuration backgroundFadedOut" aria-label=""></h4>
            </div>
            <img src="./p06j7yg1.jpg" class="gcp_itemImg" aria-hidden="true">
            <div class="gcp_itemImgGradient"></div>
        </div>

        <div class="gcp_infoWrap">
            <h3 class="gcp_itemTitle">DINO DINO DINOs</h3>
            <p class="gcp_itemDescription">Here is a description of more Audio</p>
            <div class="gcp_itemDateHolder">
                <svg class="icon-clock" focusable="false">
                    <use xlink:href="#duration-clock" width="100%" height="100%"></use>
                </svg>
                <h4 class="gcp_itemDate">123 123 123</h4>
            </div>
        </div>
    </div>
</div></li><li class="gcp_carouselItem" style="margin-right: 16px;"><div role="&quot;button&quot;" class="gcp_item" href="#" aria-label="Play item 7 of 7 Clock clock clock " title="Clock clock clock" tabindex="0" aria-hidden="false">
    <div class="gcp_itemContainer">
        <div class="gcp_itemWrap">
            <div class="gcp_itemCta">
                <svg class="gcp_itemCtaIcon" focusable="false" tabindex="-1">
                     <use xlink:href="#play" width="100%" height="100%"></use>
                </svg>
                <h4 class="gcp_itemDuration backgroundFadedOut" aria-label=""></h4>
            </div>
            <img src="./p076y3sj.jpg" class="gcp_itemImg" aria-hidden="true">
            <div class="gcp_itemImgGradient"></div>
        </div>

        <div class="gcp_infoWrap">
            <h3 class="gcp_itemTitle">Clock clock clock</h3>
            <p class="gcp_itemDescription"></p>
            <div class="gcp_itemDateHolder">
                <svg class="icon-clock" focusable="false">
                    <use xlink:href="#duration-clock" width="100%" height="100%"></use>
                </svg>
                <h4 class="gcp_itemDate"></h4>
            </div>
        </div>
    </div>
</div></li></ul><div class="gcp_carouselBackground  fadedOut" style="pointer-events: none;"><p class="gcp_moreContentTitle">More</p><div class="gcp_carouselBackgroundLeftGradient fadedOut   gcp_LeftGradientfadedIn"><p class="gcp_upNextTitle ">Up next</p></div></div><div class="gcp_carouselControls  fadedOut" style="pointer-events: none;"><div class="gcp_carouselControlsButtons">

    <button aria-label="Dismiss autoplay panel" title="Dismiss autoplay panel" class="gcp_panelsClose" tabindex="-1" aria-hidden="true">
        <svg class="gcp_closeSVG" focusable="false">
            <use xlink:href="#close" width="100%" height="100%"></use>
        </svg>
    </button>


    <button class="gcp_carouselControlsPrevious   gcp_inactive" aria-label="Previous clips" title="Previous clips" tabindex="-1" aria-hidden="true">
        <svg focusable="false">
            <use xlink:href="#previous" width="100%" height="100%"></use>
        </svg>
    </button>
    <button class="gcp_carouselControlsNext    gcp_inactive" aria-label="More clips" title="More clips" tabindex="-1" aria-hidden="true">
        <svg focusable="false">
            <use xlink:href="#next" width="100%" height="100%"></use>
        </svg>
    </button>
    
</div></div><div class="gcp_onDemandButtonContainer"><button id="gcp_onDemandButtonContainer" aria-label="Watch more" title="Watch more">
	<p>Watch more</p>
</button></div></div></div>
<script type="text/javascript">
DebugConsole.testShowDebug();
</script>


<div class="p_ctaGuidance p_guidance" style="display: table; visibility: visible;"><div class="p_guidanceContainer"><div class="p_guidanceHolder"><span class="p_guidanceFallback"><span class="p_guidanceFallbackText">G</span></span><div class="p_iconHolder"><svg focusable="false" viewBox="0 0 44 44" class="p_svg  p_guidanceIcon"><use xlink:href="#guidance"></use></svg></div><span class="p_guidanceText" style="margin-left: 25px;">This is GUIDANCE seperate to the CP CP CP CP CP CP &#24179;&#20206;&#21517;, &#12402;&#12425;&#12364;&#12394; &#24179;&#20206;&#21517;, &#12402;&#12425;&#12364;&#12394;</span></div></div><button style="display: none;"></button><span class="guidanceClose" style="display: none;"><div class="p_iconHolder"><svg focusable="false" viewBox="0 0 44 44" class="p_svg  p_crossIcon"><use xlink:href="#cross"></use></svg></div></span></div><script type="text/javascript" src="./dash.all.debug.js"></script><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="176" height="32" viewBox="0 0 176 32" focusable="false">
    <defs>
        <g id="play">
            <polygon points="14.4,33 32.3,22 14.4,11"></polygon>
        </g>
        <g id="play-iplayer">
            <polygon points="19.2,11 13.8,11 13.8,16.5 19.2,16.5 19.2,14.2 28.2,22 19.2,29.8 19.2,19.2 13.8,19.2 13.8,33 19.2,33 31.6,22"></polygon>
        </g>
		<g id="mute">
			<polygon points="22,13.8 17.9,17.9 11,17.9 11,26.1 17.9,26.1 22,30.2"></polygon>
			<rect x="23.7" y="21.3" transform="matrix(0.7072 0.7071 -0.7071 0.7072 23.9848 -13.908)" width="10.2" height="1.4"></rect>
			<rect x="28.1" y="16.9" transform="matrix(0.7072 0.707 -0.707 0.7072 23.9802 -13.9074)" width="1.4" height="10.2"></rect>
		</g>
        <g id="audio">
            <path d="M25.7,14.3l-1,1c1.7,1.7,2.8,4.1,2.8,6.7c0,2.6-1.1,5-2.8,6.7l1,1c2-2,3.2-4.7,3.2-7.7C28.9,19,27.7,16.3,25.7,14.3z"></path>
            <path d="M28.6,11.4l-1,1c2.5,2.5,4,5.9,4,9.7s-1.5,7.2-4,9.7l1,1C31.3,29.9,33,26.1,33,22C33,17.9,31.3,14.1,28.6,11.4z"></path>
            <polygon points="22,13.8 17.9,17.9 11,17.9 11,26.1 17.9,26.1 22,30.2"></polygon>
        </g>
        <g id="play-iplayer-audio">
            <path d="M26,14.5l-1,1c1.7,1.7,2.7,4,2.7,6.6c0,2.6-1,4.9-2.7,6.6l1,1c1.9-1.9,3.1-4.6,3.1-7.5C29.1,19.1,27.9,16.5,26,14.5z"></path>
            <path d="M28.8,11.7l-1,1c2.4,2.4,3.9,5.8,3.9,9.4c0,3.7-1.5,7-3.9,9.4l1,1c2.6-2.7,4.3-6.3,4.3-10.4C33.1,18,31.5,14.3,28.8,11.7z"></path>
            <polygon points="15.4,13.2 11,13.2 11,17.6 15.4,17.6 15.4,15.8 22.5,22 15.4,28.2 15.4,19.8 11,19.8 11,30.8 15.4,30.8 25.3,22"></polygon>
        </g>
        <g id="volume">
            <path d="M25.7,14.3l-1,1c1.7,1.7,2.8,4.1,2.8,6.7s-1.1,5-2.8,6.7l1,1c2-2,3.2-4.7,3.2-7.7C28.9,19,27.7,16.3,25.7,14.3z"></path>
            <path d="M28.6,11.4l-1,1c2.5,2.5,4,5.9,4,9.7c0,3.8-1.5,7.2-4,9.7l1,1C31.3,29.9,33,26.1,33,22C33,17.9,31.3,14.1,28.6,11.4z"></path>
            <polygon points="22,13.8 17.9,17.9 11,17.9 11,26.1 17.9,26.1 22,30.2"></polygon>
        </g>
        <g id="pause">
            <rect x="13.1" y="11" width="6.2" height="22"></rect>
            <rect x="24.8" y="11" width="6.2" height="22"></rect>
        </g>
        <g id="fullscreen-enter">
            <path d="M26.1,19.2v6.9h-8.2v-8.2h8.2 M27.5,16.5h-11v11h11V16.5L27.5,16.5z"></path>
            <polygon points="25.4,11 33,11 33,18.6"></polygon>
            <polygon points="18.6,11 11,11 11,18.6"></polygon>
            <polygon points="25.4,33 33,33 33,25.4"></polygon>
            <polygon points="18.6,33 11,33 11,25.4"></polygon>
        </g>
        <g id="fullscreen-return">
            <polygon points="28,12 20,12 20,4"></polygon>
            <polygon points="4,12 12,12 12,4"></polygon>
            <polygon points="28,20 20,20 20,28"></polygon>
            <polygon points="4,20 12,20 12,28"></polygon>
            <rect x="1" width="30" height="2"></rect>
            <rect x="1" y="30.5" width="30" height="2"></rect>
            <rect width="2" height="32"></rect>
            <rect x="30" width="2" height="32"></rect>
        </g>
        <g id="embed">
            <polygon points="17.9,19.4 17.9,15.1 11,21.9 17.9,28.9 17.9,24.5 15.3,21.9 "></polygon>
            <polygon points="26.1,24.5 26.1,28.9 33,21.9 26.1,15.1 26.1,19.4 28.7,21.9 "></polygon>
            <rect x="18.3" y="21.4" transform="matrix(0.7071 -0.7071 0.7071 0.7071 -9.1427 22.0532)" width="7.5" height="1.4"></rect>
        </g>
        <g id="guidance">
            <circle fill="inherit" cx="22" cy="22" r="11"></circle>
            <path fill="currentColor" d="M27.1,27.5h-1.8L25,26.3c-0.8,1.1-2,1.4-3.1,1.4c-3.3,0-5.5-2.5-5.5-5.7c0-3.2,2.2-5.7,5.5-5.7c2.3,0,4.7,1.2,5,4h-2.9c-0.1-0.9-1-1.5-2.2-1.5c-1.8,0-2.6,1.6-2.6,3.3c0,1.6,0.7,3.3,2.6,3.3c1.4,0,2.4-0.7,2.5-1.7h-2v-2.1h4.6V27.5z"></path>
        </g>
        <g id="padlock-locked">
            <rect x="13.1" y="20.6" width="17.9" height="12.4"></rect>
            <path d="M22,14.4c1.5,0,2.8,1.2,2.8,2.8v8.2c0,1.5-1.2,2.8-2.8,2.8c-1.5,0-2.8-1.2-2.8-2.8v-8.2C19.2,15.7,20.5,14.4,22,14.4M22,11c-3.4,0-6.2,2.8-6.2,6.2v8.2c0,3.4,2.8,6.2,6.2,6.2c3.4,0,6.2-2.8,6.2-6.2v-8.2C28.2,13.8,25.4,11,22,11L22,11z"></path>
        </g>
        <g id="padlock-unlocked">
            <path d="M26.8,11c-3.4,0-6.2,2.8-6.2,6.2v3.4h-4.8h-3.4H11V33h15.8V20.6h-2.1h-0.7v-3.4c0-1.5,1.2-2.8,2.8-2.8c1.5,0,2.8,1.2,2.8,2.8v3.4H33v-3.4C33,13.8,30.2,11,26.8,11z"></path>
        </g>
        <g id="cross">
            <rect x="20.3" y="8.2" transform="matrix(0.7071 0.7071 -0.7071 0.7071 22 -9.1127)" width="3.4" height="27.7"></rect>
            <rect x="20.3" y="8.2" transform="matrix(0.7071 -0.7071 0.7071 0.7071 -9.1127 21.9994)" width="3.4" height="27.7"></rect>
        </g>
        <g id="chromecast">
            <path d="M19.9,30.4H18c-0.5-3.6-3.4-6.5-7-7v-1.9           C15.7,22.1,19.4,25.7,19.9,30.4z M16.6,30.4h-1.9c-0.4-1.8-1.8-3.2-3.7-3.7v-1.9C13.8,25.3,16.1,27.6,16.6,30.4z M13.2,30.4H11           v-2.2C12,28.6,12.8,29.4,13.2,30.4z"></path>
            <path d="M21.5,29.1c-0.1-0.6-0.3-1.2-0.5-1.7h10.3V15.3l-17.3,0v5.1           c-0.6-0.2-1.1-0.4-1.7-0.5v-6.3H33v15.5H21.5z"></path>
        </g>
        <g id="closed-captions">
            <path d="M11,14v16h22V14H11z M21.5,20.9h-1.8v-0.1c0-0.1-0.1-0.2-0.1-0.3c-0.1-0.1-0.2-0.2-0.3-0.3                 c-0.1-0.1-0.2-0.2-0.4-0.2c-0.1,0-0.3,0-0.4,0c-0.3,0-0.5,0.1-0.7,0.2c-0.2,0.1-0.4,0.3-0.5,0.4c-0.1,0.2-0.2,0.4-0.3,0.7                 c-0.1,0.3-0.1,0.5-0.1,0.8c0,0.3,0,0.5,0.1,0.8c0.1,0.2,0.2,0.4,0.3,0.6s0.3,0.3,0.5,0.4c0.2,0.1,0.4,0.2,0.7,0.2                 c0.4,0,0.7-0.1,0.9-0.3c0.2-0.2,0.4-0.3,0.4-0.7h1.7v0.1c0,0.4-0.1,0.7-0.3,1c-0.1,0.2-0.3,0.4-0.6,0.7c-0.3,0.2-0.6,0.4-0.9,0.5                 c-0.4,0.1-0.7,0.2-1.2,0.2s-1-0.1-1.4-0.3c-0.4-0.2-0.8-0.4-1.1-0.8c-0.3-0.3-0.5-0.7-0.7-1.1c-0.2-0.4-0.2-0.9-0.2-1.4                 s0.1-1,0.2-1.4c0.2-0.4,0.4-0.8,0.7-1.2c0.3-0.3,0.7-0.6,1.1-0.8c0.4-0.2,0.9-0.3,1.4-0.3c0.4,0,0.7,0.1,1.1,0.2                 c0.3,0.1,0.6,0.3,0.9,0.5s0.5,0.5,0.7,0.8c0.2,0.3,0.3,0.6,0.3,1V20.9z M28.9,20.9h-1.8v-0.1c0-0.1-0.1-0.2-0.1-0.3                 c-0.1-0.1-0.2-0.2-0.3-0.3c-0.1-0.1-0.2-0.2-0.4-0.2c-0.1,0-0.3,0-0.4,0c-0.3,0-0.5,0.1-0.7,0.2c-0.2,0.1-0.4,0.3-0.5,0.4                 c-0.1,0.2-0.2,0.4-0.3,0.7c-0.1,0.3-0.1,0.5-0.1,0.8c0,0.3,0,0.5,0.1,0.8c0.1,0.2,0.2,0.4,0.3,0.6c0.1,0.2,0.3,0.3,0.5,0.4                 c0.2,0.1,0.4,0.2,0.7,0.2c0.4,0,0.7-0.1,0.9-0.3s0.4-0.3,0.4-0.7h1.7v0.1c0,0.4-0.1,0.7-0.3,1c-0.1,0.2-0.3,0.4-0.6,0.7                 c-0.3,0.2-0.6,0.4-0.9,0.5c-0.4,0.1-0.7,0.2-1.2,0.2s-1-0.1-1.4-0.3s-0.8-0.4-1.1-0.8c-0.3-0.3-0.5-0.7-0.7-1.1                 c-0.2-0.4-0.2-0.9-0.2-1.4s0.1-1,0.2-1.4c0.2-0.4,0.4-0.8,0.7-1.2c0.3-0.3,0.7-0.6,1.1-0.8c0.4-0.2,0.9-0.3,1.4-0.3                 c0.4,0,0.7,0.1,1.1,0.2c0.3,0.1,0.6,0.3,0.9,0.5c0.3,0.2,0.5,0.5,0.7,0.8c0.2,0.3,0.3,0.6,0.3,1V20.9z"></path>
        </g>
        <g id="catcast">
            <path d="M10.4,30.7C10.4,30.8,10.4,30.8,10.4,30.7l1.3,0c0,0,0,0,0,0c0-2.1-1.7-3.7-3.7-3.7v1.3                 C9.3,28.3,10.4,29.4,10.4,30.7z"></path>
            <path d="M9.2,30.8C9.2,30.8,9.2,30.8,9.2,30.8c0-0.7-0.6-1.3-1.2-1.3v1.3H9.2z"></path>
            <path d="M12.9,30.7C12.9,30.8,12.9,30.8,12.9,30.7l1.3,0c0,0,0,0,0,0c0-3.4-2.8-6.2-6.2-6.2v1.3                 C10.7,25.8,12.9,28,12.9,30.7z"></path>
            <path d="M32,26.7l5.8-4.1l-6.4,2.4c-0.1-2.6-1-5.2-2.7-7.2l0.6-4.7l-3.5,2.2c-1.9-1.2-4-1.8-6.2-1.8                 c-2.2,0-4.3,0.6-6.2,1.8L10,13.2l0.6,4.7c-1.1,1.3-1.9,2.8-2.3,4.4l0,0.6l0.5,0c0.2,0,0.4,0,0.7,0c3.5,0,6.3,2.8,6.3,6.3                 c0,0,0,0,0,0c0,0,0,0,0,0l0,0.5h18.8l-2.8-1.5l3.7-0.9L32,26.7z M13.6,20.4c-0.7,0-1.3-0.6-1.3-1.3s0.6-1.3,1.3-1.3                 s1.3,0.6,1.3,1.3S14.3,20.4,13.6,20.4z M21.5,21.7c-0.3,0.2-0.7,0.5-1,0.7c-0.3,0.2-0.6,0.2-0.9,0c-0.3-0.3-0.6-0.5-1-0.7                 c-0.5-0.3-0.4-1.1,0.2-1.3c0.4-0.1,0.8-0.1,1.2-0.1s0.8,0,1.2,0.1C21.9,20.6,22.1,21.4,21.5,21.7z M25.9,20.4                 c-0.7,0-1.3-0.6-1.3-1.3s0.6-1.3,1.3-1.3s1.3,0.6,1.3,1.3S26.6,20.4,25.9,20.4z"></path>
        </g>
        <g id="subtitles">
            <path d="M11,12v22h22V12H11z M22,28.8c-2.5,0-4.8-0.8-4.8-3.8h2.9c0.1,1,0.9,1.6,2.1,1.6c0.9,0,1.8-0.4,1.8-1.2                 c0-1-1.6-1.2-3.2-1.6c-1.6-0.4-3.2-1.2-3.2-3.2c0-2.4,2.4-3.3,4.5-3.3c2.2,0,4.4,0.6,4.4,3.6h-2.9c0-1-0.9-1.4-1.8-1.4                 c-0.6,0-1.4,0.2-1.4,0.9c0,0.8,1.6,1,3.2,1.4c1.6,0.4,3.2,1.2,3.2,3.2C26.8,27.9,24.4,28.8,22,28.8z"></path>
        </g>
        <g id="alert">
            <path d="M0,44h50.3L25.1,0L0,44z M22,14.1h6.3v15.7H22V14.1z M22,33h6.3v6.3H22V33z"></path>
        </g>
        <g id="refresh">
            <path d="M33,1.5h-8h-4v0V5v0.7v7.8h4V8.1c2.4,2.2,4,5.4,4,8.9c0,6.6-5.4,12-12,12v4c8.8,0,16-6.9,16-15.8                 c0-4.8-2.1-9.8-5.4-11.8H33V1.5z"></path>
            <path d="M9,25.9c-2.4-2.2-4-5.4-4-8.9c0-6.6,5.4-12,12-12V1C8.2,1,1,8.4,1,17.2c0,4.8,2.1,9.3,5.4,12.3H1v4h8h4v-1V29              v-0.7v-6.8H9V25.9z"></path>
        </g>
        <g id="picInPic">
            <path d="M29,0v13h-2V2H2v15h11v2H0V0H29z M32,15H15v9h17V15z"></path>
            <polygon points="5.8,4.4 4.4,5.8 9.6,11 6.7,11 6.7,13 13,13 13,6.7 11,6.7 11,9.6"></polygon>
        </g>
        <g id="picInPic-stop">
            <path d="M29,0v13h-2V2H2v15h11v2H0V0H29z M32,15H15v9h17V15z M12.2,13.6l1.4-1.4L8.4,7H11V5H5v6h2V8.4L12.2,13.6z"></path>
        </g>

        <g id="gel-exitLink">
            <path d="M9.8,8l6.2,6.2L14.2,16L8,9.8L1.8,16L0,14.2L6.2,8L0,1.8L1.8,0L8,6.2L14.2,0L16,1.8L9.8,8z"></path>
        </g>

        <g id="guidance-alert">
            <path d="M8,0L0,14h16L8,0z M9,12.5H7v-2h2V12.5z M7,9.5v-5h2v5H7z"></path>
        </g>

        <g id="accessibility">
            <path d="M15.76,23.91h7.5V22.66h-7.5v1.25Zm-2.5-9V26.05h8.13v3.09l3.44-3.09h5.94V14.92ZM32,27.58H25.26L20.14,32V27.58H12V13.75H32V27.58Zm-5-7.5H17v1.25H27Zm-2.5,2.61h3.75v1.14H24.51V22.69Z"></path>
        </g>

        <g id="playback-settings">
            <path d="M22.76522,23.847576 C21.7467559,24.2695688 20.5757973,23.785077 20.1528122,22.7645945 C19.7303271,21.744612 20.21531,20.575132 21.234774,20.1521393 C22.254238,19.7306465 23.4246967,20.2146382 23.8476818,21.2341207 C24.2706668,22.2546033 23.784184,23.4260832 22.76522,23.847576 M29.8439701,23.8605758 L28.0525333,23.1185885 C28.1885285,22.3896009 28.1955283,21.6326139 28.0560332,20.8801268 L29.8439701,20.1396395 C29.9724655,20.0861404 30.0339634,19.9376429 29.9809652,19.8096451 L29.1919931,17.9051777 C29.139495,17.7776799 28.9910002,17.715681 28.8630047,17.7691801 L27.0735679,18.5101674 C26.6400832,17.8791782 26.0996023,17.3481873 25.4891238,16.9286945 L26.2310976,15.1377251 C26.2840957,15.0092273 26.2225979,14.8607299 26.0941025,14.8077308 L24.1906696,14.0192443 C24.0626742,13.9657452 23.9146794,14.0277441 23.8611813,14.1562419 L23.1192075,15.9472113 C22.3902332,15.8122136 21.6327599,15.8047137 20.8807865,15.9442113 L20.1393127,14.1562419 C20.0863145,14.0277441 19.9378198,13.9657452 19.8093243,14.0192443 L17.9058915,14.8077308 C17.777396,14.8617299 17.7153982,15.0102273 17.7693963,15.1377251 L18.5098702,16.9271945 C17.8798924,17.3596871 17.3489112,17.9001778 16.929926,18.5106674 L15.1384892,17.7686801 C15.0104937,17.715681 14.861499,17.7776799 14.8090008,17.9051777 L14.0200287,19.8096451 C13.9670305,19.9376429 14.0280284,20.0861404 14.1570238,20.1396395 L15.9479606,20.8816268 C15.8129654,21.6091143 15.8049657,22.3666013 15.9444607,23.1190885 L14.1560239,23.8605758 C14.0275284,23.9135748 13.9655306,24.0620723 14.0195287,24.1905701 L14.8090008,26.0945375 C14.8619989,26.2225353 15.0104937,26.2845342 15.1384892,26.2315352 L16.927426,25.4900479 C17.3609107,26.121037 17.9008917,26.651528 18.5113701,27.0700208 L17.7698963,28.8619901 C17.7163982,28.9899879 17.777896,29.1384854 17.9063915,29.1919845 L19.8103243,29.980471 C19.9388197,30.03447 20.0868145,29.9724711 20.1398126,29.8439733 L20.8817865,28.052504 C21.6102607,28.1875017 22.367234,28.1955015 23.1207074,28.0555039 L23.8616813,29.8439733 C23.9151794,29.9724711 24.0636741,30.03347 24.1916696,29.980471 L26.0951024,29.1914845 C26.2235979,29.1384854 26.2850957,28.9899879 26.2320976,28.8619901 L25.4901238,27.0730207 C26.1216015,26.6395282 26.6515828,26.0995374 27.071068,25.4890479 L28.8625047,26.2310352 C28.9900002,26.2845342 29.139495,26.2225353 29.1919931,26.0945375 L29.9809652,24.1905701 C30.0339634,24.0620723 29.9724655,23.9130749 29.8439701,23.8605758"></path>
        </g>

        <symbol id="live-pulse" viewBox="0 0 12 12">
            <path id="liveIconRing" d="M5.96681502,10.3410568 C8.38342771,10.3410568 10.3424794,8.38388329 10.3424794,5.96958745 C10.3424794,3.5552916 8.38342771,1.59811812 5.96681502,1.59811812 C3.55020233,1.59811812 1.59115067,3.5552916 1.59115067,5.96958745 C1.59115067,8.38388329 3.55020233,10.3410568 5.96681502,10.3410568 Z M5.96681502,11.930682 C2.67143408,11.930682 0,9.26180906 0,5.96958745 C0,2.67736584 2.67143408,0.00849290887 5.96681502,0.00849290887 C9.26219596,0.00849290887 11.93363,2.67736584 11.93363,5.96958745 C11.93363,9.26180906 9.26219596,11.930682 5.96681502,11.930682 Z"></path>
            <circle id="liveIconCentre" cx="6" cy="6" r="3"></circle>
        </symbol>

    </defs>
</svg></body></html>